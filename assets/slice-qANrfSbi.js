import{assert as c}from"./hooks-BXO4d1DJ.js";import{createAction as v,createSlice as O}from"./redux-toolkit.esm-BnRUBto_.js";import{OffchainOrderType as T}from"./types-DbOmsKtk.js";import{Routing as l,getInterfaceTransaction as A,getWalletTransaction as C,isBridgeTypeInfo as N,isUniswapX as y}from"./selectors-BwkayGDl.js";import{TransactionStatus as p,TransactionType as f}from"./transactionDetails-BsNW_jus.js";let d=(function(t){return t.SIGN_UNISWAPX_ORDER="signUniswapXOrder",t.SIGN_UNISWAPX_V2_ORDER="signUniswapXV2Order",t.SIGN_UNISWAPX_V3_ORDER="signUniswapXV3Order",t.SIGN_LIMIT="signLimit",t.SIGN_PRIORITY_ORDER="signPriorityOrder",t})({});const P={[T.DUTCH_AUCTION]:d.SIGN_UNISWAPX_ORDER,[T.DUTCH_V2_AUCTION]:d.SIGN_UNISWAPX_V2_ORDER,[T.DUTCH_V3_AUCTION]:d.SIGN_UNISWAPX_V3_ORDER,[T.LIMIT_ORDER]:d.SIGN_LIMIT,[T.PRIORITY_ORDER]:d.SIGN_PRIORITY_ORDER};function W(t){switch(t.type){case d.SIGN_UNISWAPX_ORDER:return l.DUTCH_LIMIT;case d.SIGN_UNISWAPX_V2_ORDER:return l.DUTCH_V2;case d.SIGN_UNISWAPX_V3_ORDER:return l.DUTCH_V3;case d.SIGN_PRIORITY_ORDER:return l.PRIORITY;default:return l.CLASSIC}}const E=t=>t.type===f.Bridge?l.BRIDGE:l.CLASSIC;function F(t,o=!1){const n=o&&t.typeInfo.type===f.Bridge&&t.typeInfo.depositConfirmed;return t.status===p.Pending&&!t.cancelled&&!n}function G(t){return t.status===p.Success||t.status===p.Failed}const R={};function m({state:t,address:o,chainId:n,id:i,actionName:a}){var e;const r=(e=t[o])===null||e===void 0||(e=e[n])===null||e===void 0?void 0:e[i];c(r,`${a}: Attempted to access a missing transaction with id ${i}`);const s=A(r);return c(s,`${a}: Attempted to access a non-interface transaction with id ${i}`),s}function h({state:t,address:o,chainId:n,id:i,actionName:a}){var e;const r=(e=t[o])===null||e===void 0||(e=e[n])===null||e===void 0?void 0:e[i];c(r,`${a}: Attempted to access a missing transaction with id ${i}`);const s=C(r);return c(s,`${a}: Attempted to access a non-wallet transaction with id ${i}`),s}const I=O({name:"transactions",initialState:R,reducers:{addTransaction:(t,{payload:o})=>{var n,i;const{chainId:a,id:e,from:r}=o;c(!(!((n=t[r])===null||n===void 0||(n=n[a])===null||n===void 0)&&n[e]),`addTransaction: Attempted to overwrite tx with id ${e}`),t[r]??(t[r]={}),(i=t[r])[a]??(i[a]={}),t[r][a][e]=o},updateTransaction:(t,{payload:o})=>{var n;const{chainId:i,id:a,from:e}=o;c((n=t[e])===null||n===void 0||(n=n[i])===null||n===void 0?void 0:n[a],`updateTransaction: Attempted to update a missing tx with id ${a}`),t[e][i][a]=o},updateTransactionWithoutWatch:(t,{payload:o})=>{var n;const{chainId:i,id:a,from:e}=o;c((n=t[e])===null||n===void 0||(n=n[i])===null||n===void 0?void 0:n[a],`updateTransactionWithoutWatch: Attempted to update a missing tx with id ${a}`),t[e][i][a]=o},finalizeTransaction:(t,{payload:o})=>{const{chainId:n,id:i,status:a,receipt:e,from:r,hash:s,networkFee:_}=o,u=h({state:t,address:r,chainId:n,id:i,actionName:"finalizeTransaction"});c(u,`finalizeTransaction: Attempted to finalize a non-wallet transaction with id ${i}`),u.status=a,e&&(u.receipt=e),_&&(u.networkFee=_),y(o)&&a===p.Success&&(c(s,"finalizeTransaction: Attempted to finalize an order without providing the fill tx hash"),t[r][n][i].hash=s)},interfaceFinalizeTransaction(t,{payload:{chainId:o,hash:n,address:i,status:a,info:e}}){var r;const s=(r=t[i])===null||r===void 0||(r=r[o])===null||r===void 0?void 0:r[n];s&&(t[i][o][n]={...s,status:a,confirmedTime:Date.now(),typeInfo:e??s.typeInfo})},deleteTransaction:(t,{payload:{chainId:o,id:n,address:i}})=>{var a;c((a=t[i])===null||a===void 0||(a=a[o])===null||a===void 0?void 0:a[n],`deleteTransaction: Attempted to delete a tx that doesn't exist with id ${n}`),delete t[i][o][n]},cancelTransaction:(t,{payload:{chainId:o,id:n,address:i,cancelRequest:a}})=>{const e=h({state:t,address:i,chainId:o,id:n,actionName:"cancelTransaction"});e.status=p.Cancelling,e.cancelRequest=a},replaceTransaction:(t,{payload:{chainId:o,id:n,address:i}})=>{var a;c((a=t[i])===null||a===void 0||(a=a[o])===null||a===void 0?void 0:a[n],`replaceTransaction: Attempted to replace a tx that doesn't exist with id ${n}`),t[i][o][n].status=p.Replacing},resetTransactions:()=>R,upsertFiatOnRampTransaction:(t,{payload:o})=>{var n;const{chainId:i,id:a,from:e,typeInfo:{type:r}}=o;c(r===f.LocalOnRamp||r===f.LocalOffRamp||r===f.OnRampPurchase||r===f.OnRampTransfer||r===f.OffRampSale,"only FOR transactions can be upserted"),t[e]??(t[e]={}),(n=t[e])[i]??(n[i]={}),t[e][i][a]={...o,typeInfo:{...o.typeInfo}}},interfaceCancelTransactionWithHash:(t,{payload:{chainId:o,id:n,address:i,cancelHash:a}})=>{const e=m({state:t,address:i,chainId:o,id:n,actionName:"interfaceCancelTransactionWithHash"});delete t[i][o][n],t[i][o][a]={...e,id:a,hash:a,cancelled:!0}},interfaceClearAllTransactions:(t,{payload:{chainId:o,address:n}})=>{var i;!((i=t[n])===null||i===void 0)&&i[o]&&(t[n][o]={})},interfaceCheckedTransaction:(t,{payload:{chainId:o,id:n,address:i,blockNumber:a}})=>{const e=m({state:t,address:i,chainId:o,id:n,actionName:"interfaceCheckedTransaction"});c(e.status===p.Pending,`interfaceCheckedTransaction: Attempted to check a non-pending transaction with id ${n}`),e.lastCheckedBlockNumber?e.lastCheckedBlockNumber=Math.max(a,e.lastCheckedBlockNumber):e.lastCheckedBlockNumber=a},interfaceConfirmBridgeDeposit:(t,{payload:{chainId:o,id:n,address:i}})=>{const a=m({state:t,address:i,chainId:o,id:n,actionName:"interfaceConfirmBridgeDeposit"});c(N(a.typeInfo),`interfaceConfirmBridgeDeposit: Attempted to confirm a non-bridge transaction with id ${n}`),a.typeInfo.depositConfirmed=!0},interfaceUpdateTransactionInfo:(t,{payload:{chainId:o,id:n,address:i,typeInfo:a}})=>{const e=m({state:t,address:i,chainId:o,id:n,actionName:"interfaceUpdateTransactionInfo"});c(e.typeInfo.type===a.type,`interfaceUpdateTransactionInfo: Attempted to update a non-matching transaction with id ${n}`),e.typeInfo=a},interfaceApplyTransactionHashToBatch:(t,{payload:{batchId:o,hash:n,chainId:i,address:a}})=>{var e;const r=(e=t[a])===null||e===void 0||(e=e[i])===null||e===void 0?void 0:e[o];if(!r)return;const s={...r,id:n,hash:n};delete t[a][i][o],t[a][i][n]=s}}}),S=v("transactions/forceFetchFiatOnRampTransactions"),{addTransaction:k,cancelTransaction:B,deleteTransaction:x,finalizeTransaction:X,replaceTransaction:V,resetTransactions:H,upsertFiatOnRampTransaction:z,updateTransaction:L,updateTransactionWithoutWatch:Y,interfaceClearAllTransactions:M,interfaceCheckedTransaction:b,interfaceConfirmBridgeDeposit:q,interfaceFinalizeTransaction:j,interfaceUpdateTransactionInfo:J,interfaceApplyTransactionHashToBatch:K,interfaceCancelTransactionWithHash:Q}=I.actions,{reducer:Z}=I,tt={...I.actions,forceFetchFiatOnRampTransactions:S};export{P as OFFCHAIN_ORDER_TYPE_TO_SIGNATURE_TYPE,d as SignatureType,k as addTransaction,x as deleteTransaction,E as getRoutingForTransaction,W as getRoutingForUniswapXOrder,K as interfaceApplyTransactionHashToBatch,Q as interfaceCancelTransactionWithHash,b as interfaceCheckedTransaction,q as interfaceConfirmBridgeDeposit,j as interfaceFinalizeTransaction,J as interfaceUpdateTransactionInfo,G as isConfirmedTx,F as isPendingTx,Z as transactionReducer,L as updateTransaction};
