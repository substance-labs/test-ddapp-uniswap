import{__toESM as w}from"./chunk-DgAfPHQg.js";import{require_react as d}from"./react-CNoFhWkx.js";import{useDispatch as l}from"./es-Iwj7vF3u.js";import{SwitchChainNotSupportedError as S,useMutation as v}from"./connector-Cw8HJLtm.js";import{useIsSupportedChainIdCallback as _}from"./useSupportedChainId-DskHoisQ.js";import{deepEqual as $,useAccount as E,useConfig as m}from"./useAccount-C5hwiBwN.js";import{ChainNotConfiguredError as g}from"./config-CDfnfyHL.js";import{endSwitchingChain as b,startSwitchingChain as y}from"./reducer-CcXO4HTO.js";let s=[];function C(t){const n=t.chains;return $(s,n)?s:(s=n,n)}async function k(t,n){var i;const{addEthereumChainParameter:r,chainId:o}=n,c=t.state.connections.get(((i=n.connector)===null||i===void 0?void 0:i.uid)??t.state.current);if(c){const a=c.connector;if(!a.switchChain)throw new S({connector:a});return await a.switchChain({addEthereumChainParameter:r,chainId:o})}const e=t.chains.find(a=>a.id===o);if(!e)throw new g;return t.setState(a=>({...a,chainId:o})),e}function A(t,n){const{onChange:i}=n;return t._internal.chains.subscribe((r,o)=>{i(r,o)})}function M(t){return{mutationFn(n){return k(t,n)},mutationKey:["switchChain"]}}var p=w(d());function q(t={}){const n=m(t);return(0,p.useSyncExternalStore)(i=>A(n,{onChange:i}),()=>C(n),()=>C(n))}function x(t={}){const{mutation:n}=t,i=m(t),r=M(i),{mutate:o,mutateAsync:c,...e}=v({...n,...r});return{...e,chains:q({config:i}),switchChain:o,switchChainAsync:c}}function B(){var t;const n=l(),i=_(),{switchChain:r}=x(),o=E();return(0,p.useCallback)(c=>{var e;if(!i(c))throw new Error(`Chain ${c} not supported for connector (${(e=o.connector)===null||e===void 0?void 0:e.name})`);if(o.chainId!==c)return new Promise((u,f)=>{n(y(c)),r({chainId:c},{onSettled(N,h){n(b()),h?f(h):u()}})})},[i,o.chainId,(t=o.connector)===null||t===void 0?void 0:t.name,n,r])}export{B as useSwitchChain};
