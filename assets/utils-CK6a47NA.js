import{__toESM as lt}from"./chunk-DgAfPHQg.js";import{isInterface as dt}from"./index.web-BqgtOHN3.js";import{datadogRum as D,logger as q}from"./hooks-BXO4d1DJ.js";import{createAction as X}from"./redux-toolkit.esm-BnRUBto_.js";import{TradeType as O,init_sdk_core_esm as ft,isL2ChainId as pt,isUniverseChainId as mt}from"./utils-BX1Fu73x.js";import{currencyId as C}from"./currencyId-Ci6selsx.js";import{getTransaction as gt}from"./public-fap09Zv6.js";import{isSameAddress as vt}from"./addresses-D56PBUHX.js";import{require_ms as yt}from"./ms-BqmEYo6j.js";import{BlockedAsyncSubmissionChainIdsConfigKey as ht,DynamicConfigs as At}from"./configs-B4dDdw82.js";import{getDynamicConfigValue as Tt}from"./hooks-Bp0VtWbX.js";import{Routing as Et,getInterfaceTransaction as wt,isInterfaceTransaction as St,isUniswapX as It}from"./selectors-BwkayGDl.js";import{uniswapUrls as m}from"./urls-kwiZbYPW.js";import{FetchError as G}from"./createApiClient-BjXZMbEB.js";import{TransactionOriginType as Ct,TransactionStatus as R,TransactionType as L}from"./transactionDetails-BsNW_jus.js";import{TransactionStepType as g}from"./types-7DAoWLTI.js";import{clientToProvider as Rt,getConnectorClient as Lt}from"./useEthersProvider-CBgc_azi.js";import{wagmiConfig as K}from"./wagmiConfig-0BYSDqyO.js";import{getAction as xt}from"./getAction-BBhbL9mE.js";import{isValidHexString as b}from"./hex-njd-4N-2.js";import{addTransaction as Ot,getRoutingForTransaction as Nt,interfaceFinalizeTransaction as $t,interfaceUpdateTransactionInfo as bt,isPendingTx as Ut}from"./slice-qANrfSbi.js";import{noop as kt}from"./noop-BDbB2pLB.js";import{signTypedData as Ft}from"./signing-DH5GfhKu.js";import{didUserReject as Pt}from"./swapErrorToUserReadableMessage-DgHZMHU-.js";var he="persist:",Ae="persist/FLUSH",_t="persist/REHYDRATE",Te="persist/PAUSE",Ee="persist/PERSIST",we="persist/PURGE",Se="persist/REGISTER",Ie=-1,f=function(n){return"@@redux-saga/"+n},qt=f("CANCEL_PROMISE"),Ce=f("CHANNEL_END"),Ht=f("IO"),Re=f("MATCH"),Mt=f("MULTICAST"),Bt=f("SAGA_ACTION"),jt=f("SELF_CANCELLATION"),Le=f("TASK"),Dt=f("TASK_CANCEL"),Xt=f("TERMINATE"),Gt=f("LOCATION");function x(){return x=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)({}).hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t},x.apply(null,arguments)}var Kt=function(n){return n==null},N=function(n){return n!=null},v=function(n){return typeof n=="function"},J=function(n){return typeof n=="string"},U=Array.isArray,xe=function(n){return n&&v(n.then)},Oe=function(n){return n&&v(n.next)&&v(n.throw)},H=function t(n){return n&&(J(n)||Jt(n)||v(n)||U(n)&&n.every(t))},V=function(n){return n&&v(n.take)&&v(n.close)},Ne=function(n){return v(n)&&n.hasOwnProperty("toString")},Jt=function(n){return!!n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype},Vt=function(n){return V(n)&&n[Mt]},Wt=2147483647;function Yt(t,n){n===void 0&&(n=!0);var e,r=new Promise(function(i){e=setTimeout(i,Math.min(Wt,t),n)});return r[qt]=function(){clearTimeout(e)},r}var zt=Yt,Qt=function(n){return function(){return n}},$e=Qt(!0),Zt=function(){},tn=function(n){return n},be=function(n,e){x(n,e),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(e).forEach(function(r){n[r]=e[r]})},Ue=function(n,e){var r;return(r=[]).concat.apply(r,e.map(n))};function ke(t,n){var e=t.indexOf(n);e>=0&&t.splice(e,1)}function Fe(t){var n=!1;return function(){n||(n=!0,t())}}var nn=function(n){throw n},en=function(n){return{value:n,done:!0}};function Pe(t,n,e){n===void 0&&(n=nn),e===void 0&&(e="iterator");var r={meta:{name:e},next:t,throw:n,return:en,isSagaIterator:!0};return typeof Symbol<"u"&&(r[Symbol.iterator]=function(){return r}),r}function _e(t,n){var e=n.sagaStack;console.error(t),console.error(e)}var qe=function(n){return new Error(`
  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug
  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.
  Error: `+n+`
`)},rn=function(n){return Array.apply(null,new Array(n))},He=function(n){return function(e){return n(Object.defineProperty(e,Bt,{value:!0}))}},an=function(n){return n===Xt},on=function(n){return n===Dt},sn=function(n){return an(n)||on(n)};function Me(t,n){var e=Object.keys(t),r=e.length,i=0,a,s=U(t)?rn(r):{},u={};function T(){i===r&&(a=!0,n(s))}return e.forEach(function(l){var c=function(w,h){a||(h||sn(w)?(n.cancel(),n(w,h)):(s[l]=w,i++,T()))};c.cancel=Zt,u[l]=c}),n.cancel=function(){a||(a=!0,e.forEach(function(l){return u[l].cancel()}))},u}function Be(t){return{name:t.name||"anonymous",location:un(t)}}function un(t){return t[Gt]}var cn="Channel's Buffer overflow!",ln=1,dn=3,W=4;function fn(t,n){t===void 0&&(t=10);var e=new Array(t),r=0,i=0,a=0,s=function(c){e[i]=c,i=(i+1)%t,r++},u=function(){if(r!=0){var c=e[a];return e[a]=null,r--,a=(a+1)%t,c}},T=function(){for(var c=[];r;)c.push(u());return c};return{isEmpty:function(){return r==0},put:function(c){if(r<t)s(c);else{var d;switch(n){case ln:throw new Error(cn);case dn:e[i]=c,i=(i+1)%t,a=i;break;case W:d=2*t,e=T(),r=e.length,i=e.length,a=0,e.length=d,t=d,s(c);break;default:}}},take:u,flush:T}}var je=function(n){return fn(n,W)},$="TAKE",pn="PUT",De="ALL",mn="RACE",gn="CALL",Xe="CPS",Y="FORK",Ge="JOIN",vn="CANCEL",yn="SELECT",Ke="ACTION_CHANNEL",Je="CANCELLED",Ve="FLUSH",We="GET_CONTEXT",Ye="SET_CONTEXT",p=function(n,e){var r;return r={},r[Ht]=!0,r.combinator=!1,r.type=n,r.payload=e,r},hn=function(n){return p(Y,x({},n.payload,{detached:!0}))};function An(t,n){if(t===void 0&&(t="*"),H(t))return N(n)&&console.warn("take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types"),p($,{pattern:t});if(Vt(t)&&N(n)&&H(n))return p($,{channel:t,pattern:n});if(V(t))return N(n)&&console.warn("take(channel) takes one argument but two were provided. Second argument is ignored."),p($,{channel:t})}function Tn(t,n){return Kt(n)&&(n=t,t=void 0),p(pn,{channel:t,action:n})}function En(t){var n=p(mn,t);return n.combinator=!0,n}function z(t,n){var e=null,r;return v(t)?r=t:(U(t)?(e=t[0],r=t[1]):(e=t.context,r=t.fn),e&&J(r)&&v(e[r])&&(r=e[r])),{context:e,fn:r,args:n}}function Q(t){for(var n=arguments.length,e=new Array(n>1?n-1:0),r=1;r<n;r++)e[r-1]=arguments[r];if(0)var i;return p(gn,z(t,e))}function Z(t){for(var n=arguments.length,e=new Array(n>1?n-1:0),r=1;r<n;r++)e[r-1]=arguments[r];return p(Y,z(t,e))}function wn(t){for(var n=arguments.length,e=new Array(n>1?n-1:0),r=1;r<n;r++)e[r-1]=arguments[r];return hn(Z.apply(void 0,[t].concat(e)))}function Sn(t){return t===void 0&&(t=jt),p(vn,t)}function In(t){t===void 0&&(t=tn);for(var n=arguments.length,e=new Array(n>1?n-1:0),r=1;r<n;r++)e[r-1]=arguments[r];return p(yn,{selector:t,args:e})}var Cn=Q.bind(null,zt);function Rn(t,n){const{chainId:e,...r}=n,i=t.getClient({chainId:e});return xt(i,gt,"getTransaction")(r)}function*S(...t){return yield An(...t)}function*tt(...t){return yield Tn(...t)}function*o(...t){return yield Q(...t)}function*Ln(...t){return yield Z(...t)}function*xn(...t){return yield wn(...t)}function*On(...t){return yield Sn(...t)}function*nt(...t){return yield In(...t)}function*Nn(...t){return yield Cn(...t)}function*$n(...t){return yield En(...t)}var I=class extends Error{},bn=class extends I{constructor(t){super(t),this.name="UnexpectedTransactionStateError"}},E=class extends I{constructor({message:t,step:n,isBackendRejection:e=!1,originalError:r}){super(t),this.name="TransactionStepFailedError",this.step=n,this.isBackendRejection=e,this.originalError=r;try{this.originalErrorString=r==null?void 0:r.toString(),this.originalErrorStringified=JSON.stringify(r,null,2),this.stepStringified=JSON.stringify(n,null,2)}catch{}}getFingerprint(){const t=[this.step.type];try{var n,e;this.originalError&&"code"in this.originalError&&(typeof this.originalError.code=="string"||typeof this.originalError.code=="number")&&t.push(String(this.originalError.code)),!((n=this.originalError)===null||n===void 0)&&n.message&&t.push(String(this.originalError.message)),this.isBackendRejection&&this.originalError instanceof G&&(!((e=this.originalError.data)===null||e===void 0)&&e.detail)&&t.push(String(this.originalError.data.detail))}catch(r){dt&&D.addAction("Transaction Action",{message:`problem determining fingerprint for ${this.step.type}`,level:"info",step:this.step.type,data:{errorMessage:r instanceof Error?r.message:void 0}})}return t}},Un=class extends I{constructor(t,n){super(t),this.name="JupiterExecuteError",this.code=n}},et=class extends E{constructor({step:t}){super({message:"Approval decreased to insufficient amount in wallet",step:t}),this.logError=!1}},k=class extends I{constructor(t){super(t),this.name="HandledTransactionInterrupt"}};function ze(t,n){return n instanceof E?kn(t,n):n instanceof Un?{title:t("common.unknownError.error"),message:n.message}:{title:t("common.unknownError.error"),message:t("common.swap.failed")}}function kn(t,n){switch(n.step.type){case g.WrapTransaction:return{title:t("common.wrap.failed"),message:t("token.wrap.fail.message"),supportArticleURL:m.helpArticleUrls.wethExplainer};case g.SwapTransaction:case g.SwapTransactionAsync:return{title:t("common.swap.failed"),message:t("swap.fail.message"),supportArticleURL:m.helpArticleUrls.transactionFailure};case g.SwapTransactionBatched:return{title:t("swap.fail.batched.title"),buttonText:t("swap.fail.batched.retry"),message:t("swap.fail.batched"),supportArticleURL:m.helpArticleUrls.transactionFailure};case g.UniswapXSignature:return n.isBackendRejection?{title:t("common.swap.failed"),message:t("swap.fail.uniswapX"),supportArticleURL:m.helpArticleUrls.uniswapXFailure}:{title:t("common.swap.failed"),message:t("swap.fail.message"),supportArticleURL:m.helpArticleUrls.uniswapXFailure};case g.Permit2Signature:return{title:t("permit.approval.fail"),message:t("permit.approval.fail.message"),supportArticleURL:m.helpArticleUrls.approvalsExplainer};case g.TokenApprovalTransaction:return n instanceof et?{title:t("error.tokenApprovalEdited"),message:t("error.tokenApprovalEdited.message"),supportArticleURL:m.helpArticleUrls.approvalsExplainer}:{title:t("error.tokenApproval"),message:t("error.tokenApproval.message"),supportArticleURL:m.helpArticleUrls.approvalsExplainer};case g.TokenRevocationTransaction:return{title:t("common.revoke.approval.failed"),message:t("revoke.failed.message"),supportArticleURL:m.helpArticleUrls.revokeExplainer};default:return{title:t("common.unknownError.error"),message:t("common.swap.failed")}}}function Fn(t){const n=BigInt(`0x${t.slice(-64)}`),e=`0x${t.slice(-104,-64)}`;return{amount:n,spender:e}}function Qe(t,n){const e=X(`${n}/trigger`);return{wrappedSaga:function*(){for(;;)try{const i=yield*S(e.type);q.debug("saga","wrappedSaga",`${n} triggered`),yield*o(t,i.payload)}catch(i){q.error(i,{tags:{file:"utils/saga",function:"createSaga"},extra:{sagaName:n}})}},actions:{trigger:e}}}const rt=X("interruptTransactionFlow");function*Ze(){if(!(yield*o(M)))for(;yield*S(_t),!(yield*o(M)););}function*M(){return yield*nt(t=>{var n;return(n=t._persist)===null||n===void 0?void 0:n.rehydrated})}ft();var Pn=lt(yt());function*tr({setCurrentStep:t,step:n,ignoreInterrupt:e,account:r}){const{throwIfInterrupted:i}=yield*st(e);A({step:n,data:{domain:JSON.stringify(n.domain),values:JSON.stringify(n.values),types:JSON.stringify(n.types)}}),t({step:n,accepted:!1});const a=yield*o(F,r.address),s=yield*o(Ft,{signer:a,domain:n.domain,types:n.types,value:n.values});return yield*o(i),A({step:n,data:{signature:s},status:"complete"}),s}function*it(t){const{account:n,step:e,setCurrentStep:r,info:i,allowDuplicativeTx:a,ignoreInterrupt:s,onModification:u,shouldWaitForConfirmation:T}=t,{chainId:l}=e.txRequest;A({step:e,data:{...i}});const c=yield*Gn({info:i,account:n,chainId:l,allowDuplicativeTx:a}),d=c?wt(c):void 0;if(d)return d.status===R.Success?(A({step:e,data:{duplicativeTx:!0,hash:d.hash},status:"complete"}),d.hash):(A({step:e,data:{duplicativeTx:!0,hash:d.hash},status:"in progress"}),r({step:e,accepted:!0}),yield*B(t,d.hash));const{throwIfInterrupted:w}=yield*st(s);r({step:e,accepted:!1});let h;const P=y=>({id:y,from:n.address,typeInfo:i,hash:y,chainId:l,routing:Nt(i),transactionOriginType:Ct.Internal,status:R.Pending,addedTime:Date.now(),options:{request:{to:e.txRequest.to,from:n.address,data:e.txRequest.data,value:e.txRequest.value,gasLimit:e.txRequest.gasLimit,gasPrice:e.txRequest.gasPrice,nonce:e.txRequest.nonce,chainId:e.txRequest.chainId}}}),ut=[];if(Tt({config:At.BlockedAsyncSubmissionChainIds,key:ht.ChainIds,defaultValue:ut}).includes(l)||T){const{hash:y,data:_,nonce:ct}=yield*o(qn,t);h=P(y),e.txRequest.data!==_&&u&&(yield*o(u,{hash:y,data:_,nonce:ct}))}else{const y=yield*o(Hn,t);h=P(y),u&&(yield*xn(_n,{onModification:u,hash:y,step:e}))}return r({step:e,accepted:!0}),yield*tt(Ot(h)),yield*o(w),yield*B(t,h.hash)}function*B(t,n){const{step:e,shouldWaitForConfirmation:r=!0,ignoreInterrupt:i}=t;if(!r)return n;if(i)return yield*o(j,n,e),n;const{interrupt:a}=yield*$n({transactionFinished:o(j,n,e),interrupt:S(rt.type)});if(a)throw new k("Transaction flow was interrupted");return A({step:e,data:{txHash:n},status:"complete"}),n}function*_n({onModification:t,hash:n,step:e}){const{data:r,nonce:i}=yield*o(at,n,e);e.txRequest.data!==r&&(yield*o(t,{hash:n,data:r,nonce:i}))}function*qn(t){const{account:n,step:e}=t,r=yield*o(F,n.address);try{const i=yield*o([r,"sendTransaction"],e.txRequest);return ot(i)}catch(i){if(i&&typeof i=="object"&&"transactionHash"in i&&b(i.transactionHash))return yield*at(i.transactionHash,e);throw i}}function*Hn(t){const{account:n,step:e}=t,r=yield*o(F,n.address);try{const i=yield*o([r.provider,"send"],"eth_sendTransaction",[{from:n.address,...e.txRequest}]);if(!b(i))throw new E({message:`Transaction failed, not a valid hex string: ${i}`,step:e});return i}catch(i){if(i&&typeof i=="object"&&"transactionHash"in i&&b(i.transactionHash))return i.transactionHash;throw i}}function*at(t,n){const e=yield*Mn(t,n.txRequest.chainId);if(!e)throw new E({message:"Transaction not found",step:n});return ot(e)}function*Mn(t,n){const r=pt(n)?12e3:24e3;let i=0;for(;i<r;)try{return yield*o(Rn,K,{chainId:n,hash:t})}catch{yield*Nn(2e3),i+=2e3}return null}function ot(t){return"data"in t?{hash:t.hash,data:t.data,nonce:t.nonce}:{hash:t.hash,data:t.input,nonce:t.nonce}}function*nr(t){const{step:n}=t,e=jn(n);return yield*o(it,{...t,info:e})}function*er(t){const{step:n,account:e}=t,r=Bn(n);return yield*o(it,{...t,info:r,*onModification({hash:i,data:a}){const{isInsufficient:s,approvedAmount:u}=Dn(a,n);if(yield*tt(bt({chainId:n.txRequest.chainId,id:i,address:e.address,typeInfo:{...r,approvalAmount:u}})),s)throw new et({step:n})}})}function Bn(t){return{type:L.Approve,tokenAddress:t.token.address,spender:t.spender,approvalAmount:t.amount}}function jn(t){return{type:L.Permit2Approve,tokenAddress:t.token.address,spender:t.spender,amount:t.amount}}function Dn(t,n){const e=BigInt(`0x${parseInt(n.amount,10).toString(16)}`),r=Fn(t),i=r.amount.toString(10);return n.type===g.TokenRevocationTransaction?{isInsufficient:r.amount!==BigInt(0),approvedAmount:i}:{isInsufficient:r.amount<e,approvedAmount:i}}function Xn(t){const n=Date.now();return!(t.status===R.Failed)&&n-t.addedTime<(0,Pn.default)("30s")}function*Gn({info:t,account:n,chainId:e,allowDuplicativeTx:r}){if(r)return;if(!mt(e))throw new Error(`Invalid chainId: ${e} is not a valid UniverseChainId`);const i=yield*nt(s=>{var u;return((u=s.transactions[n.address])===null||u===void 0?void 0:u[e])??{}});return Object.values(i).filter(s=>vt(s.from,n.address)).filter(St).find(s=>(Ut(s)||Xn(s))&&JSON.stringify(s.typeInfo)===JSON.stringify(t))}function*st(t=!1){if(t)return{throwIfInterrupted:kt};let n=!1;const e=yield*Ln(function*(){yield*S(rt.type),n=!0});function*r(){if(n)throw new k("Transaction flow was interrupted");yield*On(e)}return{throwIfInterrupted:r}}function*j(t,n){for(;;){const{payload:e}=yield*S($t.type);if(e.hash===t){if(e.status===R.Success)return;throw new E({message:`${n.type} failed on-chain`,step:n})}}}async function Kn(){const t=await Lt(K),n=Rt(t);if(!n)throw new bn("Failed to get provider during transaction flow");return n}async function F(t){return(await Kn()).getSigner(t)}function rr(t){return t.routing===Et.BRIDGE?{type:L.Bridge,inputCurrencyId:C(t.inputAmount.currency),outputCurrencyId:C(t.outputAmount.currency),inputCurrencyAmountRaw:t.inputAmount.quotient.toString(),outputCurrencyAmountRaw:t.outputAmount.quotient.toString(),quoteId:t.quote.requestId,depositConfirmed:!1}:{type:L.Swap,inputCurrencyId:C(t.inputAmount.currency),outputCurrencyId:C(t.outputAmount.currency),isUniswapXOrder:It(t),...t.tradeType===O.EXACT_INPUT?{tradeType:O.EXACT_INPUT,inputCurrencyAmountRaw:t.inputAmount.quotient.toString(),expectedOutputCurrencyAmountRaw:t.outputAmount.quotient.toString(),minimumOutputCurrencyAmountRaw:t.minAmountOut.quotient.toString()}:{tradeType:O.EXACT_OUTPUT,maximumInputCurrencyAmountRaw:t.maxAmountIn.quotient.toString(),outputCurrencyAmountRaw:t.outputAmount.quotient.toString(),expectedInputCurrencyAmountRaw:t.inputAmount.quotient.toString()}}}function A({step:t,data:n={},status:e="initiated"}){D.addAction("Transaction Action",{message:`${t.type} ${e}`,step:t.type,level:"info",data:n})}function ir({error:t,step:n,flow:e="swap"}){const r=Pt(t);if(r||t instanceof k){const i=r?"user rejected request":t.message;n&&A({step:n,status:"interrupted",data:{message:i}});return}else{if(t instanceof I)return t;if(n){const i=t instanceof G;return new E({message:`${n.type} failed during ${e}`,step:n,isBackendRejection:i,originalError:t})}else return t}}export{Ke as ACTION_CHANNEL,De as ALL,gn as CALL,vn as CANCEL,qt as CANCEL$1,Je as CANCELLED,Ce as CHANNEL_END_TYPE,Xe as CPS,Ie as DEFAULT_VERSION,Ve as FLUSH,Ae as FLUSH$1,Y as FORK,We as GET_CONTEXT,k as HandledTransactionInterrupt,Ht as IO,Ge as JOIN,Un as JupiterExecuteError,he as KEY_PREFIX,Re as MATCH,Mt as MULTICAST,Te as PAUSE,Ee as PERSIST,we as PURGE,pn as PUT,mn as RACE,Se as REGISTER,_t as REHYDRATE,Bt as SAGA_ACTION,yn as SELECT,jt as SELF_CANCELLATION,Ye as SET_CONTEXT,$ as TAKE,Le as TASK,Dt as TASK_CANCEL,Xt as TERMINATE,E as TransactionStepFailedError,bn as UnexpectedTransactionStateError,x as _extends,A as addTransactionBreadcrumb,U as array,be as assignWithSymbols,o as call,Me as createAllStyleChildCallbacks,rn as createEmptyArray,Qe as createSaga,Nn as delay,je as expanding,Ue as flatMap,v as func,ir as getDisplayableError,ze as getErrorContent,un as getLocation,Be as getMetaInfo,F as getSigner,rr as getSwapTransactionInfo,er as handleApprovalTransactionStep,it as handleOnChainStep,nr as handlePermitTransactionStep,tr as handleSignatureStep,tn as identity,qe as internalErr,rt as interruptTransactionFlow,Oe as iterator,$e as kTrue,_e as logError,Pe as makeIterator,Zt as noop,N as notUndef,Fe as once,Fn as parseERC20ApproveCalldata,xe as promise,tt as put,ke as remove,nt as select,on as shouldCancel,sn as shouldComplete,an as shouldTerminate,xn as spawn,J as string,Ne as stringableFunc,Jt as symbol,Kt as undef,Ze as waitForRehydration,st as watchForInterruption,He as wrapSagaDispatch};
