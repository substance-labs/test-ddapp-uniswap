import{__toESM as w}from"./chunk-DgAfPHQg.js";import{require_react as _}from"./react-CNoFhWkx.js";import{getLogger as y}from"./hooks-BXO4d1DJ.js";import{analytics as v}from"./analytics.web-DLc1_wTk.js";import{createListenerMiddleware as A,createSlice as E}from"./redux-toolkit.esm-BnRUBto_.js";import{InterfaceEventName as O}from"./interface-BdpC4qOF.js";import{numberToHex as W}from"./isAddress-P2vaZgmG.js";import{parseAccount as D}from"./parseAccount-CRyN5swV.js";import{sendAnalyticsEvent as T}from"./send.web-CrSXW2rw.js";import{getConnectorClient as j}from"./useEthersProvider-CBgc_azi.js";import{wagmiConfig as B}from"./wagmiConfig-0BYSDqyO.js";import{deepEqual as k}from"./useAccount-C5hwiBwN.js";import{ensure0xHex as C,hexToNumber as x,isValidHexString as M,numberToHex as m}from"./hex-njd-4N-2.js";import{useWallet as I}from"./useWallet-CpLwPvrh.js";let s=(function(t){return t.Unknown="Unknown",t.Supported="Supported",t.Unsupported="Unsupported",t})({});async function H(t,e={}){const{account:i=t.account,chainId:a}=e,n=i?D(i):void 0,o=a?[n==null?void 0:n.address,[W(a)]]:[n==null?void 0:n.address],f=await t.request({method:"wallet_getCapabilities",params:o}),r={};for(const[l,g]of Object.entries(f)){r[Number(l)]={};for(let[c,S]of Object.entries(g))c==="addSubAccount"&&(c="unstable_addSubAccount"),r[Number(l)][c]=S}return typeof a=="number"?r[a]:r}async function R(t,e={}){const{account:i,chainId:a,connector:n}=e,o=await j(t,{account:i,connector:n});return H(o,{account:i,chainId:a})}function V(t){if(!L(t))return null;const e={};for(const[i,a]of Object.entries(t)){if(!q(a))return null;const n=G(i);if(!n)return null;e[n]=a}return e}function L(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}function q(t){return!(!t||typeof t!="object"||Array.isArray(t))}function G(t){if(M(t))return t;const e=Number(t);return isNaN(e)?null:C(m(e))}const z=5e3;async function wt(){let t;const e=new Promise((i,a)=>{t=setTimeout(()=>a(new Error("getCapabilities timeout")),z)});try{const i=await Promise.race([N(),e]),a=V(i);if(a)return a;throw new Error(`Invalid capabilities format: ${JSON.stringify(i)}`)}catch(i){return i instanceof Error&&i.message.includes("getCapabilities timeout")||y().warn("useWalletCapabilities","handleGetCapabilities",`Error getting capabilities: ${i}`),null}finally{t&&clearTimeout(t)}}async function N(){return R(B)}var u=(function(t){return t.Supported="supported",t.Ready="ready",t.Unsupported="unsupported",t})(u||{});function b(t){var e,i;return((e=t.atomic)===null||e===void 0?void 0:e.status)===u.Supported||((i=t.atomic)===null||i===void 0?void 0:i.status)===u.Ready}function J(t,e){const i=C(m(e)),a=t[i];return a?b(a):!1}function F(t){return t?Object.entries(t).filter(([e,i])=>b(i)).map(([e])=>parseInt(e,16)):[]}function K(t){const{getOriginalState:e,onAtomicSupportedChainIdsDetected:i,onWalletCapabilitiesDetected:a,logger:n}=t;return o=>{const r=e().walletCapabilities.byChain;if(k(r,o.payload)){n==null||n.info("reducer.ts","createOnSetCapabilitiesByChainEffect","wallet capabilities are the same");return}const l=F(o.payload);l.length>0&&(n==null||n.info("reducer.ts","createOnSetCapabilitiesByChainEffect","atomic supported chain ids detected",{atomicSupportedChainIds:l}),i(l)),a(o.payload),n==null||n.info("reducer.ts","createOnSetCapabilitiesByChainEffect","wallet capabilities detected",{payload:o.payload})}}let Q=(function(t){return t.AllWalletAddressesConnected="all_wallet_addresses_connected",t.AllWalletChainIds="all_wallet_chain_ids",t.Browser="browser",t.ChainId="chain_id",t.DarkMode="is_dark_mode",t.ExpertMode="is_expert_mode",t.GitCommitHash="git_commit_hash",t.PeerWalletAgent="peer_wallet_agent",t.RouterPreference="router_preference",t.ScreenResolutionHeight="screen_resolution_height",t.ScreenResolutionWidth="screen_resolution_width",t.SupportsAtomicBatching="supports_atomic_batching",t.TestnetModeEnabled="testnet_mode_enabled",t.UserAgent="user_agent",t.WalletAddress="wallet_address",t.WalletName="wallet_name",t.WalletType="wallet_type",t.WalletVersion="wallet_version",t})({}),_t=(function(t){return t.IsDelegatedEOA="is_delegated_eoa",t})({});function X(t,e,i){v.setUserProperty(t,e,i)}const Y={getCapabilitiesStatus:s.Unknown,byChain:{}},h=E({name:"walletCapabilities",initialState:Y,reducers:{setCapabilitiesNotSupported(t){t.getCapabilitiesStatus=s.Unsupported},setCapabilitiesByChain(t,{payload:e}){t.byChain=e,t.getCapabilitiesStatus=s.Supported},handleResetWalletCapabilitiesState(t){t.getCapabilitiesStatus=s.Unknown,t.byChain={}}}}),{setCapabilitiesByChain:Z,handleResetWalletCapabilitiesState:yt,setCapabilitiesNotSupported:vt}=h.actions;var At=h.reducer;const U=t=>t.walletCapabilities.getCapabilitiesStatus===s.Unknown,P=t=>t.walletCapabilities.getCapabilitiesStatus===s.Supported,Et=t=>Object.values(t.walletCapabilities.byChain).some(b),Ot=t=>e=>U(t)?void 0:P(t)&&J(t.walletCapabilities.byChain,e),$=A();$.startListening({actionCreator:Z,effect:(t,{getOriginalState:e})=>{K({getOriginalState:e,onAtomicSupportedChainIdsDetected:tt,onWalletCapabilitiesDetected:et})(t)}});function tt(t){X(Q.SupportsAtomicBatching,t)}function et(t){for(const[e,i]of Object.entries(t))T(O.WalletCapabilitiesDetected,{chainId:x(e),capabilities:i})}var it=w(_());let p=null;const nt=t=>{p=t},Wt=async t=>{if(!p)throw new Error("No wallet registered to sign Solana transactions");return p(t)};function Dt(){const{signTransaction:t}=I();return(0,it.useEffect)(()=>{t&&nt(t)},[t]),null}function d(t){"@babel/helpers - typeof";return d=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},d(t)}function Tt(t){if(t===null||t===!0||t===!1)return NaN;var e=Number(t);return isNaN(e)?e:e<0?Math.ceil(e):Math.floor(e)}function at(t,e){if(e.length<t)throw new TypeError(t+" argument"+(t>1?"s":"")+" required, but only "+e.length+" present")}function jt(t){at(1,arguments);var e=Object.prototype.toString.call(t);return t instanceof Date||d(t)==="object"&&e==="[object Date]"?new Date(t.getTime()):typeof t=="number"||e==="[object Number]"?new Date(t):((typeof t=="string"||e==="[object String]")&&typeof console<"u"&&(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn(new Error().stack)),new Date(NaN))}var ot={};function Bt(){return ot}export{s as GetCapabilitiesStatus,Q as InterfaceUserPropertyName,Dt as SolanaSignerUpdater,_t as UniswapUserPropertyName,d as _typeof,Bt as getDefaultOptions,wt as handleGetCapabilities,yt as handleResetWalletCapabilitiesState,J as isAtomicBatchingSupportedByChainId,At as reducer_default,at as requiredArgs,Et as selectIsAtomicBatchingSupported,Ot as selectIsAtomicBatchingSupportedByChainId,U as selectNeedsToCheckCapabilities,Z as setCapabilitiesByChain,vt as setCapabilitiesNotSupported,X as setUserProperty,Wt as signSolanaTransactionWithCurrentWallet,jt as toDate,Tt as toInteger,$ as walletCapabilitiesListenerMiddleware};
