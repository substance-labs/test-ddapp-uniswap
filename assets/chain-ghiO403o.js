import{BaseError as e,bytesToHex as d,numberToHex as o}from"./isAddress-P2vaZgmG.js";import{etherUnits as h}from"./node-C_BraYgX.js";import{formatUnits as p}from"./formatUnits-DkyMpOD7.js";function u(n,t){return({exclude:i,format:a})=>({exclude:i,format:s=>{const r=t(s);if(i)for(const m of i)delete r[m];return{...r,...a(s)}},type:n})}const f={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function x(n){const t={};return typeof n.authorizationList<"u"&&(t.authorizationList=I(n.authorizationList)),typeof n.accessList<"u"&&(t.accessList=n.accessList),typeof n.blobVersionedHashes<"u"&&(t.blobVersionedHashes=n.blobVersionedHashes),typeof n.blobs<"u"&&(typeof n.blobs[0]!="string"?t.blobs=n.blobs.map(i=>d(i)):t.blobs=n.blobs),typeof n.data<"u"&&(t.data=n.data),typeof n.from<"u"&&(t.from=n.from),typeof n.gas<"u"&&(t.gas=o(n.gas)),typeof n.gasPrice<"u"&&(t.gasPrice=o(n.gasPrice)),typeof n.maxFeePerBlobGas<"u"&&(t.maxFeePerBlobGas=o(n.maxFeePerBlobGas)),typeof n.maxFeePerGas<"u"&&(t.maxFeePerGas=o(n.maxFeePerGas)),typeof n.maxPriorityFeePerGas<"u"&&(t.maxPriorityFeePerGas=o(n.maxPriorityFeePerGas)),typeof n.nonce<"u"&&(t.nonce=o(n.nonce)),typeof n.to<"u"&&(t.to=n.to),typeof n.type<"u"&&(t.type=f[n.type]),typeof n.value<"u"&&(t.value=o(n.value)),t}const w=u("transactionRequest",x);function I(n){return n.map(t=>({address:t.address,r:t.r?o(BigInt(t.r)):t.r,s:t.s?o(BigInt(t.s)):t.s,chainId:o(t.chainId),nonce:o(t.nonce),...typeof t.yParity<"u"?{yParity:o(t.yParity)}:{},...typeof t.v<"u"&&typeof t.yParity>"u"?{v:o(t.v)}:{}}))}const T=2n**(8n-1n)-1n,E=2n**(16n-1n)-1n,C=2n**(24n-1n)-1n,R=2n**(32n-1n)-1n,L=2n**(40n-1n)-1n,$=2n**(48n-1n)-1n,F=2n**(56n-1n)-1n,V=2n**(64n-1n)-1n,B=2n**(72n-1n)-1n,G=2n**(80n-1n)-1n,N=2n**(88n-1n)-1n,O=2n**(96n-1n)-1n,S=2n**(104n-1n)-1n,_=2n**(112n-1n)-1n,k=2n**(120n-1n)-1n,D=2n**(128n-1n)-1n,M=2n**(136n-1n)-1n,H=2n**(144n-1n)-1n,j=2n**(152n-1n)-1n,A=2n**(160n-1n)-1n,W=2n**(168n-1n)-1n,Y=2n**(176n-1n)-1n,K=2n**(184n-1n)-1n,J=2n**(192n-1n)-1n,Q=2n**(200n-1n)-1n,X=2n**(208n-1n)-1n,Z=2n**(216n-1n)-1n,z=2n**(224n-1n)-1n,q=2n**(232n-1n)-1n,nn=2n**(240n-1n)-1n,tn=2n**(248n-1n)-1n,sn=2n**(256n-1n)-1n,on=-(2n**(8n-1n)),en=-(2n**(16n-1n)),an=-(2n**(24n-1n)),rn=-(2n**(32n-1n)),cn=-(2n**(40n-1n)),mn=-(2n**(48n-1n)),dn=-(2n**(56n-1n)),hn=-(2n**(64n-1n)),pn=-(2n**(72n-1n)),un=-(2n**(80n-1n)),fn=-(2n**(88n-1n)),xn=-(2n**(96n-1n)),In=-(2n**(104n-1n)),ln=-(2n**(112n-1n)),yn=-(2n**(120n-1n)),Pn=-(2n**(128n-1n)),vn=-(2n**(136n-1n)),Un=-(2n**(144n-1n)),bn=-(2n**(152n-1n)),gn=-(2n**(160n-1n)),wn=-(2n**(168n-1n)),Tn=-(2n**(176n-1n)),En=-(2n**(184n-1n)),Cn=-(2n**(192n-1n)),Rn=-(2n**(200n-1n)),Ln=-(2n**(208n-1n)),$n=-(2n**(216n-1n)),Fn=-(2n**(224n-1n)),Vn=-(2n**(232n-1n)),Bn=-(2n**(240n-1n)),Gn=-(2n**(248n-1n)),Nn=-(2n**(256n-1n)),On=2n**8n-1n,Sn=2n**16n-1n,_n=2n**24n-1n,kn=2n**32n-1n,Dn=2n**40n-1n,Mn=2n**48n-1n,Hn=2n**56n-1n,jn=2n**64n-1n,An=2n**72n-1n,Wn=2n**80n-1n,Yn=2n**88n-1n,Kn=2n**96n-1n,Jn=2n**104n-1n,Qn=2n**112n-1n,Xn=2n**120n-1n,Zn=2n**128n-1n,zn=2n**136n-1n,qn=2n**144n-1n,nt=2n**152n-1n,tt=2n**160n-1n,it=2n**168n-1n,st=2n**176n-1n,ot=2n**184n-1n,et=2n**192n-1n,at=2n**200n-1n,rt=2n**208n-1n,ct=2n**216n-1n,mt=2n**224n-1n,dt=2n**232n-1n,ht=2n**240n-1n,pt=2n**248n-1n,ut=2n**256n-1n;var c=class extends e{constructor({offset:n}){super(`Offset \`${n}\` cannot be negative.`,{name:"NegativeOffsetError"})}},l=class extends e{constructor({length:n,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${n}\`).`,{name:"PositionOutOfBoundsError"})}},y=class extends e{constructor({count:n,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${n}\`).`,{name:"RecursiveReadLimitExceededError"})}};const P={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new y({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(n){if(n<0||n>this.bytes.length-1)throw new l({length:this.bytes.length,position:n})},decrementPosition(n){if(n<0)throw new c({offset:n});const t=this.position-n;this.assertPosition(t),this.position=t},getReadCount(n){return this.positionReadCount.get(n||this.position)||0},incrementPosition(n){if(n<0)throw new c({offset:n});const t=this.position+n;this.assertPosition(t),this.position=t},inspectByte(n){const t=n??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(n,t){const i=t??this.position;return this.assertPosition(i+n-1),this.bytes.subarray(i,i+n)},inspectUint8(n){const t=n??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(n){const t=n??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(n){const t=n??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(n){const t=n??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(n){this.assertPosition(this.position),this.bytes[this.position]=n,this.position++},pushBytes(n){this.assertPosition(this.position+n.length-1),this.bytes.set(n,this.position),this.position+=n.length},pushUint8(n){this.assertPosition(this.position),this.bytes[this.position]=n,this.position++},pushUint16(n){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,n),this.position+=2},pushUint24(n){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,n>>8),this.dataView.setUint8(this.position+2,n&255),this.position+=3},pushUint32(n){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,n),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const n=this.inspectByte();return this.position++,n},readBytes(n,t){this.assertReadLimit(),this._touch();const i=this.inspectBytes(n);return this.position+=t??n,i},readUint8(){this.assertReadLimit(),this._touch();const n=this.inspectUint8();return this.position+=1,n},readUint16(){this.assertReadLimit(),this._touch();const n=this.inspectUint16();return this.position+=2,n},readUint24(){this.assertReadLimit(),this._touch();const n=this.inspectUint24();return this.position+=3,n},readUint32(){this.assertReadLimit(),this._touch();const n=this.inspectUint32();return this.position+=4,n},get remaining(){return this.bytes.length-this.position},setPosition(n){const t=this.position;return this.assertPosition(n),this.position=n,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const n=this.getReadCount();this.positionReadCount.set(this.position,n+1),n>0&&this.recursiveReadCount++}};function ft(n,{recursiveReadLimit:t=8192}={}){const i=Object.create(P);return i.bytes=n,i.dataView=new DataView(n.buffer,n.byteOffset,n.byteLength),i.positionReadCount=new Map,i.recursiveReadLimit=t,i}function xt(n,t="wei"){return p(n,h[t])}function v(n){const t=Object.entries(n).map(([a,s])=>s===void 0||s===!1?null:[a,s]).filter(Boolean),i=t.reduce((a,[s])=>Math.max(a,s.length),0);return t.map(([a,s])=>`  ${`${a}:`.padEnd(i+1)}  ${s}`).join(`
`)}var It=class extends e{constructor(){super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.","Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join(`
`),{name:"FeeConflictError"})}},lt=class extends e{constructor({v:n}){super(`Invalid \`v\` value "${n}". Expected 27 or 28.`,{name:"InvalidLegacyVError"})}},yt=class extends e{constructor({transaction:n}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",v(n),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}},Pt=class extends e{constructor({storageKey:n}){super(`Size for storage key "${n}" is invalid. Expected 32 bytes. Got ${Math.floor((n.length-2)/2)} bytes.`,{name:"InvalidStorageKeySizeError"})}},vt=class extends e{constructor({blockHash:n,blockNumber:t,blockTag:i,hash:a,index:s}){let r="Transaction";i&&s!==void 0&&(r=`Transaction at block time "${i}" at index "${s}"`),n&&s!==void 0&&(r=`Transaction at block hash "${n}" at index "${s}"`),t&&s!==void 0&&(r=`Transaction at block number "${t}" at index "${s}"`),a&&(r=`Transaction with hash "${a}"`),super(`${r} could not be found.`,{name:"TransactionNotFoundError"})}},Ut=class extends e{constructor({hash:n}){super(`Transaction receipt with hash "${n}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}},bt=class extends e{constructor({hash:n}){super(`Timed out while waiting for transaction with hash "${n}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}},gt=class extends e{constructor({blockNumber:n,chain:t,contract:i}){super(`Chain "${t.name}" does not support contract "${i.name}".`,{metaMessages:["This could be due to any of the following:",...n&&i.blockCreated&&i.blockCreated>n?[`- The contract "${i.name}" was not deployed until block ${i.blockCreated} (current block ${n}).`]:[`- The chain does not have the contract "${i.name}" configured.`]],name:"ChainDoesNotSupportContract"})}},wt=class extends e{constructor(){super("No chain was provided to the Client.",{name:"ClientChainNotConfiguredError"})}},Tt=class extends e{constructor({chainId:n}){super(typeof n=="number"?`Chain ID "${n}" is invalid.`:"Chain ID is invalid.",{name:"InvalidChainIdError"})}};export{gt as ChainDoesNotSupportContract,wt as ClientChainNotConfiguredError,It as FeeConflictError,Tt as InvalidChainIdError,lt as InvalidLegacyVError,yt as InvalidSerializableTransactionError,Pt as InvalidStorageKeySizeError,l as PositionOutOfBoundsError,vt as TransactionNotFoundError,Ut as TransactionReceiptNotFoundError,bt as WaitForTransactionReceiptTimeoutError,ft as createCursor,u as defineFormatter,w as defineTransactionRequest,xt as formatEther,x as formatTransactionRequest,Sn as maxUint16,ut as maxUint256,v as prettyPrint};
