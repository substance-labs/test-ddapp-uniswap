import{anumber as ae,concatBytes as le,init_utils as Pt,randomBytes as ue}from"./_u64-b_viZRi_.js";import{init_sha2 as de,sha256 as he}from"./sha2-Jt0E41S_.js";import{hmac as we,init_hmac as ge}from"./hmac-D-QTodfL.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tt=BigInt(0),Ot=BigInt(1);function lt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ut(e){if(!lt(e))throw new Error("Uint8Array expected")}function ft(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function wt(e){const n=e.toString(16);return n.length&1?"0"+n:n}function Wt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Tt:BigInt("0x"+e)}const Dt=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",me=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function at(e){if(Ut(e),Dt)return e.toHex();let n="";for(let t=0;t<e.length;t++)n+=me[e[t]];return n}const G={_0:48,_9:57,A:65,F:70,a:97,f:102};function kt(e){if(e>=G._0&&e<=G._9)return e-G._0;if(e>=G.A&&e<=G.F)return e-(G.A-10);if(e>=G.a&&e<=G.f)return e-(G.a-10)}function gt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Dt)return Uint8Array.fromHex(e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const f=kt(e.charCodeAt(s)),l=kt(e.charCodeAt(s+1));if(f===void 0||l===void 0){const o=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=f*16+l}return r}function nt(e){return Wt(at(e))}function Gt(e){return Ut(e),Wt(at(Uint8Array.from(e).reverse()))}function ut(e,n){return gt(e.toString(16).padStart(n*2,"0"))}function Xt(e,n){return ut(e,n).reverse()}function $(e,n,t){let r;if(typeof n=="string")try{r=gt(n)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(lt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}function mt(...e){let n=0;for(let r=0;r<e.length;r++){const i=e[r];Ut(i),n+=i.length}const t=new Uint8Array(n);for(let r=0,i=0;r<e.length;r++){const s=e[r];t.set(s,i),i+=s.length}return t}const bt=e=>typeof e=="bigint"&&Tt<=e;function _t(e,n,t){return bt(e)&&bt(n)&&bt(t)&&n<=e&&e<t}function it(e,n,t,r){if(!_t(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function pe(e){let n;for(n=0;e>Tt;e>>=Ot,n+=1);return n}const pt=e=>(Ot<<BigInt(e))-Ot,vt=e=>new Uint8Array(e),Ct=e=>Uint8Array.from(e);function ye(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=vt(e),i=vt(e),s=0;const f=()=>{r.fill(1),i.fill(0),s=0},l=(...B)=>t(i,r,...B),o=(B=vt(0))=>{i=l(Ct([0]),B),r=l(),B.length!==0&&(i=l(Ct([1]),B),r=l())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let B=0;const A=[];for(;B<n;){r=l();const z=r.slice();A.push(z),B+=r.length}return mt(...A)};return(B,A)=>{f(),o(B);let z;for(;!(z=A(d()));)o();return f(),z}}const Ee={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||lt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function yt(e,n,t={}){const r=(i,s,f)=>{const l=Ee[s];if(typeof l!="function")throw new Error("invalid validator function");const o=e[i];if(!(f&&o===void 0)&&!l(o,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(n))r(i,s,!1);for(const[i,s]of Object.entries(t))r(i,s,!0);return e}function Vt(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const s=e(t,...r);return n.set(t,s),s}}Pt();const V=BigInt(0),k=BigInt(1),et=BigInt(2),be=BigInt(3),Ft=BigInt(4),Qt=BigInt(5),Jt=BigInt(8);function H(e,n){const t=e%n;return t>=V?t:n+t}function j(e,n,t){let r=e;for(;n-- >V;)r*=r,r%=t;return r}function qt(e,n){if(e===V)throw new Error("invert: expected non-zero number");if(n<=V)throw new Error("invert: expected positive modulus, got "+n);let t=H(e,n),r=n,i=V,s=k,f=k,l=V;for(;t!==V;){const d=r/t,w=r%t,B=i-f*d,A=s-l*d;r=t,t=w,i=f,s=l,f=B,l=A}if(r!==k)throw new Error("invert: does not exist");return H(i,n)}function te(e,n){const t=(e.ORDER+k)/Ft,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function ve(e,n){const t=(e.ORDER-Qt)/Jt,r=e.mul(n,et),i=e.pow(r,t),s=e.mul(n,i),f=e.mul(e.mul(s,et),i),l=e.mul(s,e.sub(f,e.ONE));if(!e.eql(e.sqr(l),n))throw new Error("Cannot find square root");return l}function Be(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-k,t=0;for(;n%et===V;)n/=et,t++;let r=et;const i=Lt(e);for(;Ht(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return te;let s=i.pow(r,n);const f=(n+k)/et;return function(o,d){if(o.is0(d))return d;if(Ht(o,d)!==1)throw new Error("Cannot find square root");let w=t,B=o.mul(o.ONE,s),A=o.pow(d,n),z=o.pow(d,f);for(;!o.eql(A,o.ONE);){if(o.is0(A))return o.ZERO;let T=1,m=o.sqr(A);for(;!o.eql(m,o.ONE);)if(T++,m=o.sqr(m),T===w)throw new Error("Cannot find square root");const C=k<<BigInt(w-T-1),U=o.pow(B,C);w=T,B=o.sqr(U),A=o.mul(A,B),z=o.mul(z,U)}return z}}function Se(e){return e%Ft===be?te:e%Jt===Qt?ve:Be(e)}const xe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ae(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=xe.reduce((r,i)=>(r[i]="function",r),n);return yt(e,t)}function Ne(e,n,t){if(t<V)throw new Error("invalid exponent, negatives unsupported");if(t===V)return e.ONE;if(t===k)return n;let r=e.ONE,i=n;for(;t>V;)t&k&&(r=e.mul(r,i)),i=e.sqr(i),t>>=k;return r}function ee(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((f,l,o)=>e.is0(l)?f:(r[o]=f,e.mul(f,l)),e.ONE),s=e.inv(i);return n.reduceRight((f,l,o)=>e.is0(l)?f:(r[o]=e.mul(f,r[o]),e.mul(f,l)),s),r}function Ht(e,n){const t=(e.ORDER-k)/et,r=e.pow(n,t),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),f=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!f)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function ne(e,n){n!==void 0&&ae(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Lt(e,n,t=!1,r={}){if(e<=V)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=ne(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const l=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:s,MASK:pt(i),ZERO:V,ONE:k,create:o=>H(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return V<=o&&o<e},is0:o=>o===V,isOdd:o=>(o&k)===k,neg:o=>H(-o,e),eql:(o,d)=>o===d,sqr:o=>H(o*o,e),add:(o,d)=>H(o+d,e),sub:(o,d)=>H(o-d,e),mul:(o,d)=>H(o*d,e),pow:(o,d)=>Ne(l,o,d),div:(o,d)=>H(o*qt(d,e),e),sqrN:o=>o*o,addN:(o,d)=>o+d,subN:(o,d)=>o-d,mulN:(o,d)=>o*d,inv:o=>qt(o,e),sqrt:r.sqrt||(o=>(f||(f=Se(e)),f(l,o))),toBytes:o=>t?Xt(o,s):ut(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?Gt(o):nt(o)},invertBatch:o=>ee(l,o),cmov:(o,d,w)=>w?d:o});return Object.freeze(l)}function re(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function oe(e){const n=re(e);return n+Math.ceil(n/2)}function Ie(e,n,t=!1){const r=e.length,i=re(n),s=oe(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const f=t?Gt(e):nt(e),l=H(f,n-k)+k;return t?Xt(l,i):ut(l,i)}const Mt=BigInt(0),Rt=BigInt(1);function Bt(e,n){const t=n.negate();return e?t:n}function ie(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function St(e,n){ie(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,s=pt(e),f=BigInt(e);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:f}}function Yt(e,n,t){const{windowSize:r,mask:i,maxNumber:s,shiftBy:f}=t;let l=Number(e&i),o=e>>f;l>r&&(l-=s,o+=Rt);const d=n*r,w=d+Math.abs(l)-1,B=l===0,A=l<0,z=n%2!==0;return{nextN:o,offset:w,isZero:B,isNeg:A,isNegF:z,offsetF:d}}function Oe(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function qe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const xt=new WeakMap,se=new WeakMap;function At(e){return se.get(e)||1}function Re(e,n){return{constTimeNegate:Bt,hasPrecomputes(t){return At(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>Mt;)r&Rt&&(i=i.add(s)),s=s.double(),r>>=Rt;return i},precomputeWindow(t,r){const{windows:i,windowSize:s}=St(r,n),f=[];let l=t,o=l;for(let d=0;d<i;d++){o=l,f.push(o);for(let w=1;w<s;w++)o=o.add(l),f.push(o);l=o.double()}return f},wNAF(t,r,i){let s=e.ZERO,f=e.BASE;const l=St(t,n);for(let o=0;o<l.windows;o++){const{nextN:d,offset:w,isZero:B,isNeg:A,isNegF:z,offsetF:T}=Yt(i,o,l);i=d,B?f=f.add(Bt(z,r[T])):s=s.add(Bt(A,r[w]))}return{p:s,f}},wNAFUnsafe(t,r,i,s=e.ZERO){const f=St(t,n);for(let l=0;l<f.windows&&i!==Mt;l++){const{nextN:o,offset:d,isZero:w,isNeg:B}=Yt(i,l,f);if(i=o,!w){const A=r[d];s=s.add(B?A.negate():A)}}return s},getPrecomputes(t,r,i){let s=xt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&xt.set(r,i(s))),s},wNAFCached(t,r,i){const s=At(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){const f=At(t);return f===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(f,this.getPrecomputes(f,t,i),r,s)},setWindowSize(t,r){ie(r,n),se.set(t,r),xt.delete(t)}}}function Ze(e,n,t,r){Oe(t,e),qe(r,n);const i=t.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const f=e.ZERO,l=pe(BigInt(i));let o=1;l>12?o=l-3:l>4?o=l-2:l>0&&(o=2);const d=pt(o),w=new Array(Number(d)+1).fill(f),B=Math.floor((n.BITS-1)/o)*o;let A=f;for(let z=B;z>=0;z-=o){w.fill(f);for(let m=0;m<s;m++){const C=r[m],U=Number(C>>BigInt(z)&d);w[U]=w[U].add(t[m])}let T=f;for(let m=w.length-1,C=f;m>0;m--)C=C.add(w[m]),T=T.add(C);if(A=A.add(T),z!==0)for(let m=0;m<o;m++)A=A.double()}return A}function ce(e){return Ae(e.Fp),yt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ne(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function jt(e){e.lowS!==void 0&&ft("lowS",e.lowS),e.prehash!==void 0&&ft("prehash",e.prehash)}function ze(e){const n=ce(e);yt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}var Te=class extends Error{constructor(e=""){super(e)}};const X={Err:Te,_tlv:{encode:(e,n)=>{const{Err:t}=X;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=wt(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?wt(i.length/2|128):"";return wt(e)+s+i+n},decode(e,n){const{Err:t}=X;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let f=0;if(!s)f=i;else{const o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+o);if(d.length!==o)throw new t("tlv.decode: length bytes not complete");if(d[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const w of d)f=f<<8|w;if(r+=o,f<128)throw new t("tlv.decode(long): not minimal encoding")}const l=n.subarray(r,r+f);if(l.length!==f)throw new t("tlv.decode: wrong value length");return{v:l,l:n.subarray(r+f)}}},_int:{encode(e){const{Err:n}=X;if(e<F)throw new n("integer: negative integers are not allowed");let t=wt(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=X;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return nt(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=X,i=$("signature",e),{v:s,l:f}=r.decode(48,i);if(f.length)throw new n("invalid signature: left bytes after parsing");const{v:l,l:o}=r.decode(2,s),{v:d,l:w}=r.decode(2,o);if(w.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(l),s:t.decode(d)}},hexFromSig(e){const{_tlv:n,_int:t}=X,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}};function Nt(e,n){return at(ut(e,n))}const F=BigInt(0),_=BigInt(1),Pe=BigInt(2),It=BigInt(3),Ue=BigInt(4);function _e(e){const n=ze(e),{Fp:t}=n,r=Lt(n.n,n.nBitLength),i=n.toBytes||((S,c,h)=>{const y=c.toAffine();return mt(Uint8Array.from([4]),t.toBytes(y.x),t.toBytes(y.y))}),s=n.fromBytes||(S=>{const c=S.subarray(1),h=t.fromBytes(c.subarray(0,t.BYTES)),y=t.fromBytes(c.subarray(t.BYTES,2*t.BYTES));return{x:h,y}});function f(S){const{a:c,b:h}=n,y=t.sqr(S),v=t.mul(y,S);return t.add(t.add(v,t.mul(S,c)),h)}function l(S,c){const h=t.sqr(c),y=f(S);return t.eql(h,y)}if(!l(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=t.mul(t.pow(n.a,It),Ue),d=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(o,d)))throw new Error("bad curve params: a or b");function w(S){return _t(S,_,n.n)}function B(S){const{allowedPrivateKeyLengths:c,nByteLength:h,wrapPrivateKey:y,n:v}=n;if(c&&typeof S!="bigint"){if(lt(S)&&(S=at(S)),typeof S!="string"||!c.includes(S.length))throw new Error("invalid private key");S=S.padStart(h*2,"0")}let O;try{O=typeof S=="bigint"?S:nt($("private key",S,h))}catch{throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof S)}return y&&(O=H(O,v)),it("private key",O,_,v),O}function A(S){if(!(S instanceof m))throw new Error("ProjectivePoint expected")}const z=Vt((S,c)=>{const{px:h,py:y,pz:v}=S;if(t.eql(v,t.ONE))return{x:h,y};const O=S.is0();c==null&&(c=O?t.ONE:t.inv(v));const R=t.mul(h,c),q=t.mul(y,c),E=t.mul(v,c);if(O)return{x:t.ZERO,y:t.ZERO};if(!t.eql(E,t.ONE))throw new Error("invZ was invalid");return{x:R,y:q}}),T=Vt(S=>{if(S.is0()){if(n.allowInfinityPoint&&!t.is0(S.py))return;throw new Error("bad point: ZERO")}const{x:c,y:h}=S.toAffine();if(!t.isValid(c)||!t.isValid(h))throw new Error("bad point: x or y not FE");if(!l(c,h))throw new Error("bad point: equation left != right");if(!S.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class m{constructor(c,h,y){if(c==null||!t.isValid(c))throw new Error("x required");if(h==null||!t.isValid(h)||t.is0(h))throw new Error("y required");if(y==null||!t.isValid(y))throw new Error("z required");this.px=c,this.py=h,this.pz=y,Object.freeze(this)}static fromAffine(c){const{x:h,y}=c||{};if(!c||!t.isValid(h)||!t.isValid(y))throw new Error("invalid affine point");if(c instanceof m)throw new Error("projective point not allowed");const v=O=>t.eql(O,t.ZERO);return v(h)&&v(y)?m.ZERO:new m(h,y,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){const h=ee(t,c.map(y=>y.pz));return c.map((y,v)=>y.toAffine(h[v])).map(m.fromAffine)}static fromHex(c){const h=m.fromAffine(s($("pointHex",c)));return h.assertValidity(),h}static fromPrivateKey(c){return m.BASE.multiply(B(c))}static msm(c,h){return Ze(m,r,c,h)}_setWindowSize(c){P.setWindowSize(this,c)}assertValidity(){T(this)}hasEvenY(){const{y:c}=this.toAffine();if(t.isOdd)return!t.isOdd(c);throw new Error("Field doesn't support isOdd")}equals(c){A(c);const{px:h,py:y,pz:v}=this,{px:O,py:R,pz:q}=c,E=t.eql(t.mul(h,q),t.mul(O,v)),N=t.eql(t.mul(y,q),t.mul(R,v));return E&&N}negate(){return new m(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:h}=n,y=t.mul(h,It),{px:v,py:O,pz:R}=this;let q=t.ZERO,E=t.ZERO,N=t.ZERO,b=t.mul(v,v),L=t.mul(O,O),u=t.mul(R,R),a=t.mul(v,O);return a=t.add(a,a),N=t.mul(v,R),N=t.add(N,N),q=t.mul(c,N),E=t.mul(y,u),E=t.add(q,E),q=t.sub(L,E),E=t.add(L,E),E=t.mul(q,E),q=t.mul(a,q),N=t.mul(y,N),u=t.mul(c,u),a=t.sub(b,u),a=t.mul(c,a),a=t.add(a,N),N=t.add(b,b),b=t.add(N,b),b=t.add(b,u),b=t.mul(b,a),E=t.add(E,b),u=t.mul(O,R),u=t.add(u,u),b=t.mul(u,a),q=t.sub(q,b),N=t.mul(u,L),N=t.add(N,N),N=t.add(N,N),new m(q,E,N)}add(c){A(c);const{px:h,py:y,pz:v}=this,{px:O,py:R,pz:q}=c;let E=t.ZERO,N=t.ZERO,b=t.ZERO;const L=n.a,u=t.mul(n.b,It);let a=t.mul(h,O),g=t.mul(y,R),x=t.mul(v,q),I=t.add(h,y),p=t.add(O,R);I=t.mul(I,p),p=t.add(a,g),I=t.sub(I,p),p=t.add(h,v);let Z=t.add(O,q);return p=t.mul(p,Z),Z=t.add(a,x),p=t.sub(p,Z),Z=t.add(y,v),E=t.add(R,q),Z=t.mul(Z,E),E=t.add(g,x),Z=t.sub(Z,E),b=t.mul(L,p),E=t.mul(u,x),b=t.add(E,b),E=t.sub(g,b),b=t.add(g,b),N=t.mul(E,b),g=t.add(a,a),g=t.add(g,a),x=t.mul(L,x),p=t.mul(u,p),g=t.add(g,x),x=t.sub(a,x),x=t.mul(L,x),p=t.add(p,x),a=t.mul(g,p),N=t.add(N,a),a=t.mul(Z,p),E=t.mul(I,E),E=t.sub(E,a),a=t.mul(I,g),b=t.mul(Z,b),b=t.add(b,a),new m(E,N,b)}subtract(c){return this.add(c.negate())}is0(){return this.equals(m.ZERO)}wNAF(c){return P.wNAFCached(this,c,m.normalizeZ)}multiplyUnsafe(c){const{endo:h,n:y}=n;it("scalar",c,F,y);const v=m.ZERO;if(c===F)return v;if(this.is0()||c===_)return this;if(!h||P.hasPrecomputes(this))return P.wNAFCachedUnsafe(this,c,m.normalizeZ);let{k1neg:O,k1:R,k2neg:q,k2:E}=h.splitScalar(c),N=v,b=v,L=this;for(;R>F||E>F;)R&_&&(N=N.add(L)),E&_&&(b=b.add(L)),L=L.double(),R>>=_,E>>=_;return O&&(N=N.negate()),q&&(b=b.negate()),b=new m(t.mul(b.px,h.beta),b.py,b.pz),N.add(b)}multiply(c){const{endo:h,n:y}=n;it("scalar",c,_,y);let v,O;if(h){const{k1neg:R,k1:q,k2neg:E,k2:N}=h.splitScalar(c);let{p:b,f:L}=this.wNAF(q),{p:u,f:a}=this.wNAF(N);b=P.constTimeNegate(R,b),u=P.constTimeNegate(E,u),u=new m(t.mul(u.px,h.beta),u.py,u.pz),v=b.add(u),O=L.add(a)}else{const{p:R,f:q}=this.wNAF(c);v=R,O=q}return m.normalizeZ([v,O])[0]}multiplyAndAddUnsafe(c,h,y){const v=m.BASE,O=(q,E)=>E===F||E===_||!q.equals(v)?q.multiplyUnsafe(E):q.multiply(E),R=O(this,h).add(O(c,y));return R.is0()?void 0:R}toAffine(c){return z(this,c)}isTorsionFree(){const{h:c,isTorsionFree:h}=n;if(c===_)return!0;if(h)return h(m,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:c,clearCofactor:h}=n;return c===_?this:h?h(m,this):this.multiplyUnsafe(n.h)}toRawBytes(c=!0){return ft("isCompressed",c),this.assertValidity(),i(m,this,c)}toHex(c=!0){return ft("isCompressed",c),at(this.toRawBytes(c))}}m.BASE=new m(n.Gx,n.Gy,t.ONE),m.ZERO=new m(t.ZERO,t.ONE,t.ZERO);const{endo:C,nBitLength:U}=n,P=Re(m,C?Math.ceil(U/2):U);return{CURVE:n,ProjectivePoint:m,normPrivateKeyToScalar:B,weierstrassEquation:f,isWithinCurveOrder:w}}function Le(e){const n=ce(e);return yt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function ke(e){const n=Le(e),{Fp:t,n:r,nByteLength:i,nBitLength:s}=n,f=t.BYTES+1,l=2*t.BYTES+1;function o(u){return H(u,r)}function d(u){return qt(u,r)}const{ProjectivePoint:w,normPrivateKeyToScalar:B,weierstrassEquation:A,isWithinCurveOrder:z}=_e({...n,toBytes(u,a,g){const x=a.toAffine(),I=t.toBytes(x.x),p=mt;return ft("isCompressed",g),g?p(Uint8Array.from([a.hasEvenY()?2:3]),I):p(Uint8Array.from([4]),I,t.toBytes(x.y))},fromBytes(u){const a=u.length,g=u[0],x=u.subarray(1);if(a===f&&(g===2||g===3)){const I=nt(x);if(!_t(I,_,t.ORDER))throw new Error("Point is not on curve");const p=A(I);let Z;try{Z=t.sqrt(p)}catch(Y){const D=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+D)}const W=(Z&_)===_;return(g&1)===1!==W&&(Z=t.neg(Z)),{x:I,y:Z}}else if(a===l&&g===4){const I=t.fromBytes(x.subarray(0,t.BYTES)),p=t.fromBytes(x.subarray(t.BYTES,2*t.BYTES));return{x:I,y:p}}else{const I=f,p=l;throw new Error("invalid Point, expected length of "+I+", or uncompressed "+p+", got "+a)}}});function T(u){const a=r>>_;return u>a}function m(u){return T(u)?o(-u):u}const C=(u,a,g)=>nt(u.slice(a,g));class U{constructor(a,g,x){it("r",a,_,r),it("s",g,_,r),this.r=a,this.s=g,x!=null&&(this.recovery=x),Object.freeze(this)}static fromCompact(a){const g=i;return a=$("compactSignature",a,g*2),new U(C(a,0,g),C(a,g,2*g))}static fromDER(a){const{r:g,s:x}=X.toSig($("DER",a));return new U(g,x)}assertValidity(){}addRecoveryBit(a){return new U(this.r,this.s,a)}recoverPublicKey(a){const{r:g,s:x,recovery:I}=this,p=v($("msgHash",a));if(I==null||![0,1,2,3].includes(I))throw new Error("recovery id invalid");const Z=I===2||I===3?g+n.n:g;if(Z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const W=(I&1)===0?"02":"03",M=w.fromHex(W+Nt(Z,t.BYTES)),Y=d(Z),D=o(-p*Y),K=o(x*Y),Q=w.BASE.multiplyAndAddUnsafe(M,D,K);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return T(this.s)}normalizeS(){return this.hasHighS()?new U(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return gt(this.toDERHex())}toDERHex(){return X.hexFromSig(this)}toCompactRawBytes(){return gt(this.toCompactHex())}toCompactHex(){const a=i;return Nt(this.r,a)+Nt(this.s,a)}}const P={isValidPrivateKey(u){try{return B(u),!0}catch{return!1}},normPrivateKeyToScalar:B,randomPrivateKey:()=>{const u=oe(n.n);return Ie(n.randomBytes(u),n.n)},precompute(u=8,a=w.BASE){return a._setWindowSize(u),a.multiply(BigInt(3)),a}};function S(u,a=!0){return w.fromPrivateKey(u).toRawBytes(a)}function c(u){if(typeof u=="bigint")return!1;if(u instanceof w)return!0;const g=$("key",u).length,x=t.BYTES,I=x+1,p=2*x+1;if(!(n.allowedPrivateKeyLengths||i===I))return g===I||g===p}function h(u,a,g=!0){if(c(u)===!0)throw new Error("first arg must be private key");if(c(a)===!1)throw new Error("second arg must be public key");return w.fromHex(a).multiply(B(u)).toRawBytes(g)}const y=n.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const a=nt(u),g=u.length*8-s;return g>0?a>>BigInt(g):a},v=n.bits2int_modN||function(u){return o(y(u))},O=pt(s);function R(u){return it("num < 2^"+s,u,F,O),ut(u,i)}function q(u,a,g=E){if(["recovered","canonical"].some(J=>J in g))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:I}=n;let{lowS:p,prehash:Z,extraEntropy:W}=g;p==null&&(p=!0),u=$("msgHash",u),jt(g),Z&&(u=$("prehashed msgHash",x(u)));const M=v(u),Y=B(a),D=[R(Y),R(M)];if(W!=null&&W!==!1){const J=W===!0?I(t.BYTES):W;D.push($("extraEntropy",J))}const K=mt(...D),Q=M;function dt(J){const st=y(J);if(!z(st))return;const ht=d(st),ct=w.BASE.multiply(st).toAffine(),rt=o(ct.x);if(rt===F)return;const tt=o(ht*o(Q+rt*Y));if(tt===F)return;let Et=(ct.x===rt?0:2)|Number(ct.y&_),ot=tt;return p&&T(tt)&&(ot=m(tt),Et^=1),new U(rt,ot,Et)}return{seed:K,k2sig:dt}}const E={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function b(u,a,g=E){const{seed:x,k2sig:I}=q(u,a,g),p=n;return ye(p.hash.outputLen,p.nByteLength,p.hmac)(x,I)}w.BASE._setWindowSize(8);function L(u,a,g,x=N){var I;const p=u;a=$("msgHash",a),g=$("publicKey",g);const{lowS:Z,prehash:W,format:M}=x;if(jt(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const Y=typeof p=="string"||lt(p),D=!Y&&!M&&typeof p=="object"&&p!==null&&typeof p.r=="bigint"&&typeof p.s=="bigint";if(!Y&&!D)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,Q;try{if(D&&(K=new U(p.r,p.s)),Y){try{M!=="compact"&&(K=U.fromDER(p))}catch(ot){if(!(ot instanceof X.Err))throw ot}!K&&M!=="der"&&(K=U.fromCompact(p))}Q=w.fromHex(g)}catch{return!1}if(!K||Z&&K.hasHighS())return!1;W&&(a=n.hash(a));const{r:dt,s:J}=K,st=v(a),ht=d(J),ct=o(st*ht),rt=o(dt*ht),tt=(I=w.BASE.multiplyAndAddUnsafe(Q,ct,rt))===null||I===void 0?void 0:I.toAffine();return tt?o(tt.x)===dt:!1}return{CURVE:n,getPublicKey:S,getSharedSecret:h,sign:b,verify:L,ProjectivePoint:w,Signature:U,utils:P}}ge();Pt();function Ce(e){return{hash:e,hmac:(n,...t)=>we(e,n,le(...t)),randomBytes:ue}}function Ve(e,n){const t=r=>ke({...e,...Ce(r)});return{...t(n),create:t}}de();const fe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),$t=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),He=BigInt(0),Me=BigInt(1),Zt=BigInt(2),Kt=(e,n)=>(e+n/Zt)/n;function Ye(e){const n=fe,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),f=BigInt(23),l=BigInt(44),o=BigInt(88),d=e*e*e%n,w=d*d*e%n,B=j(w,t,n)*w%n,A=j(B,t,n)*w%n,z=j(A,Zt,n)*d%n,T=j(z,i,n)*z%n,m=j(T,s,n)*T%n,C=j(m,l,n)*m%n,U=j(C,o,n)*C%n,P=j(U,l,n)*m%n,S=j(P,t,n)*w%n,c=j(S,f,n)*T%n,h=j(c,r,n)*d%n,y=j(h,Zt,n);if(!zt.eql(zt.sqr(y),e))throw new Error("Cannot find square root");return y}const zt=Lt(fe,void 0,void 0,{sqrt:Ye}),We=Ve({a:He,b:BigInt(7),Fp:zt,n:$t,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=$t,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Me*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,f=BigInt("0x100000000000000000000000000000000"),l=Kt(s*e,n),o=Kt(-r*e,n);let d=H(e-l*t-o*i,n),w=H(-l*r-o*s,n);const B=d>f,A=w>f;if(B&&(d=n-d),A&&(w=n-w),d>f||w>f)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:B,k1:d,k2neg:A,k2:w}}}},he);export{We as secp256k1};
