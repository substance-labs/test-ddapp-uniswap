import"./preload-helper-CaakwtpC.js";import{BaseError as u,isHex as k}from"./isAddress-P2vaZgmG.js";import"./chain-ghiO403o.js";import{concat as v}from"./slice-cfC6NcyN.js";import"./node-C_BraYgX.js";import"./formatUnits-DkyMpOD7.js";import"./_u64-b_viZRi_.js";import{call as b,decodeErrorResult as L}from"./call-CTDbaN-t.js";import"./parseAccount-CRyN5swV.js";import{encodeAbiParameters as O}from"./encodeFunctionData-CD63gkvM.js";import{stringify as y}from"./stringify-B82RFruy.js";import{HttpRequestError as h,getUrl as w}from"./rpc-nQR4Ijs4.js";import{isAddressEqual as R,localBatchGatewayRequest as E,localBatchGatewayUrl as x}from"./localBatchGatewayRequest-CdT4Kija.js";import"./createBatchScheduler-BJBpfhFD.js";var M=class extends u{constructor({callbackSelector:o,cause:a,data:d,extraData:s,sender:n,urls:i}){var t;super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],!((t=a.metaMessages)===null||t===void 0)&&t.length?"":[],"Offchain Gateway Call:",i&&["  Gateway URL(s):",...i.map(c=>`    ${w(c)}`)],`  Sender: ${n}`,`  Data: ${d}`,`  Callback selector: ${o}`,`  Extra data: ${s}`].flat(),name:"OffchainLookupError"})}},S=class extends u{constructor({result:o,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${w(a)}`,`Response: ${y(o)}`],name:"OffchainLookupResponseMalformedError"})}},q=class extends u{constructor({sender:o,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${o}`],name:"OffchainLookupSenderMismatchError"})}};const _="0x556f1830",T={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function z(o,{blockNumber:a,blockTag:d,data:s,to:n}){const{args:i}=L({data:s,abi:[T]}),[t,c,l,p,r]=i,{ccipRead:e}=o,m=e&&typeof(e==null?void 0:e.request)=="function"?e.request:C;try{if(!R(n,t))throw new q({sender:t,to:n});const f=c.includes(x)?await E({data:l,ccipRequest:m}):await m({data:l,sender:t,urls:c}),{data:g}=await b(o,{blockNumber:a,blockTag:d,data:v([p,O([{type:"bytes"},{type:"bytes"}],[f,r])]),to:n});return g}catch(f){throw new M({callbackSelector:p,cause:f,data:s,extraData:r,sender:t,urls:c})}}async function C({data:o,sender:a,urls:d}){let s=new Error("An unknown error occurred.");for(let i=0;i<d.length;i++){const t=d[i],c=t.includes("{data}")?"GET":"POST",l=c==="POST"?{data:o,sender:a}:void 0,p=c==="POST"?{"Content-Type":"application/json"}:{};try{var n;const r=await fetch(t.replace("{sender}",a.toLowerCase()).replace("{data}",o),{body:JSON.stringify(l),headers:p,method:c});let e;if(!((n=r.headers.get("Content-Type"))===null||n===void 0)&&n.startsWith("application/json")?e=(await r.json()).data:e=await r.text(),!r.ok){s=new h({body:l,details:e!=null&&e.error?y(e.error):r.statusText,headers:r.headers,status:r.status,url:t});continue}if(!k(e)){s=new S({result:e,url:t});continue}return e}catch(r){s=new h({body:l,details:r.message,url:t})}}throw s}export{z as offchainLookup,_ as offchainLookupSignature};
