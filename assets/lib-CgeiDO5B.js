import{__esm as j,__export as J}from"./chunk-DgAfPHQg.js";import{BigNumber as g,Logger as h,arrayify as M,concat as V,getAddress as L,getContractAddress as x,hexlify as C,init_lib$2 as B,init_lib$5 as W,init_lib$6 as Z,init_lib$7 as K,isBytes as X,isHexString as N}from"./lib-DPFIyRke.js";import{deepCopy as k,defineReadOnly as l,getStatic as _,init_lib$2 as Q,resolveProperties as P,shallowCopy as m}from"./lib-CKG8APVv.js";import{Indexed as Y,Interface as O,checkResultErrors as ee,init_lib as te}from"./lib-XGdDYWzD.js";import{Provider as re,Signer as U,VoidSigner as ie,accessListify as ne,init_lib$1 as se,init_lib$2 as oe,init_lib$4 as ae}from"./lib-BncBk3QF.js";var F,le=j({"../../node_modules/@ethersproject/contracts/lib.esm/_version.js"(){F="contracts/5.7.0"}}),ce={};J(ce,{BaseContract:()=>S,Contract:()=>w,ContractFactory:()=>H});function b(e,t){return p(this,void 0,void 0,function*(){const r=yield t;typeof r!="string"&&c.throwArgumentError("invalid address or ENS name","name",r);try{return L(r)}catch{}e||c.throwError("a provider or signer is needed to resolve ENS names",h.errors.UNSUPPORTED_OPERATION,{operation:"resolveName"});const i=yield e.resolveName(r);return i==null&&c.throwArgumentError("resolver or addr is not configured for ENS name","name",r),i})}function y(e,t,r){return p(this,void 0,void 0,function*(){return Array.isArray(r)?yield Promise.all(r.map((i,a)=>y(e,Array.isArray(t)?t[a]:t[i.name],i))):r.type==="address"?yield b(e,t):r.type==="tuple"?yield y(e,t,r.components):r.baseType==="array"?Array.isArray(t)?yield Promise.all(t.map(i=>y(e,i,r.arrayChildren))):Promise.reject(c.makeError("invalid value for array",h.errors.INVALID_ARGUMENT,{argument:"value",value:t})):t})}function R(e,t,r){return p(this,void 0,void 0,function*(){let i={};r.length===t.inputs.length+1&&typeof r[r.length-1]=="object"&&(i=m(r.pop())),c.checkArgumentCount(r.length,t.inputs.length,"passed to contract"),e.signer?i.from?i.from=P({override:b(e.signer,i.from),signer:e.signer.getAddress()}).then(d=>p(this,void 0,void 0,function*(){return L(d.signer)!==d.override&&c.throwError("Contract with a Signer cannot override from",h.errors.UNSUPPORTED_OPERATION,{operation:"overrides.from"}),d.override})):i.from=e.signer.getAddress():i.from&&(i.from=b(e.provider,i.from));const a=yield P({args:y(e.signer||e.provider,r,t.inputs),address:e.resolvedAddress,overrides:P(i)||{}}),n=e.interface.encodeFunctionData(t,a.args),s={data:n,to:a.address},o=a.overrides;if(o.nonce!=null&&(s.nonce=g.from(o.nonce).toNumber()),o.gasLimit!=null&&(s.gasLimit=g.from(o.gasLimit)),o.gasPrice!=null&&(s.gasPrice=g.from(o.gasPrice)),o.maxFeePerGas!=null&&(s.maxFeePerGas=g.from(o.maxFeePerGas)),o.maxPriorityFeePerGas!=null&&(s.maxPriorityFeePerGas=g.from(o.maxPriorityFeePerGas)),o.from!=null&&(s.from=o.from),o.type!=null&&(s.type=o.type),o.accessList!=null&&(s.accessList=ne(o.accessList)),s.gasLimit==null&&t.gas!=null){let d=21e3;const f=M(n);for(let v=0;v<f.length;v++)d+=4,f[v]&&(d+=64);s.gasLimit=g.from(t.gas).add(d)}if(o.value){const d=g.from(o.value);!d.isZero()&&!t.payable&&c.throwError("non-payable method cannot override value",h.errors.UNSUPPORTED_OPERATION,{operation:"overrides.value",value:i.value}),s.value=d}o.customData&&(s.customData=m(o.customData)),o.ccipReadEnabled&&(s.ccipReadEnabled=!!o.ccipReadEnabled),delete i.nonce,delete i.gasLimit,delete i.gasPrice,delete i.from,delete i.value,delete i.type,delete i.accessList,delete i.maxFeePerGas,delete i.maxPriorityFeePerGas,delete i.customData,delete i.ccipReadEnabled;const u=Object.keys(i).filter(d=>i[d]!=null);return u.length&&c.throwError(`cannot override ${u.map(d=>JSON.stringify(d)).join(",")}`,h.errors.UNSUPPORTED_OPERATION,{operation:"overrides",overrides:u}),s})}function ue(e,t){return function(...r){return R(e,t,r)}}function de(e,t){const r=e.signer||e.provider;return function(...i){return p(this,void 0,void 0,function*(){r||c.throwError("estimate require a provider or signer",h.errors.UNSUPPORTED_OPERATION,{operation:"estimateGas"});const a=yield R(e,t,i);return yield r.estimateGas(a)})}}function q(e,t){const r=t.wait.bind(t);t.wait=i=>r(i).then(a=>(a.events=a.logs.map(n=>{let s=k(n),o=null;try{o=e.interface.parseLog(n)}catch{}return o&&(s.args=o.args,s.decode=(u,d)=>e.interface.decodeEventLog(o.eventFragment,u,d),s.event=o.name,s.eventSignature=o.signature),s.removeListener=()=>e.provider,s.getBlock=()=>e.provider.getBlock(a.blockHash),s.getTransaction=()=>e.provider.getTransaction(a.transactionHash),s.getTransactionReceipt=()=>Promise.resolve(a),s}),a))}function z(e,t,r){const i=e.signer||e.provider;return function(...a){return p(this,void 0,void 0,function*(){let n;if(a.length===t.inputs.length+1&&typeof a[a.length-1]=="object"){const u=m(a.pop());u.blockTag!=null&&(n=yield u.blockTag),delete u.blockTag,a.push(u)}e.deployTransaction!=null&&(yield e._deployed(n));const s=yield R(e,t,a),o=yield i.call(s,n);try{let u=e.interface.decodeFunctionResult(t,o);return r&&t.outputs.length===1&&(u=u[0]),u}catch(u){throw u.code===h.errors.CALL_EXCEPTION&&(u.address=e.address,u.args=a,u.transaction=s),u}})}}function he(e,t){return function(...r){return p(this,void 0,void 0,function*(){e.signer||c.throwError("sending a transaction requires a signer",h.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction"}),e.deployTransaction!=null&&(yield e._deployed());const i=yield R(e,t,r),a=yield e.signer.sendTransaction(i);return q(e,a),a})}}function D(e,t,r){return t.constant?z(e,t,r):he(e,t)}function I(e){return e.address&&(e.topics==null||e.topics.length===0)?"*":(e.address||"*")+"@"+(e.topics?e.topics.map(t=>Array.isArray(t)?t.join("|"):t).join(":"):"")}var p,c,$,E,G,T,A,S,w,H,me=j({"../../node_modules/@ethersproject/contracts/lib.esm/index.js"(){te(),oe(),se(),B(),W(),Z(),Q(),ae(),K(),le(),p=function(e,t,r,i){function a(n){return n instanceof r?n:new r(function(s){s(n)})}return new(r||(r=Promise))(function(n,s){function o(f){try{d(i.next(f))}catch(v){s(v)}}function u(f){try{d(i.throw(f))}catch(v){s(v)}}function d(f){f.done?n(f.value):a(f.value).then(o,u)}d((i=i.apply(e,t||[])).next())})},c=new h(F),$={chainId:!0,data:!0,from:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0,type:!0,accessList:!0,maxFeePerGas:!0,maxPriorityFeePerGas:!0,customData:!0,ccipReadEnabled:!0},E=class{constructor(e,t){l(this,"tag",e),l(this,"filter",t),this._listeners=[]}addListener(e,t){this._listeners.push({listener:e,once:t})}removeListener(e){let t=!1;this._listeners=this._listeners.filter(r=>t||r.listener!==e?!0:(t=!0,!1))}removeAllListeners(){this._listeners=[]}listeners(){return this._listeners.map(e=>e.listener)}listenerCount(){return this._listeners.length}run(e){const t=this.listenerCount();return this._listeners=this._listeners.filter(r=>{const i=e.slice();return setTimeout(()=>{r.listener.apply(this,i)},0),!r.once}),t}prepareEvent(e){}getEmit(e){return[e]}},G=class extends E{constructor(){super("error",null)}},T=class extends E{constructor(e,t,r,i){const a={address:e};let n=t.getEventTopic(r);i?(n!==i[0]&&c.throwArgumentError("topic mismatch","topics",i),a.topics=i.slice()):a.topics=[n],super(I(a),a),l(this,"address",e),l(this,"interface",t),l(this,"fragment",r)}prepareEvent(e){super.prepareEvent(e),e.event=this.fragment.name,e.eventSignature=this.fragment.format(),e.decode=(t,r)=>this.interface.decodeEventLog(this.fragment,t,r);try{e.args=this.interface.decodeEventLog(this.fragment,e.data,e.topics)}catch(t){e.args=null,e.decodeError=t}}getEmit(e){const t=ee(e.args);if(t.length)throw t[0].error;const r=(e.args||[]).slice();return r.push(e),r}},A=class extends E{constructor(e,t){super("*",{address:e}),l(this,"address",e),l(this,"interface",t)}prepareEvent(e){super.prepareEvent(e);try{const t=this.interface.parseLog(e);e.event=t.name,e.eventSignature=t.signature,e.decode=(r,i)=>this.interface.decodeEventLog(t.eventFragment,r,i),e.args=t.args}catch{}}},S=class{constructor(e,t,r){l(this,"interface",_(new.target,"getInterface")(t)),r==null?(l(this,"provider",null),l(this,"signer",null)):U.isSigner(r)?(l(this,"provider",r.provider||null),l(this,"signer",r)):re.isProvider(r)?(l(this,"provider",r),l(this,"signer",null)):c.throwArgumentError("invalid signer or provider","signerOrProvider",r),l(this,"callStatic",{}),l(this,"estimateGas",{}),l(this,"functions",{}),l(this,"populateTransaction",{}),l(this,"filters",{});{const n={};Object.keys(this.interface.events).forEach(s=>{const o=this.interface.events[s];l(this.filters,s,(...u)=>({address:this.address,topics:this.interface.encodeFilterTopics(o,u)})),n[o.name]||(n[o.name]=[]),n[o.name].push(s)}),Object.keys(n).forEach(s=>{const o=n[s];o.length===1?l(this.filters,s,this.filters[o[0]]):c.warn(`Duplicate definition of ${s} (${o.join(", ")})`)})}if(l(this,"_runningEvents",{}),l(this,"_wrappedEmits",{}),e==null&&c.throwArgumentError("invalid contract address or ENS name","addressOrName",e),l(this,"address",e),this.provider)l(this,"resolvedAddress",b(this.provider,e));else try{l(this,"resolvedAddress",Promise.resolve(L(e)))}catch{c.throwError("provider is required to use ENS name as contract address",h.errors.UNSUPPORTED_OPERATION,{operation:"new Contract"})}this.resolvedAddress.catch(n=>{});const i={},a={};Object.keys(this.interface.functions).forEach(n=>{const s=this.interface.functions[n];if(a[n]){c.warn(`Duplicate ABI entry for ${JSON.stringify(n)}`);return}a[n]=!0;{const o=s.name;i[`%${o}`]||(i[`%${o}`]=[]),i[`%${o}`].push(n)}this[n]==null&&l(this,n,D(this,s,!0)),this.functions[n]==null&&l(this.functions,n,D(this,s,!1)),this.callStatic[n]==null&&l(this.callStatic,n,z(this,s,!0)),this.populateTransaction[n]==null&&l(this.populateTransaction,n,ue(this,s)),this.estimateGas[n]==null&&l(this.estimateGas,n,de(this,s))}),Object.keys(i).forEach(n=>{const s=i[n];if(s.length>1)return;n=n.substring(1);const o=s[0];try{this[n]==null&&l(this,n,this[o])}catch{}this.functions[n]==null&&l(this.functions,n,this.functions[o]),this.callStatic[n]==null&&l(this.callStatic,n,this.callStatic[o]),this.populateTransaction[n]==null&&l(this.populateTransaction,n,this.populateTransaction[o]),this.estimateGas[n]==null&&l(this.estimateGas,n,this.estimateGas[o])})}static getContractAddress(e){return x(e)}static getInterface(e){return O.isInterface(e)?e:new O(e)}deployed(){return this._deployed()}_deployed(e){return this._deployedPromise||(this.deployTransaction?this._deployedPromise=this.deployTransaction.wait().then(()=>this):this._deployedPromise=this.provider.getCode(this.address,e).then(t=>(t==="0x"&&c.throwError("contract not deployed",h.errors.UNSUPPORTED_OPERATION,{contractAddress:this.address,operation:"getDeployed"}),this))),this._deployedPromise}fallback(e){this.signer||c.throwError("sending a transactions require a signer",h.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction(fallback)"});const t=m(e||{});return["from","to"].forEach(function(r){t[r]!=null&&c.throwError("cannot override "+r,h.errors.UNSUPPORTED_OPERATION,{operation:r})}),t.to=this.resolvedAddress,this.deployed().then(()=>this.signer.sendTransaction(t))}connect(e){typeof e=="string"&&(e=new ie(e,this.provider));const t=new this.constructor(this.address,this.interface,e);return this.deployTransaction&&l(t,"deployTransaction",this.deployTransaction),t}attach(e){return new this.constructor(e,this.interface,this.signer||this.provider)}static isIndexed(e){return Y.isIndexed(e)}_normalizeRunningEvent(e){return this._runningEvents[e.tag]?this._runningEvents[e.tag]:e}_getRunningEvent(e){if(typeof e=="string"){if(e==="error")return this._normalizeRunningEvent(new G);if(e==="event")return this._normalizeRunningEvent(new E("event",null));if(e==="*")return this._normalizeRunningEvent(new A(this.address,this.interface));const t=this.interface.getEvent(e);return this._normalizeRunningEvent(new T(this.address,this.interface,t))}if(e.topics&&e.topics.length>0){try{const r=e.topics[0];if(typeof r!="string")throw new Error("invalid topic");const i=this.interface.getEvent(r);return this._normalizeRunningEvent(new T(this.address,this.interface,i,e.topics))}catch{}const t={address:this.address,topics:e.topics};return this._normalizeRunningEvent(new E(I(t),t))}return this._normalizeRunningEvent(new A(this.address,this.interface))}_checkRunningEvents(e){if(e.listenerCount()===0){delete this._runningEvents[e.tag];const t=this._wrappedEmits[e.tag];t&&e.filter&&(this.provider.off(e.filter,t),delete this._wrappedEmits[e.tag])}}_wrapEvent(e,t,r){const i=k(t);return i.removeListener=()=>{r&&(e.removeListener(r),this._checkRunningEvents(e))},i.getBlock=()=>this.provider.getBlock(t.blockHash),i.getTransaction=()=>this.provider.getTransaction(t.transactionHash),i.getTransactionReceipt=()=>this.provider.getTransactionReceipt(t.transactionHash),e.prepareEvent(i),i}_addEventListener(e,t,r){if(this.provider||c.throwError("events require a provider or a signer with a provider",h.errors.UNSUPPORTED_OPERATION,{operation:"once"}),e.addListener(t,r),this._runningEvents[e.tag]=e,!this._wrappedEmits[e.tag]){const i=a=>{let n=this._wrapEvent(e,a,t);if(n.decodeError==null)try{const s=e.getEmit(n);this.emit(e.filter,...s)}catch(s){n.decodeError=s.error}e.filter!=null&&this.emit("event",n),n.decodeError!=null&&this.emit("error",n.decodeError,n)};this._wrappedEmits[e.tag]=i,e.filter!=null&&this.provider.on(e.filter,i)}}queryFilter(e,t,r){const i=this._getRunningEvent(e),a=m(i.filter);return typeof t=="string"&&N(t,32)?(r!=null&&c.throwArgumentError("cannot specify toBlock with blockhash","toBlock",r),a.blockHash=t):(a.fromBlock=t??0,a.toBlock=r??"latest"),this.provider.getLogs(a).then(n=>n.map(s=>this._wrapEvent(i,s,null)))}on(e,t){return this._addEventListener(this._getRunningEvent(e),t,!1),this}once(e,t){return this._addEventListener(this._getRunningEvent(e),t,!0),this}emit(e,...t){if(!this.provider)return!1;const r=this._getRunningEvent(e),i=r.run(t)>0;return this._checkRunningEvents(r),i}listenerCount(e){return this.provider?e==null?Object.keys(this._runningEvents).reduce((t,r)=>t+this._runningEvents[r].listenerCount(),0):this._getRunningEvent(e).listenerCount():0}listeners(e){if(!this.provider)return[];if(e==null){const t=[];for(let r in this._runningEvents)this._runningEvents[r].listeners().forEach(i=>{t.push(i)});return t}return this._getRunningEvent(e).listeners()}removeAllListeners(e){if(!this.provider)return this;if(e==null){for(const r in this._runningEvents){const i=this._runningEvents[r];i.removeAllListeners(),this._checkRunningEvents(i)}return this}const t=this._getRunningEvent(e);return t.removeAllListeners(),this._checkRunningEvents(t),this}off(e,t){if(!this.provider)return this;const r=this._getRunningEvent(e);return r.removeListener(t),this._checkRunningEvents(r),this}removeListener(e,t){return this.off(e,t)}},w=class extends S{},H=class{constructor(e,t,r){let i=null;typeof t=="string"?i=t:X(t)?i=C(t):t&&typeof t.object=="string"?i=t.object:i="!",i.substring(0,2)!=="0x"&&(i="0x"+i),(!N(i)||i.length%2)&&c.throwArgumentError("invalid bytecode","bytecode",t),r&&!U.isSigner(r)&&c.throwArgumentError("invalid signer","signer",r),l(this,"bytecode",i),l(this,"interface",_(new.target,"getInterface")(e)),l(this,"signer",r||null)}getDeployTransaction(...e){let t={};if(e.length===this.interface.deploy.inputs.length+1&&typeof e[e.length-1]=="object"){t=m(e.pop());for(const r in t)if(!$[r])throw new Error("unknown transaction override "+r)}return["data","from","to"].forEach(r=>{t[r]!=null&&c.throwError("cannot override "+r,h.errors.UNSUPPORTED_OPERATION,{operation:r})}),t.value&&!g.from(t.value).isZero()&&!this.interface.deploy.payable&&c.throwError("non-payable constructor cannot override value",h.errors.UNSUPPORTED_OPERATION,{operation:"overrides.value",value:t.value}),c.checkArgumentCount(e.length,this.interface.deploy.inputs.length," in Contract constructor"),t.data=C(V([this.bytecode,this.interface.encodeDeploy(e)])),t}deploy(...e){return p(this,void 0,void 0,function*(){let t={};e.length===this.interface.deploy.inputs.length+1&&(t=e.pop()),c.checkArgumentCount(e.length,this.interface.deploy.inputs.length," in Contract constructor");const r=yield y(this.signer,e,this.interface.deploy.inputs);r.push(t);const i=this.getDeployTransaction(...r),a=yield this.signer.sendTransaction(i),n=_(this.constructor,"getContractAddress")(a),s=_(this.constructor,"getContract")(n,this.interface,this.signer);return q(s,a),l(s,"deployTransaction",a),s})}attach(e){return this.constructor.getContract(e,this.interface,this.signer)}connect(e){return new this.constructor(this.interface,this.bytecode,e)}static fromSolidity(e,t){e==null&&c.throwError("missing compiler output",h.errors.MISSING_ARGUMENT,{argument:"compilerOutput"}),typeof e=="string"&&(e=JSON.parse(e));const r=e.abi;let i=null;return e.bytecode?i=e.bytecode:e.evm&&e.evm.bytecode&&(i=e.evm.bytecode),new this(r,i,t)}static getInterface(e){return w.getInterface(e)}static getContractAddress(e){return x(e)}static getContract(e,t,r){return new w(e,t,r)}}}});export{S as BaseContract,w as Contract,H as ContractFactory,me as init_lib,ce as lib_exports};
