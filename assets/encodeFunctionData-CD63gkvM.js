import{BaseError as a,IntegerOutOfRangeError as M,InvalidAddressError as j,boolToHex as N,isAddress as y,isHex as T,keccak256 as D,numberToHex as h,padHex as u,size as d,stringToHex as k,toBytes as O}from"./isAddress-P2vaZgmG.js";import{concat as l,concatHex as L,slice as B}from"./slice-cfC6NcyN.js";function g(t,{includeName:e=!1}={}){if(t.type!=="function"&&t.type!=="event"&&t.type!=="error")throw new Y(t.type);return`${t.name}(${m(t.inputs,{includeName:e})})`}function m(t,{includeName:e=!1}={}){return t?t.map(n=>C(n,{includeName:e})).join(e?", ":","):""}function C(t,{includeName:e}){return t.type.startsWith("tuple")?`(${m(t.components,{includeName:e})})${t.type.slice(5)}`:t.type+(e&&t.name?` ${t.name}`:"")}var gt=class extends a{constructor({docsPath:t}){super(["A constructor was not found on the ABI.","Make sure you are using the correct ABI and that the constructor exists on it."].join(`
`),{docsPath:t,name:"AbiConstructorNotFoundError"})}},mt=class extends a{constructor({docsPath:t}){super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.","Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join(`
`),{docsPath:t,name:"AbiConstructorParamsNotFoundError"})}},bt=class extends a{constructor({data:t,params:e,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`),{metaMessages:[`Params: (${m(e,{includeName:!0})})`,`Data:   ${t} (${n} bytes)`],name:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t,this.params=e,this.size=n}},At=class extends a{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.',{name:"AbiDecodingZeroDataError"})}},R=class extends a{constructor({expectedLength:t,givenLength:e,type:n}){super([`ABI encoding array length mismatch for type ${n}.`,`Expected length: ${t}`,`Given length: ${e}`].join(`
`),{name:"AbiEncodingArrayLengthMismatchError"})}},H=class extends a{constructor({expectedSize:t,value:e}){super(`Size of bytes "${e}" (bytes${d(e)}) does not match expected size (bytes${t}).`,{name:"AbiEncodingBytesSizeMismatchError"})}},W=class extends a{constructor({expectedLength:t,givenLength:e}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${t}`,`Given length (values): ${e}`].join(`
`),{name:"AbiEncodingLengthMismatchError"})}},vt=class extends a{constructor(t,{docsPath:e}){super([`Arguments (\`args\`) were provided to "${t}", but "${t}" on the ABI does not contain any parameters (\`inputs\`).`,"Cannot encode error result without knowing what the parameter types are.","Make sure you are using the correct ABI and that the inputs exist on it."].join(`
`),{docsPath:e,name:"AbiErrorInputsNotFoundError"})}},$t=class extends a{constructor(t,{docsPath:e}={}){super([`Error ${t?`"${t}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it."].join(`
`),{docsPath:e,name:"AbiErrorNotFoundError"})}},Et=class extends a{constructor(t,{docsPath:e}){super([`Encoded error signature "${t}" not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`),{docsPath:e,name:"AbiErrorSignatureNotFoundError"}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.signature=t}},xt=class extends a{constructor({docsPath:t}){super("Cannot extract event signature from empty topics.",{docsPath:t,name:"AbiEventSignatureEmptyTopicsError"})}},wt=class extends a{constructor(t,{docsPath:e}){super([`Encoded event signature "${t}" not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`),{docsPath:e,name:"AbiEventSignatureNotFoundError"})}},Pt=class extends a{constructor(t,{docsPath:e}={}){super([`Event ${t?`"${t}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it."].join(`
`),{docsPath:e,name:"AbiEventNotFoundError"})}},x=class extends a{constructor(t,{docsPath:e}={}){super([`Function ${t?`"${t}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it."].join(`
`),{docsPath:e,name:"AbiFunctionNotFoundError"})}},Bt=class extends a{constructor(t,{docsPath:e}){super([`Function "${t}" does not contain any \`outputs\` on ABI.`,"Cannot decode function result without knowing what the parameter types are.","Make sure you are using the correct ABI and that the function exists on it."].join(`
`),{docsPath:e,name:"AbiFunctionOutputsNotFoundError"})}},It=class extends a{constructor(t,{docsPath:e}){super([`Encoded function signature "${t}" not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`),{docsPath:e,name:"AbiFunctionSignatureNotFoundError"})}},_=class extends a{constructor(t,e){super("Found ambiguous types in overloaded ABI items.",{metaMessages:[`\`${t.type}\` in \`${g(t.abiItem)}\`, and`,`\`${e.type}\` in \`${g(e.abiItem)}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."],name:"AbiItemAmbiguityError"})}},zt=class extends a{constructor({expectedSize:t,givenSize:e}){super(`Expected bytes${t}, got bytes${e}.`,{name:"BytesSizeMismatchError"})}},Ft=class extends a{constructor({abiItem:t,data:e,params:n,size:r}){super([`Data size of ${r} bytes is too small for non-indexed event parameters.`].join(`
`),{metaMessages:[`Params: (${m(n,{includeName:!0})})`,`Data:   ${e} (${r} bytes)`],name:"DecodeLogDataMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=t,this.data=e,this.params=n,this.size=r}},St=class extends a{constructor({abiItem:t,param:e}){super([`Expected a topic for indexed event parameter${e.name?` "${e.name}"`:""} on event "${g(t,{includeName:!0})}".`].join(`
`),{name:"DecodeLogTopicsMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=t}},q=class extends a{constructor(t,{docsPath:e}){super([`Type "${t}" is not a valid encoding type.`,"Please provide a valid ABI type."].join(`
`),{docsPath:e,name:"InvalidAbiEncodingType"})}},Mt=class extends a{constructor(t,{docsPath:e}){super([`Type "${t}" is not a valid decoding type.`,"Please provide a valid ABI type."].join(`
`),{docsPath:e,name:"InvalidAbiDecodingType"})}},V=class extends a{constructor(t){super([`Value "${t}" is not a valid array.`].join(`
`),{name:"InvalidArrayError"})}},Y=class extends a{constructor(t){super([`"${t}" is not a valid definition type.`,'Valid types: "function", "event", "error"'].join(`
`),{name:"InvalidDefinitionTypeError"})}};const G=t=>D(O(t));function U(t){return G(t)}function Z(t,e){const n=t.exec(e);return n==null?void 0:n.groups}const jt=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,Nt=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,Tt=/^\(.+?\).*?$/,w=/^tuple(?<array>(\[(\d*)\])*)$/;function b(t){let e=t.type;if(w.test(t.type)&&"components"in t){e="(";const n=t.components.length;for(let o=0;o<n;o++){const s=t.components[o];e+=b(s),o<n-1&&(e+=", ")}const r=Z(w,t.type);return e+=`)${(r==null?void 0:r.array)??""}`,b({...t,type:e})}return"indexed"in t&&t.indexed&&(e=`${e} indexed`),t.name?`${e} ${t.name}`:e}function f(t){let e="";const n=t.length;for(let r=0;r<n;r++){const o=t[r];e+=b(o),r!==n-1&&(e+=", ")}return e}function J(t){var e;return t.type==="function"?`function ${t.name}(${f(t.inputs)})${t.stateMutability&&t.stateMutability!=="nonpayable"?` ${t.stateMutability}`:""}${!((e=t.outputs)===null||e===void 0)&&e.length?` returns (${f(t.outputs)})`:""}`:t.type==="event"?`event ${t.name}(${f(t.inputs)})`:t.type==="error"?`error ${t.name}(${f(t.inputs)})`:t.type==="constructor"?`constructor(${f(t.inputs)})${t.stateMutability==="payable"?" payable":""}`:t.type==="fallback"?`fallback() external${t.stateMutability==="payable"?" payable":""}`:"receive() external payable"}function K(t){let e=!0,n="",r=0,o="",s=!1;for(let c=0;c<t.length;c++){const i=t[c];if(["(",")",","].includes(i)&&(e=!0),i==="("&&r++,i===")"&&r--,!!e){if(r===0){if(i===" "&&["event","function",""].includes(o))o="";else if(o+=i,i===")"){s=!0;break}continue}if(i===" "){t[c-1]!==","&&n!==","&&n!==",("&&(n="",e=!1);continue}o+=i,n+=i}}if(!s)throw new a("Unable to normalize signature.");return o}const Q=t=>{const e=typeof t=="string"?t:J(t);return K(e)};function I(t){return U(Q(t))}const z=t=>B(I(t),0,4),Dt=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,X=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function tt(t,e){if(t.length!==e.length)throw new W({expectedLength:t.length,givenLength:e.length});const n=et({params:t,values:e}),r=$(n);return r.length===0?"0x":r}function et({params:t,values:e}){const n=[];for(let r=0;r<t.length;r++)n.push(v({param:t[r],value:e[r]}));return n}function v({param:t,value:e}){const n=ut(t.type);if(n){const[r,o]=n;return rt(e,{length:r,param:{...t,type:o}})}if(t.type==="tuple")return at(e,{param:t});if(t.type==="address")return nt(e);if(t.type==="bool")return it(e);if(t.type.startsWith("uint")||t.type.startsWith("int")){const r=t.type.startsWith("int"),[,,o="256"]=X.exec(t.type)??[];return st(e,{signed:r,size:Number(o)})}if(t.type.startsWith("bytes"))return ot(e,{param:t});if(t.type==="string")return ct(e);throw new q(t.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function $(t){let e=0;for(let s=0;s<t.length;s++){const{dynamic:c,encoded:i}=t[s];c?e+=32:e+=d(i)}const n=[],r=[];let o=0;for(let s=0;s<t.length;s++){const{dynamic:c,encoded:i}=t[s];c?(n.push(h(e+o,{size:32})),r.push(i),o+=d(i)):n.push(i)}return l([...n,...r])}function nt(t){if(!y(t))throw new j({address:t});return{dynamic:!1,encoded:u(t.toLowerCase())}}function rt(t,{length:e,param:n}){const r=e===null;if(!Array.isArray(t))throw new V(t);if(!r&&t.length!==e)throw new R({expectedLength:e,givenLength:t.length,type:`${n.type}[${e}]`});let o=!1;const s=[];for(let c=0;c<t.length;c++){const i=v({param:n,value:t[c]});i.dynamic&&(o=!0),s.push(i)}if(r||o){const c=$(s);if(r){const i=h(s.length,{size:32});return{dynamic:!0,encoded:s.length>0?l([i,c]):i}}if(o)return{dynamic:!0,encoded:c}}return{dynamic:!1,encoded:l(s.map(({encoded:c})=>c))}}function ot(t,{param:e}){const[,n]=e.type.split("bytes"),r=d(t);if(!n){let o=t;return r%32!==0&&(o=u(o,{dir:"right",size:Math.ceil((t.length-2)/2/32)*32})),{dynamic:!0,encoded:l([u(h(r,{size:32})),o])}}if(r!==Number.parseInt(n))throw new H({expectedSize:Number.parseInt(n),value:t});return{dynamic:!1,encoded:u(t,{dir:"right"})}}function it(t){if(typeof t!="boolean")throw new a(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:u(N(t))}}function st(t,{signed:e,size:n=256}){if(typeof n=="number"){const r=2n**(BigInt(n)-(e?1n:0n))-1n,o=e?-r-1n:0n;if(t>r||t<o)throw new M({max:r.toString(),min:o.toString(),signed:e,size:n/8,value:t.toString()})}return{dynamic:!1,encoded:h(t,{size:32,signed:e})}}function ct(t){const e=k(t),n=Math.ceil(d(e)/32),r=[];for(let o=0;o<n;o++)r.push(u(B(e,o*32,(o+1)*32),{dir:"right"}));return{dynamic:!0,encoded:l([u(h(d(e),{size:32})),...r])}}function at(t,{param:e}){let n=!1;const r=[];for(let o=0;o<e.components.length;o++){const s=e.components[o],c=Array.isArray(t)?o:s.name,i=v({param:s,value:t[c]});r.push(i),i.dynamic&&(n=!0)}return{dynamic:n,encoded:n?$(r):l(r.map(({encoded:o})=>o))}}function ut(t){const e=t.match(/^(.*)\[(\d+)?\]$/);return e?[e[2]?Number(e[2]):null,e[1]]:void 0}const dt=I;function lt(t){const{abi:e,args:n=[],name:r}=t,o=T(r,{strict:!1}),s=e.filter(i=>o?i.type==="function"?z(i)===r:i.type==="event"?dt(i)===r:!1:"name"in i&&i.name===r);if(s.length===0)return;if(s.length===1)return s[0];let c;for(const i of s){if(!("inputs"in i))continue;if(!n||n.length===0){if(!i.inputs||i.inputs.length===0)return i;continue}if(!i.inputs||i.inputs.length===0||i.inputs.length!==n.length)continue;if(n.every((p,S)=>{const E="inputs"in i&&i.inputs[S];return E?A(p,E):!1})){if(c&&"inputs"in c&&c.inputs){const p=F(i.inputs,c.inputs,n);if(p)throw new _({abiItem:i,type:p[0]},{abiItem:c,type:p[1]})}c=i}}return c||s[0]}function A(t,e){const n=typeof t,r=e.type;switch(r){case"address":return y(t,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return r==="tuple"&&"components"in e?Object.values(e.components).every((o,s)=>A(Object.values(t)[s],o)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)?n==="string"||t instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)?Array.isArray(t)&&t.every(o=>A(o,{...e,type:r.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function F(t,e,n){for(const r in t){const o=t[r],s=e[r];if(o.type==="tuple"&&s.type==="tuple"&&"components"in o&&"components"in s)return F(o.components,s.components,n[r]);const c=[o.type,s.type];if(c.includes("address")&&c.includes("bytes20")?!0:c.includes("address")&&c.includes("string")?y(n[r],{strict:!1}):c.includes("address")&&c.includes("bytes")?y(n[r],{strict:!1}):!1)return c}}const P="/docs/contract/encodeFunctionData";function pt(t){const{abi:e,args:n,functionName:r}=t;let o=e[0];if(r){const s=lt({abi:e,args:n,name:r});if(!s)throw new x(r,{docsPath:P});o=s}if(o.type!=="function")throw new x(void 0,{docsPath:P});return{abi:[o],functionName:z(g(o))}}function kt(t){const{args:e}=t,{abi:n,functionName:r}=(()=>{var i;return t.abi.length===1&&(!((i=t.functionName)===null||i===void 0)&&i.startsWith("0x"))?t:pt(t)})(),o=n[0],s=r,c="inputs"in o&&o.inputs?tt(o.inputs,e??[]):void 0;return L([s,c??"0x"])}export{gt as AbiConstructorNotFoundError,mt as AbiConstructorParamsNotFoundError,bt as AbiDecodingDataSizeTooSmallError,At as AbiDecodingZeroDataError,vt as AbiErrorInputsNotFoundError,$t as AbiErrorNotFoundError,Et as AbiErrorSignatureNotFoundError,Pt as AbiEventNotFoundError,xt as AbiEventSignatureEmptyTopicsError,wt as AbiEventSignatureNotFoundError,x as AbiFunctionNotFoundError,Bt as AbiFunctionOutputsNotFoundError,It as AbiFunctionSignatureNotFoundError,zt as BytesSizeMismatchError,Ft as DecodeLogDataMismatch,St as DecodeLogTopicsMismatch,Mt as InvalidAbiDecodingTypeError,V as InvalidArrayError,Dt as bytesRegex,jt as bytesRegex$1,tt as encodeAbiParameters,kt as encodeFunctionData,Z as execTyped,J as formatAbiItem,g as formatAbiItem$1,lt as getAbiItem,ut as getArrayComponents,X as integerRegex,Nt as integerRegex$1,Tt as isTupleRegex,dt as toEventSelector,z as toFunctionSelector};
