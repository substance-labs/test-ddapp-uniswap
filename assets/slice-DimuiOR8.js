import{__toESM as C}from"./chunk-DgAfPHQg.js";import{require_react as y}from"./react-CNoFhWkx.js";import{require_jsx_runtime as I}from"./jsx-runtime-D7bMTQeG.js";import{logger as u}from"./hooks-BXO4d1DJ.js";import{createSlice as E}from"./redux-toolkit.esm-BnRUBto_.js";import{Ether as S,UniverseChainId as g,init_sdk_core_esm as T}from"./utils-BX1Fu73x.js";import{currencyId as F}from"./currencyId-Ci6selsx.js";import{ENS_SUFFIX as x}from"./constants-vVZBLDwL.js";import{UNITAG_SUBDOMAIN as N,UNITAG_SUFFIX as w}from"./constants-CZ9iND_H.js";import{WBTC as P}from"./objects-DlLkJwrJ.js";import{Flex as b}from"./Loader-D83W8G1W.js";let n=(function(e){return e[e.ENSAddress=0]="ENSAddress",e[e.Token=1]="Token",e[e.Etherscan=2]="Etherscan",e[e.NFTCollection=3]="NFTCollection",e[e.Unitag=4]="Unitag",e[e.WalletByAddress=5]="WalletByAddress",e[e.Pool=6]="Pool",e})({});function $(e){return e.type===n.Token}function U(e){return e.type===n.Pool}function ee(e){return e.type===n.NFTCollection}function te(e){return e.type===n.Etherscan}function re(e){return e.type===n.WalletByAddress||e.type===n.ENSAddress||e.type===n.Unitag}function oe(e,t){const r=e.indexOf(".");if(r===-1||r===e.length-1)return t===n.Unitag?w:x;const o=e.substring(r);return o===N?w:o}const H=5;function B(e){const{type:t}=e,r=U(e)?e.poolId:e.address,o=(r==null?void 0:r.toLowerCase())??null;switch(t){case n.Token:return`token-${e.chainId}-${o}`;case n.ENSAddress:return`ens-${o}`;case n.Unitag:return`unitag-${o}`;case n.WalletByAddress:return`wallet-${o}`;case n.Etherscan:return`etherscan-${o}`;case n.NFTCollection:return`nftCollection-${e.chainId}-${o}`;case n.Pool:return`pool-${e.chainId}-${o}-${e.feeTier}`}}const L={results:[]},W=E({name:"searchHistory",initialState:L,reducers:{addToSearchHistory:(e,t)=>{const{searchResult:r}=t.payload,o=B(r);e.results.unshift({...r,searchId:o}),e.results=e.results.filter((s,i,c)=>i===c.findIndex(d=>d.searchId===s.searchId)).slice(0,H)},clearSearchHistory:e=>{e.results=[]}}}),{addToSearchHistory:ne,clearSearchHistory:se}=W.actions,{reducer:ie}=W;var a=C(y()),k=C(I());function O(){const e=(0,a.createContext)(void 0);function t({children:s,fetch:i,query:c,stale:d}){const[m,v]=(0,a.useState)(0),[l,f]=(0,a.useState)(!0);(0,a.useEffect)(()=>{d&&f(!0)},[d]),(0,a.useEffect)(()=>{l&&m&&(i(),f(!1))},[m,i,l]);const A=(0,a.useCallback)(()=>(v(h=>h+1),()=>v(h=>h-1)),[]),p=(0,a.useCallback)(()=>{l&&(i(),f(!1))},[i,l]);return(0,k.jsx)(e.Provider,{value:(0,a.useMemo)(()=>({query:c,refetch:p,subscribe:A}),[p,c,A]),children:s})}function r(s){const i=(0,a.useContext)(e);if(!i)throw new Error("useAdaptiveRefetchQuery must be used within an AdaptiveRefetchProvider");const{subscribe:c}=i;return(0,a.useEffect)(()=>{if((s==null?void 0:s.cacheOnly)!==!0)return c()},[s==null?void 0:s.cacheOnly,c]),i.query}function o({children:s,className:i}){const c=(0,a.useContext)(e);if(!c)throw new Error("PrefetchWrapper must be used within an AdaptiveRefetchProvider");const{refetch:d}=c;return(0,k.jsx)(b,{className:i,onMouseEnter:d,children:s})}return{Provider:t,PrefetchWrapper:o,useQuery:r}}const{Provider:ae,useQuery:ce,PrefetchWrapper:de}=O();T();const M=F(P).toLowerCase(),j=F(S.onChain(g.Mainnet)).toLowerCase(),D={tokens:[j,M],watchedAddresses:[]},_=E({name:"favorites",initialState:D,reducers:{addFavoriteToken:(e,{payload:{currencyId:t}})=>{e.tokens.indexOf(t)===-1?e.tokens.push(t.toLowerCase()):u.warn("slice","addFavoriteToken",`Attempting to favorite a token twice (${t})`)},removeFavoriteToken:(e,{payload:{currencyId:t}})=>{const r=e.tokens.filter(o=>o.toLocaleLowerCase()!==t.toLocaleLowerCase());r.length===e.tokens.length&&u.warn("slice","removeFavoriteToken",`Attempting to un-favorite a token that was not in favorites (${t})`),e.tokens=r},setFavoriteTokens:(e,{payload:{currencyIds:t}})=>{e.tokens=t},addWatchedAddress:(e,{payload:{address:t}})=>{e.watchedAddresses.includes(t)?u.warn("slice","addWatchedAddress",`Attempting to watch an address twice (${t})`):e.watchedAddresses.push(t)},removeWatchedAddress:(e,{payload:{address:t}})=>{const r=e.watchedAddresses.filter(o=>o!==t);r.length===e.watchedAddresses.length&&u.warn("slice","removeWatchedAddress",`Attempting to remove an address not found in watched list (${t})`),e.watchedAddresses=r},setFavoriteWallets:(e,{payload:{addresses:t}})=>{e.watchedAddresses=t}}}),{addFavoriteToken:le,removeFavoriteToken:ue,setFavoriteTokens:fe,addWatchedAddress:he,removeWatchedAddress:me,setFavoriteWallets:ve}=_.actions,{reducer:Ae}=_;export{ae as AdaptiveTokenBalancesProvider,de as PrefetchBalancesWrapper,n as SearchResultType,le as addFavoriteToken,ne as addToSearchHistory,he as addWatchedAddress,se as clearSearchHistory,O as createAdaptiveRefetchContext,oe as extractDomain,Ae as favoritesReducer,te as isEtherscanSearchResult,ee as isNFTCollectionSearchResult,U as isPoolSearchResult,$ as isTokenSearchResult,re as isWalletSearchResult,ue as removeFavoriteToken,me as removeWatchedAddress,ie as searchHistoryReducer,B as searchResultId,ce as useTokenBalancesQuery};
