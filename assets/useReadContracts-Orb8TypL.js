import{__toESM as p}from"./chunk-DgAfPHQg.js";import{require_react as b}from"./react-CNoFhWkx.js";import{ContractFunctionExecutionError as I}from"./call-CTDbaN-t.js";import{multicall as v}from"./multicall-BYS6jvE9.js";import{getAction as C}from"./getAction-BBhbL9mE.js";import{useChainId as y,useConfig as g}from"./useAccount-C5hwiBwN.js";import{readContract as w}from"./wagmi-CsUiFCSO.js";import{filterQueryOptions as S,structuralSharing as x,useQuery as F}from"./query-qNZtVuxH.js";async function O(t,o){const{allowFailure:r=!0,chainId:c,contracts:a,...i}=o,m=t.getClient({chainId:c});return C(m,v,"multicall")({allowFailure:r,contracts:a,...i})}async function Q(t,o){const{allowFailure:r=!0,blockNumber:c,blockTag:a,...i}=o,m=o.contracts;try{const n={};for(const[u,f]of m.entries()){var s;const d=f.chainId??t.state.chainId;n[d]||(n[d]=[]),(s=n[d])===null||s===void 0||s.push({contract:f,index:u})}const l=()=>Object.entries(n).map(([u,f])=>O(t,{...i,allowFailure:r,blockNumber:c,blockTag:a,chainId:Number.parseInt(u),contracts:f.map(({contract:d})=>d)})),e=(await Promise.all(l())).flat(),h=Object.values(n).flatMap(u=>u.map(({index:f})=>f));return e.reduce((u,f,d)=>(u&&(u[h[d]]=f),u),[])}catch(n){if(n instanceof I)throw n;const l=()=>m.map(e=>w(t,{...e,blockNumber:c,blockTag:a}));return r?(await Promise.allSettled(l())).map(e=>e.status==="fulfilled"?{result:e.value,status:"success"}:{error:e.reason,result:void 0,status:"failure"}):await Promise.all(l())}}function k(t,o={}){return{async queryFn({queryKey:r}){const c=[],a=r[1].contracts.length;for(let n=0;n<a;n++){var i;const l=r[1].contracts[n],e=((i=o.contracts)===null||i===void 0?void 0:i[n]).abi;c.push({...l,abi:e})}const{scopeKey:m,...s}=r[1];return Q(t,{...s,contracts:c})},queryKey:E(o)}}function E(t={}){const o=[];for(const r of t.contracts??[]){const{abi:c,...a}=r;o.push({...a,chainId:a.chainId??t.chainId})}return["readContracts",S({...t,contracts:o})]}var M=p(b());function T(t={}){const{contracts:o=[],query:r={}}=t,c=g(t),a=y({config:c}),i=k(c,{...t,chainId:a}),m=(0,M.useMemo)(()=>{let s=!1;for(const n of o){const{abi:l,address:e,functionName:h}=n;if(!l||!e||!h){s=!1;break}s=!0}return!!(s&&(r.enabled??!0))},[o,r.enabled]);return F({...i,...r,enabled:m,structuralSharing:r.structuralSharing??x})}export{Q as readContracts,T as useReadContracts};
