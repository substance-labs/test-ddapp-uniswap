import{logger as m}from"./hooks-BXO4d1DJ.js";import{ALL_EVM_CHAIN_IDS as d,getChainInfo as v}from"./utils-BX1Fu73x.js";import{StaticJsonRpcProvider as h,init_lib as b}from"./lib-Dj-AwQVD.js";import{AVERAGE_L1_BLOCK_TIME_MS as l}from"./usePollingIntervalByChain-YBOfXXzb.js";var c=(function(o){function t(e){"@babel/helpers - typeof";return t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(r){return typeof r}:function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},t(e)}function i(e,r){if(t(e)!="object"||!e)return e;var s=e[Symbol.toPrimitive];if(s!==void 0){var a=s.call(e,r||"default");if(t(a)!="object")return a;throw TypeError("@@toPrimitive must return a primitive value.")}return(r==="string"?String:Number)(e)}function n(e){var r=i(e,"string");return t(r)=="symbol"?r:r+""}function f(e,r,s){return(r=n(r))in e?Object.defineProperty(e,r,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[r]=s,e}return o.defineProperty=f,o})({});b();var p=class extends h{constructor({url:o,networkish:t,pollingInterval:i=l}){super(o,t),this.pollingInterval=i}},y=class{constructor(o){c.defineProperty(this,"isEnabled",!0),c.defineProperty(this,"timeout",void 0),c.defineProperty(this,"exponentialBackoffFactor",1),this.minimumBackoffTime=o}reset(){this.isEnabled=!0,clearTimeout(this.timeout),this.timeout=void 0}onSuccess(){this.reset(),this.exponentialBackoffFactor=1}onError(){this.isEnabled=!1,this.timeout||(this.timeout=setTimeout(()=>{this.reset(),this.exponentialBackoffFactor*=2},this.minimumBackoffTime*this.exponentialBackoffFactor))}get enabled(){return this.isEnabled}},P=class u extends p{constructor(t,{minimumBackoffTime:i=l}={}){if(t.length===0)throw new Error("Missing providers for AppJsonRpcProvider");super({networkish:t[0].network}),c.defineProperty(this,"providers",void 0),this.providers=t.map(n=>({provider:n,controller:new y(i)}))}async perform(t,i){const n=u.sortProviders(this.providers);for(const{provider:f,controller:e}of n)try{const r=await f.perform(t,i);return e.onSuccess(),r}catch(r){m.warn("AppJsonRpcProvider","perform","rpc action failed",r),e.onError()}throw new Error(`All providers failed to perform the operation: ${t}`)}static sortProviders(t){return[...t].sort(({controller:{enabled:i}},{controller:{enabled:n}})=>i&&!n?-1:!i&&n?1:0)}};function E(o){const t=v(o);return new P(t.rpcUrls.interface.http.map(i=>new p({url:i,networkish:{chainId:o,name:t.interfaceName}})))}const R=Object.fromEntries(d.map(o=>[o,E(o)]));export{R as RPC_PROVIDERS};
