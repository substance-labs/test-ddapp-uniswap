import{__commonJS as U}from"./chunk-DgAfPHQg.js";import{require__u64 as j,require_utils as q}from"./_u64-XHsHocZf.js";var J=U({"../../node_modules/@noble/hashes/sha3.js"(o){Object.defineProperty(o,"__esModule",{value:!0}),o.shake256=o.shake128=o.keccak_512=o.keccak_384=o.keccak_256=o.keccak_224=o.sha3_512=o.sha3_384=o.sha3_256=o.sha3_224=o.Keccak=void 0,o.keccakP=L;const l=j(),a=q(),m=BigInt(0),k=BigInt(1),S=BigInt(2),T=BigInt(7),F=BigInt(256),X=BigInt(113),w=[],y=[],b=[];for(let n=0,t=k,s=1,i=0;n<24;n++){[s,i]=[i,(2*s+3*i)%5],w.push(2*(5*i+s)),y.push((n+1)*(n+2)/2%64);let c=m;for(let h=0;h<7;h++)t=(t<<k^(t>>T)*X)%F,t&S&&(c^=k<<(k<<BigInt(h))-k);b.push(c)}const g=(0,l.split)(b,!0),v=g[0],E=g[1],B=(n,t,s)=>s>32?(0,l.rotlBH)(n,t,s):(0,l.rotlSH)(n,t,s),p=(n,t,s)=>s>32?(0,l.rotlBL)(n,t,s):(0,l.rotlSL)(n,t,s);function L(n,t=24){const s=new Uint32Array(10);for(let i=24-t;i<24;i++){for(let e=0;e<10;e++)s[e]=n[e]^n[e+10]^n[e+20]^n[e+30]^n[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,_=(e+2)%10,d=s[_],f=s[_+1],P=B(d,f,1)^s[r],K=p(d,f,1)^s[r+1];for(let I=0;I<50;I+=10)n[e+I]^=P,n[e+I+1]^=K}let c=n[2],h=n[3];for(let e=0;e<24;e++){const r=y[e],_=B(c,h,r),d=p(c,h,r),f=w[e];c=n[f],h=n[f+1],n[f]=_,n[f+1]=d}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)s[r]=n[e+r];for(let r=0;r<10;r++)n[e+r]^=~s[(r+2)%10]&s[(r+4)%10]}n[0]^=v[i],n[1]^=E[i]}(0,a.clean)(s)}var O=class H extends a.Hash{constructor(t,s,i,c=!1,h=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=s,this.outputLen=i,this.enableXOF=c,this.rounds=h,(0,a.anumber)(i),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,a.u32)(this.state)}clone(){return this._cloneInto()}keccak(){(0,a.swap32IfBE)(this.state32),L(this.state32,this.rounds),(0,a.swap32IfBE)(this.state32),this.posOut=0,this.pos=0}update(t){(0,a.aexists)(this),t=(0,a.toBytes)(t),(0,a.abytes)(t);const{blockLen:s,state:i}=this,c=t.length;for(let h=0;h<c;){const e=Math.min(s-this.pos,c-h);for(let r=0;r<e;r++)i[this.pos++]^=t[h++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:i,blockLen:c}=this;t[i]^=s,(s&128)!==0&&i===c-1&&this.keccak(),t[c-1]^=128,this.keccak()}writeInto(t){(0,a.aexists)(this,!1),(0,a.abytes)(t),this.finish();const s=this.state,{blockLen:i}=this;for(let c=0,h=t.length;c<h;){this.posOut>=i&&this.keccak();const e=Math.min(i-this.posOut,h-c);t.set(s.subarray(this.posOut,this.posOut+e),c),this.posOut+=e,c+=e}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,a.anumber)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,a.aoutput)(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,a.clean)(this.state)}_cloneInto(t){const{blockLen:s,suffix:i,outputLen:c,rounds:h,enableXOF:e}=this;return t||(t=new H(s,i,c,e,h)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=h,t.suffix=i,t.outputLen=c,t.enableXOF=e,t.destroyed=this.destroyed,t}};o.Keccak=O;const u=(n,t,s)=>(0,a.createHasher)(()=>new O(t,n,s));o.sha3_224=u(6,144,224/8),o.sha3_256=u(6,136,256/8),o.sha3_384=u(6,104,384/8),o.sha3_512=u(6,72,512/8),o.keccak_224=u(1,144,224/8),o.keccak_256=u(1,136,256/8),o.keccak_384=u(1,104,384/8),o.keccak_512=u(1,72,512/8);const A=(n,t,s)=>(0,a.createXOFer)((i={})=>new O(t,n,i.dkLen===void 0?s:i.dkLen,!0));o.shake128=A(31,168,128/8),o.shake256=A(31,136,256/8)}});export{J as require_sha3};
