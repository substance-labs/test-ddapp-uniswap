import{__toESM as Se}from"./chunk-DgAfPHQg.js";import{require_react as ve}from"./react-CNoFhWkx.js";import{ReactQueryCacheKey as Ce}from"./cache-BFZkIToX.js";import{useEnabledChains as Ee}from"./useEnabledChains-DuB86c95.js";import{logger as _e}from"./hooks-BXO4d1DJ.js";import{ApolloError as be,UniverseChainId as C,fromGraphQLChain as Ae,useTokenProjectsQuery as ke}from"./utils-BX1Fu73x.js";import{BRIDGED_BASE_ADDRESSES as xe,areAddressesEqual as oe,buildNativeCurrencyId as R,buildWrappedNativeCurrencyId as Te,currencyId as P}from"./currencyId-Ci6selsx.js";import{MAX_REACT_QUERY_CACHE_TIME_MS as ce}from"./time-D_OqcZ4M.js";import{skipToken as we,useQuery as Be,useQueryClient as Re}from"./useQuery-D_ZCw8XG.js";import{USDC as Ne,USDT as Pe,WBTC as Le}from"./objects-DlLkJwrJ.js";import{fetchSwappableTokens as Oe,getTokenAddressFromChainForTradingApi as Fe,toTradingApiSupportedChainId as $e}from"./TradingApiClient-Cp_0ez5S.js";import{usePersistedError as De,usePortfolioBalances as je}from"./balances-DV0Wvmri.js";import{buildCurrency as Ke,buildCurrencyInfo as We,currencyIdToContractInput as Qe,getCurrencySafetyInfo as Ue}from"./getCurrencySafetyInfo-BHD1ohD-.js";import{uniswapUrls as ze}from"./urls-kwiZbYPW.js";import{COMMON_BASES as Ge}from"./useCurrencyInfo-Bxa3J04d.js";var m=Se(ve());function lr({params:e,...t}){const r=V(e);return Be({queryKey:r,queryFn:e?ie(e):we,gcTime:ce,...t})}function ur({queryClient:e,params:t}){return e.getQueryData(V(t))}function hr(e){const t=Re();(0,m.useEffect)(()=>{(async()=>{const s=e!=null&&e.address?Fe(e.address,e.chainId):void 0,n=$e(e==null?void 0:e.chainId);!s||!n||await t.prefetchQuery({queryKey:V({tokenIn:s,tokenInChainId:n}),queryFn:ie({tokenIn:s,tokenInChainId:n}),gcTime:ce})})().catch(s=>{_e.error(s,{tags:{file:"useTradingApiSwappableTokensQuery",function:"prefetchSwappableTokens"}})})},[e,t])}const V=e=>[Ce.TradingApi,ze.tradingApiPaths.swappableTokens,e],ie=e=>async()=>await Oe(e);function He(e,t){return e==null?void 0:e.flatMap(r=>r==null?void 0:r.tokens.map(s=>{const{logoUrl:n,safetyLevel:o}=r,{name:c,chain:i,address:l,decimals:a,symbol:u,feeData:h,protectionInfo:f}=s,g=Ae(i);if(t&&t!==g)return null;const p=Ke({chainId:g,address:l,decimals:a,symbol:u,name:c,buyFeeBps:h==null?void 0:h.buyFeeBps,sellFeeBps:h==null?void 0:h.sellFeeBps});return p?We({currency:p,currencyId:P(p),logoUrl:n,safetyInfo:Ue(o,f)}):null})).filter(Boolean)}function Ye(e){const t=(0,m.useMemo)(()=>e.map(l=>Qe(l)),[e]),{data:r,loading:s,error:n,refetch:o}=ke({variables:{contracts:t},skip:e.length===0}),c=(0,m.useMemo)(()=>{if(!(!r||!r.tokenProjects))return He(r.tokenProjects)},[r]),i=(0,m.useCallback)(()=>o({contracts:t}),[t,o]);return(0,m.useMemo)(()=>({data:c,loading:s,refetch:i,error:n}),[c,s,i,n])}function _(e){return Array.isArray?Array.isArray(e):ue(e)==="[object Array]"}const Ve=1/0;function Je(e){if(typeof e=="string")return e;let t=e+"";return t=="0"&&1/e==-Ve?"-0":t}function Xe(e){return e==null?"":Je(e)}function E(e){return typeof e=="string"}function ae(e){return typeof e=="number"}function Ze(e){return e===!0||e===!1||qe(e)&&ue(e)=="[object Boolean]"}function le(e){return typeof e=="object"}function qe(e){return le(e)&&e!==null}function M(e){return e!=null}function W(e){return!e.trim().length}function ue(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const et="Incorrect 'index' type",tt=e=>`Invalid value for key ${e}`,rt=e=>`Pattern length exceeds max of ${e}.`,nt=e=>`Missing ${e} property in key`,st=e=>`Property 'weight' in key '${e}' must be a positive integer`,ee=Object.prototype.hasOwnProperty;var ot=class{constructor(e){this._keys=[],this._keyMap={};let t=0;e.forEach(r=>{let s=he(r);t+=s.weight,this._keys.push(s),this._keyMap[s.id]=s,t+=s.weight}),this._keys.forEach(r=>{r.weight/=t})}get(e){return this._keyMap[e]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}};function he(e){let t=null,r=null,s=null,n=1;if(E(e)||_(e))s=e,t=te(e),r=Q(e);else{if(!ee.call(e,"name"))throw new Error(nt("name"));const o=e.name;if(s=o,ee.call(e,"weight")&&(n=e.weight,n<=0))throw new Error(st(o));t=te(o),r=Q(o)}return{path:t,id:r,weight:n,src:s}}function te(e){return _(e)?e:e.split(".")}function Q(e){return _(e)?e.join("."):e}function ct(e,t){let r=[],s=!1;const n=(o,c,i)=>{if(M(o))if(!c[i])r.push(o);else{let l=c[i];const a=o[l];if(!M(a))return;if(i===c.length-1&&(E(a)||ae(a)||Ze(a)))r.push(Xe(a));else if(_(a)){s=!0;for(let u=0,h=a.length;u<h;u+=1)n(a[u],c,i+1)}else c.length&&n(a,c,i+1)}};return n(e,E(t)?t.split("."):t,0),s?r:r[0]}const it={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},at={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1},lt={location:0,threshold:.6,distance:100},ut={useExtendedSearch:!1,getFn:ct,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var d={...at,...it,...lt,...ut};const ht=/[^ ]+/g;function dt(e=1,t=3){const r=new Map,s=Math.pow(10,t);return{get(n){const o=n.match(ht).length;if(r.has(o))return r.get(o);const c=1/Math.pow(o,.5*e),i=parseFloat(Math.round(c*s)/s);return r.set(o,i),i},clear(){r.clear()}}}var J=class{constructor({getFn:e=d.getFn,fieldNormWeight:t=d.fieldNormWeight}={}){this.norm=dt(t,3),this.getFn=e,this.isCreated=!1,this.setIndexRecords()}setSources(e=[]){this.docs=e}setIndexRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e,this._keysMap={},e.forEach((t,r)=>{this._keysMap[t.id]=r})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,E(this.docs[0])?this.docs.forEach((e,t)=>{this._addString(e,t)}):this.docs.forEach((e,t)=>{this._addObject(e,t)}),this.norm.clear())}add(e){const t=this.size();E(e)?this._addString(e,t):this._addObject(e,t)}removeAt(e){this.records.splice(e,1);for(let t=e,r=this.size();t<r;t+=1)this.records[t].i-=1}getValueForItemAtKeyId(e,t){return e[this._keysMap[t]]}size(){return this.records.length}_addString(e,t){if(!M(e)||W(e))return;let r={v:e,i:t,n:this.norm.get(e)};this.records.push(r)}_addObject(e,t){let r={i:t,$:{}};this.keys.forEach((s,n)=>{let o=this.getFn(e,s.path);if(M(o)){if(_(o)){let c=[];const i=[{nestedArrIndex:-1,value:o}];for(;i.length;){const{nestedArrIndex:l,value:a}=i.pop();if(M(a))if(E(a)&&!W(a)){let u={v:a,i:l,n:this.norm.get(a)};c.push(u)}else _(a)&&a.forEach((u,h)=>{i.push({nestedArrIndex:h,value:u})})}r.$[n]=c}else if(!W(o)){let c={v:o,n:this.norm.get(o)};r.$[n]=c}}}),this.records.push(r)}toJSON(){return{keys:this.keys,records:this.records}}};function de(e,t,{getFn:r=d.getFn,fieldNormWeight:s=d.fieldNormWeight}={}){const n=new J({getFn:r,fieldNormWeight:s});return n.setKeys(e.map(he)),n.setSources(t),n.create(),n}function ft(e,{getFn:t=d.getFn,fieldNormWeight:r=d.fieldNormWeight}={}){const{keys:s,records:n}=e,o=new J({getFn:t,fieldNormWeight:r});return o.setKeys(s),o.setIndexRecords(n),o}function $(e,{errors:t=0,currentLocation:r=0,expectedLocation:s=0,distance:n=d.distance,ignoreLocation:o=d.ignoreLocation}={}){const c=t/e.length;if(o)return c;const i=Math.abs(s-r);return n?c+i/n:i?1:c}function gt(e=[],t=d.minMatchCharLength){let r=[],s=-1,n=-1,o=0;for(let c=e.length;o<c;o+=1){let i=e[o];i&&s===-1?s=o:!i&&s!==-1&&(n=o-1,n-s+1>=t&&r.push([s,n]),s=-1)}return e[o-1]&&o-s>=t&&r.push([s,o-1]),r}const T=32;function pt(e,t,r,{location:s=d.location,distance:n=d.distance,threshold:o=d.threshold,findAllMatches:c=d.findAllMatches,minMatchCharLength:i=d.minMatchCharLength,includeMatches:l=d.includeMatches,ignoreLocation:a=d.ignoreLocation}={}){if(t.length>T)throw new Error(rt(T));const u=t.length,h=e.length,f=Math.max(0,Math.min(s,h));let g=o,p=f;const I=i>1||l,y=I?Array(h):[];let w;for(;(w=e.indexOf(t,p))>-1;){let S=$(t,{currentLocation:w,expectedLocation:f,distance:n,ignoreLocation:a});if(g=Math.min(S,g),p=w+u,I){let b=0;for(;b<u;)y[w+b]=1,b+=1}}p=-1;let x=[],L=1,O=u+h;const Ie=1<<u-1;for(let S=0;S<u;S+=1){let b=0,A=O;for(;b<A;)$(t,{errors:S,currentLocation:f+A,expectedLocation:f,distance:n,ignoreLocation:a})<=g?b=A:O=A,A=Math.floor((O-b)/2+b);O=A;let Z=Math.max(1,f-A+1),K=c?h:Math.min(f+A,h)+u,B=Array(K+2);B[K+1]=(1<<S)-1;for(let v=K;v>=Z;v-=1){let F=v-1,q=r[e.charAt(F)];if(I&&(y[F]=+!!q),B[v]=(B[v+1]<<1|1)&q,S&&(B[v]|=(x[v+1]|x[v])<<1|1|x[v+1]),B[v]&Ie&&(L=$(t,{errors:S,currentLocation:F,expectedLocation:f,distance:n,ignoreLocation:a}),L<=g)){if(g=L,p=F,p<=f)break;Z=Math.max(1,2*f-p)}}if($(t,{errors:S+1,currentLocation:f,expectedLocation:f,distance:n,ignoreLocation:a})>g)break;x=B}const j={isMatch:p>=0,score:Math.max(.001,L)};if(I){const S=gt(y,i);S.length?l&&(j.indices=S):j.isMatch=!1}return j}function mt(e){let t={};for(let r=0,s=e.length;r<s;r+=1){const n=e.charAt(r);t[n]=(t[n]||0)|1<<s-r-1}return t}var fe=class{constructor(e,{location:t=d.location,threshold:r=d.threshold,distance:s=d.distance,includeMatches:n=d.includeMatches,findAllMatches:o=d.findAllMatches,minMatchCharLength:c=d.minMatchCharLength,isCaseSensitive:i=d.isCaseSensitive,ignoreLocation:l=d.ignoreLocation}={}){if(this.options={location:t,threshold:r,distance:s,includeMatches:n,findAllMatches:o,minMatchCharLength:c,isCaseSensitive:i,ignoreLocation:l},this.pattern=i?e:e.toLowerCase(),this.chunks=[],!this.pattern.length)return;const a=(h,f)=>{this.chunks.push({pattern:h,alphabet:mt(h),startIndex:f})},u=this.pattern.length;if(u>T){let h=0;const f=u%T,g=u-f;for(;h<g;)a(this.pattern.substr(h,T),h),h+=T;if(f){const p=u-T;a(this.pattern.substr(p),p)}}else a(this.pattern,0)}searchIn(e){const{isCaseSensitive:t,includeMatches:r}=this.options;if(t||(e=e.toLowerCase()),this.pattern===e){let g={isMatch:!0,score:0};return r&&(g.indices=[[0,e.length-1]]),g}const{location:s,distance:n,threshold:o,findAllMatches:c,minMatchCharLength:i,ignoreLocation:l}=this.options;let a=[],u=0,h=!1;this.chunks.forEach(({pattern:g,alphabet:p,startIndex:I})=>{const{isMatch:y,score:w,indices:x}=pt(e,g,p,{location:s+I,distance:n,threshold:o,findAllMatches:c,minMatchCharLength:i,includeMatches:r,ignoreLocation:l});y&&(h=!0),u+=w,y&&x&&(a=[...a,...x])});let f={isMatch:h,score:h?u/this.chunks.length:1};return h&&r&&(f.indices=a),f}},k=class{constructor(e){this.pattern=e}static isMultiMatch(e){return re(e,this.multiRegex)}static isSingleMatch(e){return re(e,this.singleRegex)}search(){}};function re(e,t){const r=e.match(t);return r?r[1]:null}var yt=class extends k{constructor(e){super(e)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(e){const t=e===this.pattern;return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}},Mt=class extends k{constructor(e){super(e)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(e){const r=e.indexOf(this.pattern)===-1;return{isMatch:r,score:r?0:1,indices:[0,e.length-1]}}},It=class extends k{constructor(e){super(e)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(e){const t=e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}},St=class extends k{constructor(e){super(e)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(e){const t=!e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},vt=class extends k{constructor(e){super(e)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(e){const t=e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[e.length-this.pattern.length,e.length-1]}}},Ct=class extends k{constructor(e){super(e)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(e){const t=!e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},ge=class extends k{constructor(e,{location:t=d.location,threshold:r=d.threshold,distance:s=d.distance,includeMatches:n=d.includeMatches,findAllMatches:o=d.findAllMatches,minMatchCharLength:c=d.minMatchCharLength,isCaseSensitive:i=d.isCaseSensitive,ignoreLocation:l=d.ignoreLocation}={}){super(e),this._bitapSearch=new fe(e,{location:t,threshold:r,distance:s,includeMatches:n,findAllMatches:o,minMatchCharLength:c,isCaseSensitive:i,ignoreLocation:l})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(e){return this._bitapSearch.searchIn(e)}},pe=class extends k{constructor(e){super(e)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(e){let t=0,r;const s=[],n=this.pattern.length;for(;(r=e.indexOf(this.pattern,t))>-1;)t=r+n,s.push([r,t-1]);const o=!!s.length;return{isMatch:o,score:o?0:1,indices:s}}};const U=[yt,pe,It,St,Ct,vt,Mt,ge],ne=U.length,Et=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/,_t="|";function bt(e,t={}){return e.split(_t).map(r=>{let s=r.trim().split(Et).filter(o=>o&&!!o.trim()),n=[];for(let o=0,c=s.length;o<c;o+=1){const i=s[o];let l=!1,a=-1;for(;!l&&++a<ne;){const u=U[a];let h=u.isMultiMatch(i);h&&(n.push(new u(h,t)),l=!0)}if(!l)for(a=-1;++a<ne;){const u=U[a];let h=u.isSingleMatch(i);if(h){n.push(new u(h,t));break}}}return n})}const At=new Set([ge.type,pe.type]);var kt=class{constructor(e,{isCaseSensitive:t=d.isCaseSensitive,includeMatches:r=d.includeMatches,minMatchCharLength:s=d.minMatchCharLength,ignoreLocation:n=d.ignoreLocation,findAllMatches:o=d.findAllMatches,location:c=d.location,threshold:i=d.threshold,distance:l=d.distance}={}){this.query=null,this.options={isCaseSensitive:t,includeMatches:r,minMatchCharLength:s,findAllMatches:o,ignoreLocation:n,location:c,threshold:i,distance:l},this.pattern=t?e:e.toLowerCase(),this.query=bt(this.pattern,this.options)}static condition(e,t){return t.useExtendedSearch}searchIn(e){const t=this.query;if(!t)return{isMatch:!1,score:1};const{includeMatches:r,isCaseSensitive:s}=this.options;e=s?e:e.toLowerCase();let n=0,o=[],c=0;for(let i=0,l=t.length;i<l;i+=1){const a=t[i];o.length=0,n=0;for(let u=0,h=a.length;u<h;u+=1){const f=a[u],{isMatch:g,indices:p,score:I}=f.search(e);if(g){if(n+=1,c+=I,r){const y=f.constructor.type;At.has(y)?o=[...o,...p]:o.push(p)}}else{c=0,n=0,o.length=0;break}}if(n){let u={isMatch:!0,score:c/n};return r&&(u.indices=o),u}}return{isMatch:!1,score:1}}};const z=[];function xt(...e){z.push(...e)}function G(e,t){for(let r=0,s=z.length;r<s;r+=1){let n=z[r];if(n.condition(e,t))return new n(e,t)}return new fe(e,t)}const D={AND:"$and",OR:"$or"},H={PATH:"$path",PATTERN:"$val"},Y=e=>!!(e[D.AND]||e[D.OR]),Tt=e=>!!e[H.PATH],wt=e=>!_(e)&&le(e)&&!Y(e),se=e=>({[D.AND]:Object.keys(e).map(t=>({[t]:e[t]}))});function me(e,t,{auto:r=!0}={}){const s=n=>{let o=Object.keys(n);const c=Tt(n);if(!c&&o.length>1&&!Y(n))return s(se(n));if(wt(n)){const l=c?n[H.PATH]:o[0],a=c?n[H.PATTERN]:n[l];if(!E(a))throw new Error(tt(l));const u={keyId:Q(l),pattern:a};return r&&(u.searcher=G(a,t)),u}let i={children:[],operator:o[0]};return o.forEach(l=>{const a=n[l];_(a)&&a.forEach(u=>{i.children.push(s(u))})}),i};return Y(e)||(e=se(e)),s(e)}function Bt(e,{ignoreFieldNorm:t=d.ignoreFieldNorm}){e.forEach(r=>{let s=1;r.matches.forEach(({key:n,norm:o,score:c})=>{const i=n?n.weight:null;s*=Math.pow(c===0&&i?Number.EPSILON:c,(i||1)*(t?1:o))}),r.score=s})}function Rt(e,t){const r=e.matches;t.matches=[],M(r)&&r.forEach(s=>{if(!M(s.indices)||!s.indices.length)return;const{indices:n,value:o}=s;let c={indices:n,value:o};s.key&&(c.key=s.key.src),s.idx>-1&&(c.refIndex=s.idx),t.matches.push(c)})}function Nt(e,t){t.score=e.score}function Pt(e,t,{includeMatches:r=d.includeMatches,includeScore:s=d.includeScore}={}){const n=[];return r&&n.push(Rt),s&&n.push(Nt),e.map(o=>{const{idx:c}=o,i={item:t[c],refIndex:c};return n.length&&n.forEach(l=>{l(o,i)}),i})}var N=class{constructor(e,t={},r){this.options={...d,...t},this.options.useExtendedSearch,this._keyStore=new ot(this.options.keys),this.setCollection(e,r)}setCollection(e,t){if(this._docs=e,t&&!(t instanceof J))throw new Error(et);this._myIndex=t||de(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(e){M(e)&&(this._docs.push(e),this._myIndex.add(e))}remove(e=()=>!1){const t=[];for(let r=0,s=this._docs.length;r<s;r+=1){const n=this._docs[r];e(n,r)&&(this.removeAt(r),r-=1,s-=1,t.push(n))}return t}removeAt(e){this._docs.splice(e,1),this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e,{limit:t=-1}={}){const{includeMatches:r,includeScore:s,shouldSort:n,sortFn:o,ignoreFieldNorm:c}=this.options;let i=E(e)?E(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);return Bt(i,{ignoreFieldNorm:c}),n&&i.sort(o),ae(t)&&t>-1&&(i=i.slice(0,t)),Pt(i,this._docs,{includeMatches:r,includeScore:s})}_searchStringList(e){const t=G(e,this.options),{records:r}=this._myIndex,s=[];return r.forEach(({v:n,i:o,n:c})=>{if(!M(n))return;const{isMatch:i,score:l,indices:a}=t.searchIn(n);i&&s.push({item:n,idx:o,matches:[{score:l,value:n,norm:c,indices:a}]})}),s}_searchLogical(e){const t=me(e,this.options),r=(c,i,l)=>{if(!c.children){const{keyId:u,searcher:h}=c,f=this._findMatches({key:this._keyStore.get(u),value:this._myIndex.getValueForItemAtKeyId(i,u),searcher:h});return f&&f.length?[{idx:l,item:i,matches:f}]:[]}const a=[];for(let u=0,h=c.children.length;u<h;u+=1){const f=c.children[u],g=r(f,i,l);if(g.length)a.push(...g);else if(c.operator===D.AND)return[]}return a},s=this._myIndex.records,n={},o=[];return s.forEach(({$:c,i})=>{if(M(c)){let l=r(t,c,i);l.length&&(n[i]||(n[i]={idx:i,item:c,matches:[]},o.push(n[i])),l.forEach(({matches:a})=>{n[i].matches.push(...a)}))}}),o}_searchObjectList(e){const t=G(e,this.options),{keys:r,records:s}=this._myIndex,n=[];return s.forEach(({$:o,i:c})=>{if(!M(o))return;let i=[];r.forEach((l,a)=>{i.push(...this._findMatches({key:l,value:o[a],searcher:t}))}),i.length&&n.push({idx:c,item:o,matches:i})}),n}_findMatches({key:e,value:t,searcher:r}){if(!M(t))return[];let s=[];if(_(t))t.forEach(({v:n,i:o,n:c})=>{if(!M(n))return;const{isMatch:i,score:l,indices:a}=r.searchIn(n);i&&s.push({score:l,key:e,value:n,idx:o,norm:c,indices:a})});else{const{v:n,n:o}=t,{isMatch:c,score:i,indices:l}=r.searchIn(n);c&&s.push({score:i,key:e,value:n,norm:o,indices:l})}return s}};N.version="6.5.3";N.createIndex=de;N.parseIndex=ft;N.config=d;N.parseQuery=me;xt(kt);const Lt={includeMatches:!0,isCaseSensitive:!1,keys:["currencyInfo.currency.chainId","currencyInfo.currency.symbol","currencyInfo.currency.name",{name:"currencyInfo.currency.address",weight:.2}],shouldSort:!0,useExtendedSearch:!0},Ot=e=>e?{"currencyInfo.currency.chainId":`=${e}`}:null,Ft=e=>e&&e.startsWith("0x")&&e.length>5?{"currencyInfo.currency.address":`^${e}`}:null,$t=e=>e?{"currencyInfo.currency.symbol":`'${e}`}:null,Dt=e=>e?{"currencyInfo.currency.name":`'${e}`}:null;function jt({tokenOptions:e,chainFilter:t,searchFilter:r}){if(!e||!e.length)return[];if(!t&&!r)return e;const s=[],n=[],o=Ot(t);o&&s.push(o);const c=Ft(r);c&&n.push(c);const i=$t(r);i&&n.push(i);const l=Dt(r);l&&n.push(l);const a={$and:[...s,...n.length>0?[{$or:n}]:[]]};return new N(e,Lt).search(a).map(f=>f.item)}function ye(e){const{data:t,loading:r,error:s,refetch:n}=Ye(e),o=De(r,s instanceof be?s:void 0);return{data:(0,m.useMemo)(()=>t==null?void 0:t.filter(i=>{if(i.currency.isNative)return!0;const{address:l,chainId:a}=i.currency;return!xe.find(h=>oe({addressInput1:{address:h,chainId:a},addressInput2:{address:l,chainId:a}}))}),[t]),loading:r,error:o,refetch:n}}const Kt=[R(C.Mainnet),R(C.Polygon),R(C.Bnb),R(C.Celo),R(C.Avalanche),R(C.Solana),P(Ne),P(Pe),P(Le),Te(C.Mainnet)];function Wt(){const{isTestnetModeEnabled:e}=Ee();return ye(e?[]:Kt)}let X=(function(e){return e.Token="Token",e.Pool="Pool",e.WalletByAddress="WalletByAddress",e.ENSAddress="ENSAddress",e.Unitag="Unitag",e.NFTCollection="NFTCollection",e})({});function Qt(e){return e==null?void 0:e.filter(t=>!!t).map(t=>({type:X.Token,currencyInfo:t,quantity:null,balanceUSD:void 0}))}function Ut(e){return{type:X.Token,currencyInfo:e,balanceUSD:null,quantity:null}}function Me({currencyInfos:e,portfolioBalancesById:t,sortAlphabetically:r}){return(0,m.useMemo)(()=>e?(r?[...e].sort((n,o)=>n.currency.name&&o.currency.name?n.currency.name.localeCompare(o.currency.name):0):e).map(n=>{const o=t==null?void 0:t[n.currencyId.toLowerCase()];return o?{type:X.Token,...o}:Ut(n)}):void 0,[e,t,r])}function zt(e){const{data:t,error:r,refetch:s,loading:n}=je({address:e,fetchPolicy:"cache-first"});return(0,m.useMemo)(()=>({data:t,error:r,refetch:s,loading:n}),[t,r,s,n])}function Gt(e,t){const{data:r,error:s,refetch:n,loading:o}=zt(e),{data:c,error:i,refetch:l,loading:a}=Wt(),u="0x588ce4f028d8e7b53b687865d6a67b3a54c75518",h=(0,m.useMemo)(()=>c==null?void 0:c.filter(y=>y.currency.isNative||y.currency.chainId!==C.Unichain||!oe({addressInput1:{address:u,chainId:C.Unichain},addressInput2:{address:y.currency.address,chainId:y.currency.chainId}})),[c]),f=Me({currencyInfos:h,portfolioBalancesById:r}),g=(0,m.useCallback)(()=>{n==null||n(),l==null||l()},[n,l]),p=!r&&s||!c&&i,I=(0,m.useMemo)(()=>f&&jt({tokenOptions:f,chainFilter:t}),[t,f]);return(0,m.useMemo)(()=>({data:I,refetch:g,error:p||void 0,loading:o||a}),[p,a,o,I,g])}function dr(e,t){const{data:r,error:s,refetch:n,loading:o}=Gt(e,t),c=t?Qt(Ge[t]):void 0,i=(0,m.useMemo)(()=>(c==null?void 0:c.map(h=>P(h.currencyInfo.currency)).filter(Boolean))??[],[c]),{data:l}=ye(i),a=Me({currencyInfos:l,portfolioBalancesById:{}}),u=(r==null?void 0:r.length)===0&&(c==null?void 0:c.length);return(0,m.useMemo)(()=>({data:u?a:r,error:u?void 0:s,refetch:n,loading:o}),[a,r,s,o,n,u])}export{X as OnchainItemListOptionType,Qt as currencyInfosToTokenOptions,jt as filter,ur as getSwappableTokensQueryData,dr as useCommonTokensOptionsWithFallback,ye as useCurrencies,Me as useCurrencyInfosToTokenOptions,zt as usePortfolioBalancesForAddressById,hr as usePrefetchSwappableTokens,Ye as useTokenProjects,lr as useTradingApiSwappableTokensQuery};
