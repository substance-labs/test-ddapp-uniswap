import{__toESM as _}from"./chunk-DgAfPHQg.js";import{require_react as T}from"./react-CNoFhWkx.js";import{getAddress as x}from"./isAddress-P2vaZgmG.js";import{parseAccount as b}from"./parseAccount-CRyN5swV.js";import{useQueryClient as $}from"./useQuery-D_ZCw8XG.js";import{Web3Provider as k,init_lib as M}from"./lib-Dj-AwQVD.js";import{createTransport as N,uid as O}from"./createTransport-WEDNYdh5.js";import{require_with_selector as R,useAccount as S,useAccount$1 as F,useChainId as K,useConfig as q}from"./useAccount-C5hwiBwN.js";import{ConnectorAccountNotFoundError as U,ConnectorChainMismatchError as W,ConnectorNotConnectedError as j,ConnectorUnavailableReconnectingError as B}from"./config-CDfnfyHL.js";import{filterQueryOptions as L,useQuery as D}from"./query-qNZtVuxH.js";function V(n){const{batch:e,cacheTime:t=n.pollingInterval??4e3,ccipRead:o,key:i="base",name:s="Base Client",pollingInterval:r=4e3,type:u="base"}=n,a=n.chain,c=n.account?b(n.account):void 0,{config:d,request:C,value:f}=n.transport({chain:a,pollingInterval:r}),v={...d,...f},l={account:c,batch:e,cacheTime:t,ccipRead:o,chain:a,key:i,name:s,pollingInterval:r,request:C,transport:v,type:u,uid:O()};function g(p){return P=>{const w=P(p);for(const Q in l)delete w[Q];const I={...p,...w};return Object.assign(I,{extend:g(I)})}}return Object.assign(l,{extend:g(l)})}function Y(n,e={}){const{key:t="custom",methods:o,name:i="Custom Provider",retryDelay:s}=e;return({retryCount:r})=>N({key:t,methods:o,name:i,request:n.request.bind(n),retryCount:e.retryCount??r,retryDelay:s,type:"custom"})}async function z(n,e={}){let t;if(e.connector){const{connector:c}=e;if(n.state.status==="reconnecting"&&!c.getAccounts&&!c.getChainId)throw new B({connector:c});const[d,C]=await Promise.all([c.getAccounts().catch(f=>{if(e.account===null)return[];throw f}),c.getChainId()]);t={accounts:d,chainId:C,connector:c}}else t=n.state.connections.get(n.state.current);if(!t)throw new j;const o=e.chainId??t.chainId,i=await t.connector.getChainId();if(i!==t.chainId)throw new W({connectionChainId:t.chainId,connectorChainId:i});const s=t.connector;if(s.getClient)return s.getClient({chainId:o});const r=b(e.account??t.accounts[0]);if(r&&(r.address=x(r.address)),e.account&&!t.accounts.some(c=>c.toLowerCase()===r.address.toLowerCase()))throw new U({address:r.address,connector:s});const u=n.chains.find(c=>c.id===o),a=await t.connector.getProvider({chainId:o});return V({account:r,chain:u,name:"Connector Client",transport:c=>Y(a)({...c,retryCount:0})})}function y(n,e={}){let t;try{t=n.getClient(e)}catch{}return t}function G(n,e){const{onChange:t}=e;return n.subscribe(()=>y(n),t,{equalityFn(o,i){return(o==null?void 0:o.uid)===(i==null?void 0:i.uid)}})}function H(n,e={}){return{gcTime:0,async queryFn({queryKey:t}){const{connector:o}=e,{connectorUid:i,scopeKey:s,...r}=t[1];return z(n,{...r,connector:o})},queryKey:J(e)}}function J(n={}){const{connector:e,...t}=n;return["connectorClient",{...L(t),connectorUid:e==null?void 0:e.uid}]}var X=_(R());function Z(n={}){const e=q(n);return(0,X.useSyncExternalStoreWithSelector)(t=>G(e,{onChange:t}),()=>y(e,n),()=>y(e,n),t=>t,(t,o)=>(t==null?void 0:t.uid)===(o==null?void 0:o.uid))}var h=_(T());function A(n={}){const{query:e={},...t}=n,o=q(t),i=$(),{address:s,connector:r,status:u}=F({config:o}),a=K({config:o}),c=n.connector??r,{queryKey:d,...C}=H(o,{...n,chainId:n.chainId??a,connector:c}),f=!!((u==="connected"||u==="reconnecting"&&(c!=null&&c.getProvider))&&(e.enabled??!0)),v=(0,h.useRef)(s);return(0,h.useEffect)(()=>{const l=v.current;!s&&l?(i.removeQueries({queryKey:d}),v.current=void 0):s!==l&&(i.invalidateQueries({queryKey:d}),v.current=s)},[s,i]),D({...e,...C,queryKey:d,enabled:f,staleTime:Number.POSITIVE_INFINITY})}M();const m=new WeakMap;function E(n,e){var t;if(!n)return;const{chain:o,transport:i}=n,s=(t=o.contracts)===null||t===void 0||(t=t.ensRegistry)===null||t===void 0?void 0:t.address,r=o?{chainId:o.id,name:o.name,ensAddress:s}:e?{chainId:e,name:"Unsupported"}:void 0;if(r){if(m.has(n))return m.get(n);{const u=new k(i,r);return m.set(n,u),u}}}function ln({chainId:n}={}){const e=S(),{data:t}=A({chainId:n}),o=Z({chainId:n});return(0,h.useMemo)(()=>E(e.chainId!==n?o:t??o,n),[e.chainId,n,t,o])}function Cn({chainId:n}={}){const{data:e}=A({chainId:n});return(0,h.useMemo)(()=>E(e,n),[n,e])}export{E as clientToProvider,V as createClient,Y as custom,y as getClient,z as getConnectorClient,A as useConnectorClient,ln as useEthersProvider,Cn as useEthersWeb3Provider};
