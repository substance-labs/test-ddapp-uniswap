import{__toESM as rt}from"./chunk-DgAfPHQg.js";import{global as L,init_dist as Co}from"./dist-Q7olfaoJ.js";import{init_dist as Ro,process$1 as ji}from"./dist-QCpUvRkJ.js";import{Buffer as Ee,init_dist as Or}from"./dist-ceZDlR1V.js";import{recoverAddress as Za}from"./recoverAddress-oPdWABRo.js";import{esm_default as Xa}from"./esm-DSGHq0HW.js";import{require_events as vs}from"./events-Bnkik2bI.js";import{A as ec,C as tc,E as Pe,IEvents as $i,Po as Vr,Qe as ic,Qo as sc,concat as Ui,detect as rc,f as Je,f$1 as nc,formatJsonRpcError as To,formatJsonRpcRequest as Dt,formatJsonRpcResult as bs,fromString as Le,getBigIntRpcId as ci,h as oc,i as ac,import_browser as Ar,isJsonRpcError as et,isJsonRpcRequest as xr,isJsonRpcResponse as Nr,isJsonRpcResult as ct,k as $s,o as Be,payloadId as mt,r as Ei,require_cjs as cc,require_cjs$1 as qo,require_cjs$2 as Cr,safeJsonParse as Kr,safeJsonStringify as hc,sn as er,toString as Ne,y as ke}from"./index.es-2xsffwdf.js";import{AccountController as Fr,ChainController as ot,ConnectionController as Ns,ConnectorController as lc,ConstantsUtil$2 as uc,CoreHelperUtil as Gr,EventsController as Vt,ModalController as Oi,OptionsController as es,RouterController as Kt,SnackController as Ai,W3mFrameRpcConstants as pc}from"./ConstantsUtil-DWdkyivO.js";var fw=rt(vs()),dc=Object.defineProperty,gc=(e,t,i)=>t in e?dc(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Wr=(e,t,i)=>gc(e,typeof t!="symbol"?t+"":t,i),fc=class extends $i{constructor(e){super(),this.opts=e,Wr(this,"protocol","wc"),Wr(this,"version",2)}},yc=Object.defineProperty,mc=(e,t,i)=>t in e?yc(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,wc=(e,t,i)=>mc(e,typeof t!="symbol"?t+"":t,i),vc=class extends $i{constructor(e,t){super(),this.core=e,this.logger=t,wc(this,"records",new Map)}},bc=class{constructor(e,t){this.logger=e,this.core=t}},$c=class extends $i{constructor(e,t){super(),this.relayer=e,this.logger=t}},Ec=class extends $i{constructor(e){super()}},_c=class{constructor(e,t,i,s){this.core=e,this.logger=t,this.name=i}},Ic=class extends $i{constructor(e,t){super(),this.relayer=e,this.logger=t}},Pc=class extends $i{constructor(e,t){super(),this.core=e,this.logger=t}},Sc=class{constructor(e,t,i){this.core=e,this.logger=t,this.store=i}},Oc=class{constructor(e,t){this.projectId=e,this.logger=t}},Ac=class{constructor(e,t,i){this.core=e,this.logger=t,this.telemetryEnabled=i}},xc=Object.defineProperty,Nc=(e,t,i)=>t in e?xc(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Jr=(e,t,i)=>Nc(e,typeof t!="symbol"?t+"":t,i),Cc=class{constructor(e){this.opts=e,Jr(this,"protocol","wc"),Jr(this,"version",2)}},Rc=class{constructor(e){this.client=e}};Ro();Co();Or();var pi=rt(Cr()),St=rt(qo()),Tc=rt(cc());const qc=":";function di(e){const[t,i]=e.split(qc);return{namespace:t,reference:i}}function Do(e,t){return e.includes(":")?[e]:t.chains||[]}var Dc=Object.defineProperty,kc=Object.defineProperties,jc=Object.getOwnPropertyDescriptors,Yr=Object.getOwnPropertySymbols,Uc=Object.prototype.hasOwnProperty,Mc=Object.prototype.propertyIsEnumerable,Qr=(e,t,i)=>t in e?Dc(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Zr=(e,t)=>{for(var i in t||(t={}))Uc.call(t,i)&&Qr(e,i,t[i]);if(Yr)for(var i of Yr(t))Mc.call(t,i)&&Qr(e,i,t[i]);return e},Lc=(e,t)=>kc(e,jc(t));const Bc="ReactNative",xe={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"};const zc="js";function gs(){return typeof ji<"u"&&typeof ji.versions<"u"&&typeof ji.versions.node<"u"}function Ot(){return!(0,St.getDocument)()&&!!(0,St.getNavigator)()&&navigator.product===Bc}function Hc(){return Ot()&&typeof L<"u"&&typeof(L==null?void 0:L.Platform)<"u"&&(L==null?void 0:L.Platform.OS)==="android"}function Vc(){return Ot()&&typeof L<"u"&&typeof(L==null?void 0:L.Platform)<"u"&&(L==null?void 0:L.Platform.OS)==="ios"}function _i(){return!gs()&&!!(0,St.getNavigator)()&&!!(0,St.getDocument)()}function Gi(){return Ot()?xe.reactNative:gs()?xe.node:_i()?xe.browser:xe.unknown}function Xr(){var e;try{return Ot()&&typeof L<"u"&&typeof(L==null?void 0:L.Application)<"u"?(e=L.Application)==null?void 0:e.applicationId:void 0}catch{return}}function Kc(e,t){const i=new URLSearchParams(e);for(const s of Object.keys(t).sort())if(t.hasOwnProperty(s)){const r=t[s];r!==void 0&&i.set(s,r)}return i.toString()}function Fc(e){var t,i;const s=ko();try{return e!=null&&e.url&&s.url&&new URL(e.url).host!==new URL(s.url).host&&(console.warn(`The configured WalletConnect 'metadata.url':${e.url} differs from the actual page url:${s.url}. This is probably unintended and can lead to issues.`),e.url=s.url),(t=e==null?void 0:e.icons)!=null&&t.length&&e.icons.length>0&&(e.icons=e.icons.filter(r=>r!=="")),Lc(Zr(Zr({},s),e),{url:(e==null?void 0:e.url)||s.url,name:(e==null?void 0:e.name)||s.name,description:(e==null?void 0:e.description)||s.description,icons:(i=e==null?void 0:e.icons)!=null&&i.length&&e.icons.length>0?e.icons:s.icons})}catch(r){return console.warn("Error populating app metadata",r),e||s}}function ko(){return(0,Tc.getWindowMetadata)()||{name:"",description:"",url:"",icons:[""]}}function Gc(){if(Gi()===xe.reactNative&&typeof L<"u"&&typeof(L==null?void 0:L.Platform)<"u"){const{OS:i,Version:s}=L.Platform;return[i,s].join("-")}const e=rc();if(e===null)return"unknown";const t=e.os?e.os.replace(" ","").toLowerCase():"unknown";return e.type==="browser"?[t,e.name,e.version].join("-"):[t,e.version].join("-")}function Wc(){var e;const t=Gi();return t===xe.browser?[t,((e=(0,St.getLocation)())==null?void 0:e.host)||"unknown"].join(":"):t}function jo(e,t,i){const s=Gc(),r=Wc();return[[e,t].join("-"),[zc,i].join("-"),s,r].join("/")}function Jc({protocol:e,version:t,relayUrl:i,sdkVersion:s,auth:r,projectId:n,useOnCloseEvent:o,bundleId:a,packageName:c}){const h=i.split("?"),l=jo(e,t,s),u={auth:r,ua:l,projectId:n,useOnCloseEvent:o||void 0,packageName:c||void 0,bundleId:a||void 0},p=Kc(h[1]||"",u);return h[0]+"?"+p}function kt(e,t){return e.filter(i=>t.includes(i)).length===e.length}function tr(e){return Object.fromEntries(e.entries())}function ir(e){return new Map(Object.entries(e))}function Ct(e=pi.FIVE_MINUTES,t){const i=(0,pi.toMiliseconds)(e||pi.FIVE_MINUTES);let s,r,n,o;return{resolve:a=>{n&&s&&(clearTimeout(n),s(a),o=Promise.resolve(a))},reject:a=>{n&&r&&(clearTimeout(n),r(a))},done:()=>new Promise((a,c)=>{if(o)return a(o);n=setTimeout(()=>{const h=new Error(t);o=Promise.reject(h),c(h)},i),s=a,r=c})}}function Et(e,t,i){return new Promise(async(s,r)=>{const n=setTimeout(()=>r(new Error(i)),t);try{const o=await e;s(o)}catch(o){r(o)}clearTimeout(n)})}function Uo(e,t){if(typeof t=="string"&&t.startsWith(`${e}:`))return t;if(e.toLowerCase()==="topic"){if(typeof t!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${t}`}else if(e.toLowerCase()==="id"){if(typeof t!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${t}`}throw new Error(`Unknown expirer target type: ${e}`)}function Yc(e){return Uo("topic",e)}function Qc(e){return Uo("id",e)}function Mo(e){const[t,i]=e.split(":"),s={id:void 0,topic:void 0};if(t==="topic"&&typeof i=="string")s.topic=i;else if(t==="id"&&Number.isInteger(Number(i)))s.id=Number(i);else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${i}`);return s}function he(e,t){return(0,pi.fromMiliseconds)((t||Date.now())+(0,pi.toMiliseconds)(e))}function bt(e){return Date.now()>=(0,pi.toMiliseconds)(e)}function Y(e,t){return`${e}${t?`:${t}`:""}`}function it(e=[],t=[]){return[...new Set([...e,...t])]}async function Zc({id:e,topic:t,wcDeepLink:i}){var s;try{if(!i)return;const r=typeof i=="string"?JSON.parse(i):i,n=r==null?void 0:r.href;if(typeof n!="string")return;const o=Xc(n,e,t),a=Gi();if(a===xe.browser){if(!((s=(0,St.getDocument)())!=null&&s.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}eh(o)}else a===xe.reactNative&&typeof(L==null?void 0:L.Linking)<"u"&&await L.Linking.openURL(o)}catch(r){console.error(r)}}function Xc(e,t,i){const s=`requestId=${t}&sessionTopic=${i}`;e.endsWith("/")&&(e=e.slice(0,-1));let r=`${e}`;if(e.startsWith("https://t.me")){const n=e.includes("?")?"&startapp=":"?startapp=";r=`${r}${n}${rh(s,!0)}`}else r=`${r}/wc?${s}`;return r}function eh(e){let t="_self";sh()?t="_top":(ih()||e.startsWith("https://")||e.startsWith("http://"))&&(t="_blank"),window.open(e,t,"noreferrer noopener")}async function th(e,t){let i="";try{if(_i()&&(i=localStorage.getItem(t),i))return i;i=await e.getItem(t)}catch(s){console.error(s)}return i}function en(e,t){if(!e.includes(t))return null;const i=e.split(/([&,?,=])/),s=i.indexOf(t);return i[s+2]}function tn(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,e=>{const t=Math.random()*16|0;return(e==="x"?t:t&3|8).toString(16)})}function Rr(){return typeof ji<"u"&&{}.IS_VITEST==="true"}function ih(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function sh(){try{return window.self!==window.top}catch{return!1}}function rh(e,t=!1){const i=Ee.from(e).toString("base64");return t?i.replace(/[=]/g,""):i}function Lo(e){return Ee.from(e,"base64").toString("utf-8")}function nh(e){return new Promise(t=>setTimeout(t,e))}function zi(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function oh(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Wi(e,...t){if(!oh(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Tr(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");zi(e.outputLen),zi(e.blockLen)}function gi(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Bo(e,t){Wi(e);const i=t.outputLen;if(e.length<i)throw new Error("digestInto() expects output buffer of length at least "+i)}const ts=BigInt(2**32-1),sn=BigInt(32);function ah(e,t=!1){return t?{h:Number(e&ts),l:Number(e>>sn&ts)}:{h:Number(e>>sn&ts)|0,l:Number(e&ts)|0}}function ch(e,t=!1){let i=new Uint32Array(e.length),s=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:n,l:o}=ah(e[r],t);[i[r],s[r]]=[n,o]}return[i,s]}const hh=(e,t,i)=>e<<i|t>>>32-i,lh=(e,t,i)=>t<<i|e>>>32-i,uh=(e,t,i)=>t<<i-32|e>>>64-i,ph=(e,t,i)=>e<<i-32|t>>>64-i,Ft=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function dh(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function Cs(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function Ye(e,t){return e<<32-t|e>>>t}const rn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function gh(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function nn(e){for(let t=0;t<e.length;t++)e[t]=gh(e[t])}function fh(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function fi(e){return typeof e=="string"&&(e=fh(e)),Wi(e),e}function yh(...e){let t=0;for(let s=0;s<e.length;s++){const r=e[s];Wi(r),t+=r.length}const i=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const n=e[s];i.set(n,r),r+=n.length}return i}var qr=class{clone(){return this._cloneInto()}};function zo(e){const t=s=>e().update(fi(s)).digest(),i=e();return t.outputLen=i.outputLen,t.blockLen=i.blockLen,t.create=()=>e(),t}function Ii(e=32){if(Ft&&typeof Ft.getRandomValues=="function")return Ft.getRandomValues(new Uint8Array(e));if(Ft&&typeof Ft.randomBytes=="function")return Ft.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const Ho=[],Vo=[],Ko=[],mh=BigInt(0),xi=BigInt(1),wh=BigInt(2),vh=BigInt(7),bh=BigInt(256),$h=BigInt(113);for(let e=0,t=xi,i=1,s=0;e<24;e++){[i,s]=[s,(2*i+3*s)%5],Ho.push(2*(5*s+i)),Vo.push((e+1)*(e+2)/2%64);let r=mh;for(let n=0;n<7;n++)t=(t<<xi^(t>>vh)*$h)%bh,t&wh&&(r^=xi<<(xi<<BigInt(n))-xi);Ko.push(r)}const[Eh,_h]=ch(Ko,!0),on=(e,t,i)=>i>32?uh(e,t,i):hh(e,t,i),an=(e,t,i)=>i>32?ph(e,t,i):lh(e,t,i);function Ih(e,t=24){const i=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let o=0;o<10;o++)i[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,c=(o+2)%10,h=i[c],l=i[c+1],u=on(h,l,1)^i[a],p=an(h,l,1)^i[a+1];for(let y=0;y<50;y+=10)e[o+y]^=u,e[o+y+1]^=p}let r=e[2],n=e[3];for(let o=0;o<24;o++){const a=Vo[o],c=on(r,n,a),h=an(r,n,a),l=Ho[o];r=e[l],n=e[l+1],e[l]=c,e[l+1]=h}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)i[a]=e[o+a];for(let a=0;a<10;a++)e[o+a]^=~i[(a+2)%10]&i[(a+4)%10]}e[0]^=Eh[s],e[1]^=_h[s]}i.fill(0)}var Ph=class Fo extends qr{constructor(t,i,s,r=!1,n=24){if(super(),this.blockLen=t,this.suffix=i,this.outputLen=s,this.enableXOF=r,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,zi(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=dh(this.state)}keccak(){rn||nn(this.state32),Ih(this.state32,this.rounds),rn||nn(this.state32),this.posOut=0,this.pos=0}update(t){gi(this);const{blockLen:i,state:s}=this;t=fi(t);const r=t.length;for(let n=0;n<r;){const o=Math.min(i-this.pos,r-n);for(let a=0;a<o;a++)s[this.pos++]^=t[n++];this.pos===i&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:i,pos:s,blockLen:r}=this;t[s]^=i,i&128&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){gi(this,!1),Wi(t),this.finish();const i=this.state,{blockLen:s}=this;for(let r=0,n=t.length;r<n;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,n-r);t.set(i.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return zi(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Bo(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:i,suffix:s,outputLen:r,rounds:n,enableXOF:o}=this;return t||(t=new Fo(i,s,r,o,n)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=n,t.suffix=s,t.outputLen=r,t.enableXOF=o,t.destroyed=this.destroyed,t}};const Sh=(e,t,i)=>zo(()=>new Ph(t,e,i)),Oh=Sh(1,136,256/8),Ah="https://rpc.walletconnect.org/v1";function Go(e){const t=`Ethereum Signed Message:
${e.length}`,i=new TextEncoder().encode(t+e);return"0x"+Ee.from(Oh(i)).toString("hex")}async function xh(e,t,i,s,r,n){switch(i.t){case"eip191":return await Nh(e,t,i.s);case"eip1271":return await Ch(e,t,i.s,s,r,n);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${i.t}`)}}async function Nh(e,t,i){return(await Za({hash:Go(t),signature:i})).toLowerCase()===e.toLowerCase()}async function Ch(e,t,i,s,r,n){const o=di(s);if(!o.namespace||!o.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${s}`);try{const a="0x1626ba7e",c="0000000000000000000000000000000000000000000000000000000000000040",h="0000000000000000000000000000000000000000000000000000000000000041",l=i.substring(2),u=Go(t).substring(2),p=a+u+c+h+l,y=await fetch(`${n||Ah}/?chainId=${s}&projectId=${r}`,{method:"POST",body:JSON.stringify({id:Rh(),jsonrpc:"2.0",method:"eth_call",params:[{to:e,data:p},"latest"]})}),{result:f}=await y.json();return f?f.slice(0,a.length).toLowerCase()===a.toLowerCase():!1}catch(a){return console.error("isValidEip1271Signature: ",a),!1}}function Rh(){return Date.now()+Math.floor(Math.random()*1e3)}function Th(e){const t=atob(e),i=new Uint8Array(t.length);for(let o=0;o<t.length;o++)i[o]=t.charCodeAt(o);const s=i[0];if(s===0)throw new Error("No signatures found");const r=1+s*64;if(i.length<r)throw new Error("Transaction data too short for claimed signature count");if(i.length<100)throw new Error("Transaction too short");const n=Ee.from(e,"base64").slice(1,65);return Xa.encode(n)}var qh=Object.defineProperty,Dh=Object.defineProperties,kh=Object.getOwnPropertyDescriptors,cn=Object.getOwnPropertySymbols,jh=Object.prototype.hasOwnProperty,Uh=Object.prototype.propertyIsEnumerable,hn=(e,t,i)=>t in e?qh(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Mh=(e,t)=>{for(var i in t||(t={}))jh.call(t,i)&&hn(e,i,t[i]);if(cn)for(var i of cn(t))Uh.call(t,i)&&hn(e,i,t[i]);return e},Lh=(e,t)=>Dh(e,kh(t));const Bh="did:pkh:",Dr=e=>e==null?void 0:e.split(":"),zh=e=>{const t=e&&Dr(e);if(t)return e.includes(Bh)?t[3]:t[1]},sr=e=>{const t=e&&Dr(e);if(t)return t[2]+":"+t[3]},fs=e=>{const t=e&&Dr(e);if(t)return t.pop()};async function ln(e){const{cacao:t,projectId:i}=e,{s,p:r}=t,n=Wo(r,r.iss),o=fs(r.iss);return await xh(o,n,s,sr(r.iss),i)}const Wo=(e,t)=>{const i=`${e.domain} wants you to sign in with your Ethereum account:`,s=fs(t);if(!e.aud&&!e.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let r=e.statement||void 0;const n=`URI: ${e.aud||e.uri}`,o=`Version: ${e.version}`,a=`Chain ID: ${zh(t)}`,c=`Nonce: ${e.nonce}`,h=`Issued At: ${e.iat}`,l=e.exp?`Expiration Time: ${e.exp}`:void 0,u=e.nbf?`Not Before: ${e.nbf}`:void 0,p=e.requestId?`Request ID: ${e.requestId}`:void 0,y=e.resources?`Resources:${e.resources.map(m=>`
- ${m}`).join("")}`:void 0,f=ls(e.resources);if(f){const m=Hi(f);r=Qh(r,m)}return[i,s,"",r,"",n,o,a,c,h,l,u,p,y].filter(m=>m!=null).join(`
`)};function Hh(e){return Ee.from(JSON.stringify(e)).toString("base64")}function Vh(e){return JSON.parse(Ee.from(e,"base64").toString("utf-8"))}function Ut(e){if(!e)throw new Error("No recap provided, value is undefined");if(!e.att)throw new Error("No `att` property found");const t=Object.keys(e.att);if(!(t!=null&&t.length))throw new Error("No resources found in `att` property");t.forEach(i=>{const s=e.att[i];if(Array.isArray(s))throw new Error(`Resource must be an object: ${i}`);if(typeof s!="object")throw new Error(`Resource must be an object: ${i}`);if(!Object.keys(s).length)throw new Error(`Resource object is empty: ${i}`);Object.keys(s).forEach(r=>{const n=s[r];if(!Array.isArray(n))throw new Error(`Ability limits ${r} must be an array of objects, found: ${n}`);if(!n.length)throw new Error(`Value of ${r} is empty array, must be an array with objects`);n.forEach(o=>{if(typeof o!="object")throw new Error(`Ability limits (${r}) must be an array of objects, found: ${o}`)})})})}function Kh(e,t,i,s={}){return i==null||i.sort((r,n)=>r.localeCompare(n)),{att:{[e]:Fh(t,i,s)}}}function Fh(e,t,i={}){t=t==null?void 0:t.sort((r,n)=>r.localeCompare(n));const s=t.map(r=>({[`${e}/${r}`]:[i]}));return Object.assign({},...s)}function Jo(e){return Ut(e),`urn:recap:${Hh(e).replace(/=/g,"")}`}function Hi(e){const t=Vh(e.replace("urn:recap:",""));return Ut(t),t}function Gh(e,t,i){const s=Kh(e,t,i);return Jo(s)}function Wh(e){return e&&e.includes("urn:recap:")}function Jh(e,t){const i=Hi(e),s=Hi(t),r=Yh(i,s);return Jo(r)}function Yh(e,t){Ut(e),Ut(t);const i=Object.keys(e.att).concat(Object.keys(t.att)).sort((r,n)=>r.localeCompare(n)),s={att:{}};return i.forEach(r=>{var n,o;Object.keys(((n=e.att)==null?void 0:n[r])||{}).concat(Object.keys(((o=t.att)==null?void 0:o[r])||{})).sort((a,c)=>a.localeCompare(c)).forEach(a=>{var c,h;s.att[r]=Lh(Mh({},s.att[r]),{[a]:((c=e.att[r])==null?void 0:c[a])||((h=t.att[r])==null?void 0:h[a])})})}),s}function Qh(e="",t){Ut(t);const i="I further authorize the stated URI to perform the following actions on my behalf: ";if(e.includes(i))return e;const s=[];let r=0;Object.keys(t.att).forEach(a=>{const c=Object.keys(t.att[a]).map(u=>({ability:u.split("/")[0],action:u.split("/")[1]}));c.sort((u,p)=>u.action.localeCompare(p.action));const h={};c.forEach(u=>{h[u.ability]||(h[u.ability]=[]),h[u.ability].push(u.action)});const l=Object.keys(h).map(u=>(r++,`(${r}) '${u}': '${h[u].join("', '")}' for '${a}'.`));s.push(l.join(", ").replace(".,","."))});const n=s.join(" "),o=`${i}${n}`;return`${e?e+" ":""}${o}`}function un(e){var t;const i=Hi(e);Ut(i);const s=(t=i.att)==null?void 0:t.eip155;return s?Object.keys(s).map(r=>r.split("/")[1]):[]}function pn(e){const t=Hi(e);Ut(t);const i=[];return Object.values(t.att).forEach(s=>{Object.values(s).forEach(r=>{var n;(n=r==null?void 0:r[0])!=null&&n.chains&&i.push(r[0].chains)})}),[...new Set(i.flat())]}function ls(e){if(!e)return;const t=e==null?void 0:e[e.length-1];return Wh(t)?t:void 0}function Rs(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Yo(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function qe(e,...t){if(!Yo(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function dn(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Zh(e,t){qe(e);const i=t.outputLen;if(e.length<i)throw new Error("digestInto() expects output buffer of length at least "+i)}function gn(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}const _t=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Xh=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),el=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!el)throw new Error("Non little-endian hardware is not supported");function tl(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function rr(e){if(typeof e=="string")e=tl(e);else if(Yo(e))e=nr(e);else throw new Error("Uint8Array expected, got "+typeof e);return e}function il(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function sl(e,t){if(e.length!==t.length)return!1;let i=0;for(let s=0;s<e.length;s++)i|=e[s]^t[s];return i===0}const rl=(e,t)=>{function i(s,...r){if(qe(s),e.nonceLength!==void 0){const h=r[0];if(!h)throw new Error("nonce / iv required");e.varSizeNonce?qe(h):qe(h,e.nonceLength)}const n=e.tagLength;n&&r[1]!==void 0&&qe(r[1]);const o=t(s,...r),a=(h,l)=>{if(l!==void 0){if(h!==2)throw new Error("cipher output not supported");qe(l)}};let c=!1;return{encrypt(h,l){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,qe(h),a(o.encrypt.length,l),o.encrypt(h,l)},decrypt(h,l){if(qe(h),n&&h.length<n)throw new Error("invalid ciphertext length: smaller than tagLength="+n);return a(o.decrypt.length,l),o.decrypt(h,l)}}}return Object.assign(i,e),i};function fn(e,t,i=!0){if(t===void 0)return new Uint8Array(e);if(t.length!==e)throw new Error("invalid output length, expected "+e+", got: "+t.length);if(i&&!nl(t))throw new Error("invalid output, must be aligned");return t}function yn(e,t,i,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,i,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(i>>r&n),a=Number(i&n),c=s?4:0,h=s?0:4;e.setUint32(t+c,o,s),e.setUint32(t+h,a,s)}function nl(e){return e.byteOffset%4===0}function nr(e){return Uint8Array.from(e)}function yi(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const Qo=e=>Uint8Array.from(e.split("").map(t=>t.charCodeAt(0))),ol=Qo("expand 16-byte k"),al=Qo("expand 32-byte k"),cl=_t(ol),hl=_t(al);function F(e,t){return e<<t|e>>>32-t}function or(e){return e.byteOffset%4===0}const is=64,ll=16,Zo=2**32-1,mn=new Uint32Array;function ul(e,t,i,s,r,n,o,a){const c=r.length,h=new Uint8Array(is),l=_t(h),u=or(r)&&or(n),p=u?_t(r):mn,y=u?_t(n):mn;for(let f=0;f<c;o++){if(e(t,i,s,l,o,a),o>=Zo)throw new Error("arx: counter overflow");const m=Math.min(is,c-f);if(u&&m===is){const d=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let g=0,w;g<ll;g++)w=d+g,y[w]=p[w]^l[g];f+=is;continue}for(let d=0,g;d<m;d++)g=f+d,n[g]=r[g]^h[d];f+=m}}function pl(e,t){const{allowShortKeys:i,extendNonceFn:s,counterLength:r,counterRight:n,rounds:o}=il({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return Rs(r),Rs(o),gn(n),gn(i),(a,c,h,l,u=0)=>{qe(a),qe(c),qe(h);const p=h.length;if(l===void 0&&(l=new Uint8Array(p)),qe(l),Rs(u),u<0||u>=Zo)throw new Error("arx: counter overflow");if(l.length<p)throw new Error(`arx: output (${l.length}) is shorter than data (${p})`);const y=[];let f=a.length,m,d;if(f===32)y.push(m=nr(a)),d=hl;else if(f===16&&i)m=new Uint8Array(32),m.set(a),m.set(a,16),d=cl,y.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);or(c)||y.push(c=nr(c));const g=_t(m);if(s){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(d,g,_t(c.subarray(0,16)),g),c=c.subarray(16)}const w=16-r;if(w!==c.length)throw new Error(`arx: nonce must be ${w} or 16 bytes`);if(w!==12){const I=new Uint8Array(12);I.set(c,n?0:12-c.length),c=I,y.push(c)}const E=_t(c);return ul(e,d,g,E,h,l,u,o),yi(...y),l}}const fe=(e,t)=>e[t++]&255|(e[t++]&255)<<8;var dl=class{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=rr(e),qe(e,32);const t=fe(e,0),i=fe(e,2),s=fe(e,4),r=fe(e,6),n=fe(e,8),o=fe(e,10),a=fe(e,12),c=fe(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|i<<3)&8191,this.r[2]=(i>>>10|s<<6)&7939,this.r[3]=(s>>>7|r<<9)&8191,this.r[4]=(r>>>4|n<<12)&255,this.r[5]=n>>>1&8190,this.r[6]=(n>>>14|o<<2)&8191,this.r[7]=(o>>>11|a<<5)&8065,this.r[8]=(a>>>8|c<<8)&8191,this.r[9]=c>>>5&127;for(let h=0;h<8;h++)this.pad[h]=fe(e,16+2*h)}process(e,t,i=!1){const s=i?0:2048,{h:r,r:n}=this,o=n[0],a=n[1],c=n[2],h=n[3],l=n[4],u=n[5],p=n[6],y=n[7],f=n[8],m=n[9],d=fe(e,t+0),g=fe(e,t+2),w=fe(e,t+4),E=fe(e,t+6),I=fe(e,t+8),C=fe(e,t+10),x=fe(e,t+12),O=fe(e,t+14);let v=r[0]+(d&8191),N=r[1]+((d>>>13|g<<3)&8191),k=r[2]+((g>>>10|w<<6)&8191),q=r[3]+((w>>>7|E<<9)&8191),D=r[4]+((E>>>4|I<<12)&8191),j=r[5]+(I>>>1&8191),$=r[6]+((I>>>14|C<<2)&8191),P=r[7]+((C>>>11|x<<5)&8191),S=r[8]+((x>>>8|O<<8)&8191),R=r[9]+(O>>>5|s),_=0,T=_+v*o+N*(5*m)+k*(5*f)+q*(5*y)+D*(5*p);_=T>>>13,T&=8191,T+=j*(5*u)+$*(5*l)+P*(5*h)+S*(5*c)+R*(5*a),_+=T>>>13,T&=8191;let B=_+v*a+N*o+k*(5*m)+q*(5*f)+D*(5*y);_=B>>>13,B&=8191,B+=j*(5*p)+$*(5*u)+P*(5*l)+S*(5*h)+R*(5*c),_+=B>>>13,B&=8191;let z=_+v*c+N*a+k*o+q*(5*m)+D*(5*f);_=z>>>13,z&=8191,z+=j*(5*y)+$*(5*p)+P*(5*u)+S*(5*l)+R*(5*h),_+=z>>>13,z&=8191;let M=_+v*h+N*c+k*a+q*o+D*(5*m);_=M>>>13,M&=8191,M+=j*(5*f)+$*(5*y)+P*(5*p)+S*(5*u)+R*(5*l),_+=M>>>13,M&=8191;let K=_+v*l+N*h+k*c+q*a+D*o;_=K>>>13,K&=8191,K+=j*(5*m)+$*(5*f)+P*(5*y)+S*(5*p)+R*(5*u),_+=K>>>13,K&=8191;let se=_+v*u+N*l+k*h+q*c+D*a;_=se>>>13,se&=8191,se+=j*o+$*(5*m)+P*(5*f)+S*(5*y)+R*(5*p),_+=se>>>13,se&=8191;let ie=_+v*p+N*u+k*l+q*h+D*c;_=ie>>>13,ie&=8191,ie+=j*a+$*o+P*(5*m)+S*(5*f)+R*(5*y),_+=ie>>>13,ie&=8191;let re=_+v*y+N*p+k*u+q*l+D*h;_=re>>>13,re&=8191,re+=j*c+$*a+P*o+S*(5*m)+R*(5*f),_+=re>>>13,re&=8191;let be=_+v*f+N*y+k*p+q*u+D*l;_=be>>>13,be&=8191,be+=j*h+$*c+P*a+S*o+R*(5*m),_+=be>>>13,be&=8191;let oe=_+v*m+N*f+k*y+q*p+D*u;_=oe>>>13,oe&=8191,oe+=j*l+$*h+P*c+S*a+R*o,_+=oe>>>13,oe&=8191,_=(_<<2)+_|0,_=_+T|0,T=_&8191,_=_>>>13,B+=_,r[0]=T,r[1]=B,r[2]=z,r[3]=M,r[4]=K,r[5]=se,r[6]=ie,r[7]=re,r[8]=be,r[9]=oe}finalize(){const{h:e,pad:t}=this,i=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let o=2;o<10;o++)e[o]+=s,s=e[o]>>>13,e[o]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,i[0]=e[0]+5,s=i[0]>>>13,i[0]&=8191;for(let o=1;o<10;o++)i[o]=e[o]+s,s=i[o]>>>13,i[o]&=8191;i[9]-=8192;let r=(s^1)-1;for(let o=0;o<10;o++)i[o]&=r;r=~r;for(let o=0;o<10;o++)e[o]=e[o]&r|i[o];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let n=e[0]+t[0];e[0]=n&65535;for(let o=1;o<8;o++)n=(e[o]+t[o]|0)+(n>>>16)|0,e[o]=n&65535;yi(i)}update(e){dn(this);const{buffer:t,blockLen:i}=this;e=rr(e);const s=e.length;for(let r=0;r<s;){const n=Math.min(i-this.pos,s-r);if(n===i){for(;i<=s-r;r+=i)this.process(e,r);continue}t.set(e.subarray(r,r+n),this.pos),this.pos+=n,r+=n,this.pos===i&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){yi(this.h,this.r,this.buffer,this.pad)}digestInto(e){dn(this),Zh(e,this),this.finished=!0;const{buffer:t,h:i}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let r=0;for(let n=0;n<8;n++)e[r++]=i[n]>>>0,e[r++]=i[n]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}};function gl(e){const t=(s,r)=>e(r).update(rr(s)).digest(),i=e(new Uint8Array(32));return t.outputLen=i.outputLen,t.blockLen=i.blockLen,t.create=s=>e(s),t}const fl=gl(e=>new dl(e));function yl(e,t,i,s,r,n=20){let o=e[0],a=e[1],c=e[2],h=e[3],l=t[0],u=t[1],p=t[2],y=t[3],f=t[4],m=t[5],d=t[6],g=t[7],w=r,E=i[0],I=i[1],C=i[2],x=o,O=a,v=c,N=h,k=l,q=u,D=p,j=y,$=f,P=m,S=d,R=g,_=w,T=E,B=I,z=C;for(let K=0;K<n;K+=2)x=x+k|0,_=F(_^x,16),$=$+_|0,k=F(k^$,12),x=x+k|0,_=F(_^x,8),$=$+_|0,k=F(k^$,7),O=O+q|0,T=F(T^O,16),P=P+T|0,q=F(q^P,12),O=O+q|0,T=F(T^O,8),P=P+T|0,q=F(q^P,7),v=v+D|0,B=F(B^v,16),S=S+B|0,D=F(D^S,12),v=v+D|0,B=F(B^v,8),S=S+B|0,D=F(D^S,7),N=N+j|0,z=F(z^N,16),R=R+z|0,j=F(j^R,12),N=N+j|0,z=F(z^N,8),R=R+z|0,j=F(j^R,7),x=x+q|0,z=F(z^x,16),S=S+z|0,q=F(q^S,12),x=x+q|0,z=F(z^x,8),S=S+z|0,q=F(q^S,7),O=O+D|0,_=F(_^O,16),R=R+_|0,D=F(D^R,12),O=O+D|0,_=F(_^O,8),R=R+_|0,D=F(D^R,7),v=v+j|0,T=F(T^v,16),$=$+T|0,j=F(j^$,12),v=v+j|0,T=F(T^v,8),$=$+T|0,j=F(j^$,7),N=N+k|0,B=F(B^N,16),P=P+B|0,k=F(k^P,12),N=N+k|0,B=F(B^N,8),P=P+B|0,k=F(k^P,7);let M=0;s[M++]=o+x|0,s[M++]=a+O|0,s[M++]=c+v|0,s[M++]=h+N|0,s[M++]=l+k|0,s[M++]=u+q|0,s[M++]=p+D|0,s[M++]=y+j|0,s[M++]=f+$|0,s[M++]=m+P|0,s[M++]=d+S|0,s[M++]=g+R|0,s[M++]=w+_|0,s[M++]=E+T|0,s[M++]=I+B|0,s[M++]=C+z|0}const ml=pl(yl,{counterRight:!1,counterLength:4,allowShortKeys:!1}),wl=new Uint8Array(16),wn=(e,t)=>{e.update(t);const i=t.length%16;i&&e.update(wl.subarray(i))},vl=new Uint8Array(32);function vn(e,t,i,s,r){const n=e(t,i,vl),o=fl.create(n);r&&wn(o,r),wn(o,s);const a=new Uint8Array(16),c=Xh(a);yn(c,0,BigInt(r?r.length:0),!0),yn(c,8,BigInt(s.length),!0),o.update(a);const h=o.digest();return yi(n,a),h}const bl=e=>(t,i,s)=>({encrypt(r,n){const o=r.length;n=fn(o+16,n,!1),n.set(r);const a=n.subarray(0,-16);e(t,i,a,a,1);const c=vn(e,t,i,a,s);return n.set(c,o),yi(c),n},decrypt(r,n){n=fn(r.length-16,n,!1);const o=r.subarray(0,-16),a=r.subarray(-16),c=vn(e,t,i,o,s);if(!sl(a,c))throw new Error("invalid tag");return n.set(r.subarray(0,-16)),e(t,i,n,n,1),yi(c),n}}),Xo=rl({blockSize:64,nonceLength:12,tagLength:16},bl(ml));var ea=class extends qr{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Tr(e);const i=fi(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,r=new Uint8Array(s);r.set(i.length>s?e.create().update(i).digest():i);for(let n=0;n<r.length;n++)r[n]^=54;this.iHash.update(r),this.oHash=e.create();for(let n=0;n<r.length;n++)r[n]^=106;this.oHash.update(r),r.fill(0)}update(e){return gi(this),this.iHash.update(e),this}digestInto(e){gi(this),Wi(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:i,finished:s,destroyed:r,blockLen:n,outputLen:o}=this;return e=e,e.finished=s,e.destroyed=r,e.blockLen=n,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=i._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const Es=(e,t,i)=>new ea(e,t).update(i).digest();Es.create=(e,t)=>new ea(e,t);function $l(e,t,i){return Tr(e),i===void 0&&(i=new Uint8Array(e.outputLen)),Es(e,fi(i),fi(t))}const Ts=new Uint8Array([0]),bn=new Uint8Array;function El(e,t,i,s=32){if(Tr(e),zi(s),s>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const r=Math.ceil(s/e.outputLen);i===void 0&&(i=bn);const n=new Uint8Array(r*e.outputLen),o=Es.create(e,t),a=o._cloneInto(),c=new Uint8Array(o.outputLen);for(let h=0;h<r;h++)Ts[0]=h+1,a.update(h===0?bn:c).update(i).update(Ts).digestInto(c),n.set(c,e.outputLen*h),o._cloneInto(a);return o.destroy(),a.destroy(),c.fill(0),Ts.fill(0),n.slice(0,s)}const _l=(e,t,i,s,r)=>El(e,$l(e,t,i),s,r);function Il(e,t,i,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,i,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(i>>r&n),a=Number(i&n),c=s?4:0,h=s?0:4;e.setUint32(t+c,o,s),e.setUint32(t+h,a,s)}function Pl(e,t,i){return e&t^~e&i}function Sl(e,t,i){return e&t^e&i^t&i}var Ol=class extends qr{constructor(e,t,i,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=i,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Cs(this.buffer)}update(e){gi(this);const{view:t,buffer:i,blockLen:s}=this;e=fi(e);const r=e.length;for(let n=0;n<r;){const o=Math.min(s-this.pos,r-n);if(o===s){const a=Cs(e);for(;s<=r-n;n+=s)this.process(a,n);continue}i.set(e.subarray(n,n+o),this.pos),this.pos+=o,n+=o,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){gi(this),Bo(e,this),this.finished=!0;const{buffer:t,view:i,blockLen:s,isLE:r}=this;let{pos:n}=this;t[n++]=128,this.buffer.subarray(n).fill(0),this.padOffset>s-n&&(this.process(i,0),n=0);for(let l=n;l<s;l++)t[l]=0;Il(i,s-8,BigInt(this.length*8),r),this.process(i,0);const o=Cs(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,h=this.get();if(c>h.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<c;l++)o.setUint32(4*l,h[l],r)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:i,length:s,finished:r,destroyed:n,pos:o}=this;return e.length=s,e.pos=o,e.finished=r,e.destroyed=n,s%t&&e.buffer.set(i),e}};const Al=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),wt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),vt=new Uint32Array(64);var xl=class extends Ol{constructor(){super(64,32,8,!1),this.A=wt[0]|0,this.B=wt[1]|0,this.C=wt[2]|0,this.D=wt[3]|0,this.E=wt[4]|0,this.F=wt[5]|0,this.G=wt[6]|0,this.H=wt[7]|0}get(){const{A:e,B:t,C:i,D:s,E:r,F:n,G:o,H:a}=this;return[e,t,i,s,r,n,o,a]}set(e,t,i,s,r,n,o,a){this.A=e|0,this.B=t|0,this.C=i|0,this.D=s|0,this.E=r|0,this.F=n|0,this.G=o|0,this.H=a|0}process(e,t){for(let l=0;l<16;l++,t+=4)vt[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const u=vt[l-15],p=vt[l-2],y=Ye(u,7)^Ye(u,18)^u>>>3,f=Ye(p,17)^Ye(p,19)^p>>>10;vt[l]=f+vt[l-7]+y+vt[l-16]|0}let{A:i,B:s,C:r,D:n,E:o,F:a,G:c,H:h}=this;for(let l=0;l<64;l++){const u=Ye(o,6)^Ye(o,11)^Ye(o,25),p=h+u+Pl(o,a,c)+Al[l]+vt[l]|0,y=(Ye(i,2)^Ye(i,13)^Ye(i,22))+Sl(i,s,r)|0;h=c,c=a,a=o,o=n+p|0,n=r,r=s,s=i,i=p+y|0}i=i+this.A|0,s=s+this.B|0,r=r+this.C|0,n=n+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,h=h+this.H|0,this.set(i,s,r,n,o,a,c,h)}roundClean(){vt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const Ji=zo(()=>new xl);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _s=BigInt(0),Is=BigInt(1),Nl=BigInt(2);function Mt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Yi(e){if(!Mt(e))throw new Error("Uint8Array expected")}function mi(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}const Cl=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function wi(e){Yi(e);let t="";for(let i=0;i<e.length;i++)t+=Cl[e[i]];return t}function hi(e){const t=e.toString(16);return t.length&1?"0"+t:t}function kr(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?_s:BigInt("0x"+e)}const at={_0:48,_9:57,A:65,F:70,a:97,f:102};function $n(e){if(e>=at._0&&e<=at._9)return e-at._0;if(e>=at.A&&e<=at.F)return e-(at.A-10);if(e>=at.a&&e<=at.f)return e-(at.a-10)}function vi(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length,i=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(i);for(let r=0,n=0;r<i;r++,n+=2){const o=$n(e.charCodeAt(n)),a=$n(e.charCodeAt(n+1));if(o===void 0||a===void 0){const c=e[n]+e[n+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+n)}s[r]=o*16+a}return s}function jt(e){return kr(wi(e))}function Vi(e){return Yi(e),kr(wi(Uint8Array.from(e).reverse()))}function bi(e,t){return vi(e.toString(16).padStart(t*2,"0"))}function Ps(e,t){return bi(e,t).reverse()}function Rl(e){return vi(hi(e))}function Te(e,t,i){let s;if(typeof t=="string")try{s=vi(t)}catch(n){throw new Error(e+" must be hex string or Uint8Array, cause: "+n)}else if(Mt(t))s=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");const r=s.length;if(typeof i=="number"&&r!==i)throw new Error(e+" of length "+i+" expected, got "+r);return s}function Ki(...e){let t=0;for(let s=0;s<e.length;s++){const r=e[s];Yi(r),t+=r.length}const i=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const n=e[s];i.set(n,r),r+=n.length}return i}function Tl(e,t){if(e.length!==t.length)return!1;let i=0;for(let s=0;s<e.length;s++)i|=e[s]^t[s];return i===0}function ql(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const qs=e=>typeof e=="bigint"&&_s<=e;function Ss(e,t,i){return qs(e)&&qs(t)&&qs(i)&&t<=e&&e<i}function pt(e,t,i,s){if(!Ss(t,i,s))throw new Error("expected valid "+e+": "+i+" <= n < "+s+", got "+t)}function ta(e){let t;for(t=0;e>_s;e>>=Is,t+=1);return t}function Dl(e,t){return e>>BigInt(t)&Is}function kl(e,t,i){return e|(i?Is:_s)<<BigInt(t)}const jr=e=>(Nl<<BigInt(e-1))-Is,Ds=e=>new Uint8Array(e),En=e=>Uint8Array.from(e);function ia(e,t,i){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof i!="function")throw new Error("hmacFn must be a function");let s=Ds(e),r=Ds(e),n=0;const o=()=>{s.fill(1),r.fill(0),n=0},a=(...l)=>i(r,s,...l),c=(l=Ds())=>{r=a(En([0]),l),s=a(),l.length!==0&&(r=a(En([1]),l),s=a())},h=()=>{if(n++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const u=[];for(;l<t;){s=a();const p=s.slice();u.push(p),l+=s.length}return Ki(...u)};return(l,u)=>{o(),c(l);let p;for(;!(p=u(h()));)c();return o(),p}}const jl={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||Mt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Pi(e,t,i={}){const s=(r,n,o)=>{const a=jl[n];if(typeof a!="function")throw new Error("invalid validator function");const c=e[r];if(!(o&&c===void 0)&&!a(c,e))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+c)};for(const[r,n]of Object.entries(t))s(r,n,!1);for(const[r,n]of Object.entries(i))s(r,n,!0);return e}const Ul=()=>{throw new Error("not implemented")};function ar(e){const t=new WeakMap;return(i,...s)=>{const r=t.get(i);if(r!==void 0)return r;const n=e(i,...s);return t.set(i,n),n}}var Ml=Object.freeze({__proto__:null,isBytes:Mt,abytes:Yi,abool:mi,bytesToHex:wi,numberToHexUnpadded:hi,hexToNumber:kr,hexToBytes:vi,bytesToNumberBE:jt,bytesToNumberLE:Vi,numberToBytesBE:bi,numberToBytesLE:Ps,numberToVarBytesBE:Rl,ensureBytes:Te,concatBytes:Ki,equalBytes:Tl,utf8ToBytes:ql,inRange:Ss,aInRange:pt,bitLen:ta,bitGet:Dl,bitSet:kl,bitMask:jr,createHmacDrbg:ia,validateObject:Pi,notImplemented:Ul,memoized:ar});const ge=BigInt(0),ne=BigInt(1),Rt=BigInt(2),Ll=BigInt(3),cr=BigInt(4),_n=BigInt(5),In=BigInt(8);function Ae(e,t){const i=e%t;return i>=ge?i:t+i}function sa(e,t,i){if(t<ge)throw new Error("invalid exponent, negatives unsupported");if(i<=ge)throw new Error("invalid modulus");if(i===ne)return ge;let s=ne;for(;t>ge;)t&ne&&(s=s*e%i),e=e*e%i,t>>=ne;return s}function Ge(e,t,i){let s=e;for(;t-- >ge;)s*=s,s%=i;return s}function hr(e,t){if(e===ge)throw new Error("invert: expected non-zero number");if(t<=ge)throw new Error("invert: expected positive modulus, got "+t);let i=Ae(e,t),s=t,r=ge,n=ne;for(;i!==ge;){const o=s/i,a=s%i,c=r-n*o;s=i,i=a,r=n,n=c}if(s!==ne)throw new Error("invert: does not exist");return Ae(r,t)}function Bl(e){const t=(e-ne)/Rt;let i,s,r;for(i=e-ne,s=0;i%Rt===ge;i/=Rt,s++);for(r=Rt;r<e&&sa(r,t,e)!==e-ne;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const o=(e+ne)/cr;return function(a,c){const h=a.pow(c,o);if(!a.eql(a.sqr(h),c))throw new Error("Cannot find square root");return h}}const n=(i+ne)/Rt;return function(o,a){if(o.pow(a,t)===o.neg(o.ONE))throw new Error("Cannot find square root");let c=s,h=o.pow(o.mul(o.ONE,r),i),l=o.pow(a,n),u=o.pow(a,i);for(;!o.eql(u,o.ONE);){if(o.eql(u,o.ZERO))return o.ZERO;let p=1;for(let f=o.sqr(u);p<c&&!o.eql(f,o.ONE);p++)f=o.sqr(f);const y=o.pow(h,ne<<BigInt(c-p-1));h=o.sqr(y),l=o.mul(l,y),u=o.mul(u,h),c=p}return l}}function zl(e){if(e%cr===Ll){const t=(e+ne)/cr;return function(i,s){const r=i.pow(s,t);if(!i.eql(i.sqr(r),s))throw new Error("Cannot find square root");return r}}if(e%In===_n){const t=(e-_n)/In;return function(i,s){const r=i.mul(s,Rt),n=i.pow(r,t),o=i.mul(s,n),a=i.mul(i.mul(o,Rt),n),c=i.mul(o,i.sub(a,i.ONE));if(!i.eql(i.sqr(c),s))throw new Error("Cannot find square root");return c}}return Bl(e)}const Hl=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Vl(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},i=Hl.reduce((s,r)=>(s[r]="function",s),t);return Pi(e,i)}function Kl(e,t,i){if(i<ge)throw new Error("invalid exponent, negatives unsupported");if(i===ge)return e.ONE;if(i===ne)return t;let s=e.ONE,r=t;for(;i>ge;)i&ne&&(s=e.mul(s,r)),r=e.sqr(r),i>>=ne;return s}function Fl(e,t){const i=new Array(t.length),s=t.reduce((n,o,a)=>e.is0(o)?n:(i[a]=n,e.mul(n,o)),e.ONE),r=e.inv(s);return t.reduceRight((n,o,a)=>e.is0(o)?n:(i[a]=e.mul(n,i[a]),e.mul(n,o)),r),i}function ra(e,t){const i=t!==void 0?t:e.toString(2).length,s=Math.ceil(i/8);return{nBitLength:i,nByteLength:s}}function na(e,t,i=!1,s={}){if(e<=ge)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:r,nByteLength:n}=ra(e,t);if(n>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:e,isLE:i,BITS:r,BYTES:n,MASK:jr(r),ZERO:ge,ONE:ne,create:c=>Ae(c,e),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return ge<=c&&c<e},is0:c=>c===ge,isOdd:c=>(c&ne)===ne,neg:c=>Ae(-c,e),eql:(c,h)=>c===h,sqr:c=>Ae(c*c,e),add:(c,h)=>Ae(c+h,e),sub:(c,h)=>Ae(c-h,e),mul:(c,h)=>Ae(c*h,e),pow:(c,h)=>Kl(a,c,h),div:(c,h)=>Ae(c*hr(h,e),e),sqrN:c=>c*c,addN:(c,h)=>c+h,subN:(c,h)=>c-h,mulN:(c,h)=>c*h,inv:c=>hr(c,e),sqrt:s.sqrt||(c=>(o||(o=zl(e)),o(a,c))),invertBatch:c=>Fl(a,c),cmov:(c,h,l)=>l?h:c,toBytes:c=>i?Ps(c,n):bi(c,n),fromBytes:c=>{if(c.length!==n)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+c.length);return i?Vi(c):jt(c)}});return Object.freeze(a)}function oa(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function aa(e){const t=oa(e);return t+Math.ceil(t/2)}function Gl(e,t,i=!1){const s=e.length,r=oa(t),n=aa(t);if(s<16||s<n||s>1024)throw new Error("expected "+n+"-1024 bytes of input, got "+s);const o=i?Vi(e):jt(e),a=Ae(o,t-ne)+ne;return i?Ps(a,r):bi(a,r)}const Pn=BigInt(0),ss=BigInt(1);function ks(e,t){const i=t.negate();return e?i:t}function ca(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function js(e,t){ca(e,t);const i=Math.ceil(t/e)+1,s=2**(e-1);return{windows:i,windowSize:s}}function Wl(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((i,s)=>{if(!(i instanceof t))throw new Error("invalid point at index "+s)})}function Jl(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((i,s)=>{if(!t.isValid(i))throw new Error("invalid scalar at index "+s)})}const Us=new WeakMap,ha=new WeakMap;function Ms(e){return ha.get(e)||1}function Yl(e,t){return{constTimeNegate:ks,hasPrecomputes(i){return Ms(i)!==1},unsafeLadder(i,s,r=e.ZERO){let n=i;for(;s>Pn;)s&ss&&(r=r.add(n)),n=n.double(),s>>=ss;return r},precomputeWindow(i,s){const{windows:r,windowSize:n}=js(s,t),o=[];let a=i,c=a;for(let h=0;h<r;h++){c=a,o.push(c);for(let l=1;l<n;l++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(i,s,r){const{windows:n,windowSize:o}=js(i,t);let a=e.ZERO,c=e.BASE;const h=BigInt(2**i-1),l=2**i,u=BigInt(i);for(let p=0;p<n;p++){const y=p*o;let f=Number(r&h);r>>=u,f>o&&(f-=l,r+=ss);const m=y,d=y+Math.abs(f)-1,g=p%2!==0,w=f<0;f===0?c=c.add(ks(g,s[m])):a=a.add(ks(w,s[d]))}return{p:a,f:c}},wNAFUnsafe(i,s,r,n=e.ZERO){const{windows:o,windowSize:a}=js(i,t),c=BigInt(2**i-1),h=2**i,l=BigInt(i);for(let u=0;u<o;u++){const p=u*a;if(r===Pn)break;let y=Number(r&c);if(r>>=l,y>a&&(y-=h,r+=ss),y===0)continue;let f=s[p+Math.abs(y)-1];y<0&&(f=f.negate()),n=n.add(f)}return n},getPrecomputes(i,s,r){let n=Us.get(s);return n||(n=this.precomputeWindow(s,i),i!==1&&Us.set(s,r(n))),n},wNAFCached(i,s,r){const n=Ms(i);return this.wNAF(n,this.getPrecomputes(n,i,r),s)},wNAFCachedUnsafe(i,s,r,n){const o=Ms(i);return o===1?this.unsafeLadder(i,s,n):this.wNAFUnsafe(o,this.getPrecomputes(o,i,r),s,n)},setWindowSize(i,s){ca(s,t),ha.set(i,s),Us.delete(i)}}}function Ql(e,t,i,s){if(Wl(i,e),Jl(s,t),i.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=e.ZERO,n=ta(BigInt(i.length)),o=n>12?n-3:n>4?n-2:n?2:1,a=(1<<o)-1,c=new Array(a+1).fill(r),h=Math.floor((t.BITS-1)/o)*o;let l=r;for(let u=h;u>=0;u-=o){c.fill(r);for(let y=0;y<s.length;y++){const f=s[y],m=Number(f>>BigInt(u)&BigInt(a));c[m]=c[m].add(i[y])}let p=r;for(let y=c.length-1,f=r;y>0;y--)f=f.add(c[y]),p=p.add(f);if(l=l.add(p),u!==0)for(let y=0;y<o;y++)l=l.double()}return l}function la(e){return Vl(e.Fp),Pi(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ra(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const Gt=BigInt(0),Ls=BigInt(1);function Zl(e){return Pi(e,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...e})}function Xl(e){const t=Zl(e),{P:i}=t,s=w=>Ae(w,i),r=t.montgomeryBits,n=Math.ceil(r/8),o=t.nByteLength,a=t.adjustScalarBytes||(w=>w),c=t.powPminus2||(w=>sa(w,i-BigInt(2),i));function h(w,E,I){const C=s(w*(E-I));return E=s(E-C),I=s(I+C),[E,I]}const l=(t.a-BigInt(2))/BigInt(4);function u(w,E){pt("u",w,Gt,i),pt("scalar",E,Gt,i);const I=E,C=w;let x=Ls,O=Gt,v=w,N=Ls,k=Gt,q;for(let j=BigInt(r-1);j>=Gt;j--){const $=I>>j&Ls;k^=$,q=h(k,x,v),x=q[0],v=q[1],q=h(k,O,N),O=q[0],N=q[1],k=$;const P=x+O,S=s(P*P),R=x-O,_=s(R*R),T=S-_,B=v+N,z=v-N,M=s(z*P),K=s(B*R),se=M+K,ie=M-K;v=s(se*se),N=s(C*s(ie*ie)),x=s(S*_),O=s(T*(S+s(l*T)))}q=h(k,x,v),x=q[0],v=q[1],q=h(k,O,N),O=q[0],N=q[1];const D=c(O);return s(x*D)}function p(w){return Ps(s(w),n)}function y(w){const E=Te("u coordinate",w,n);return o===32&&(E[31]&=127),Vi(E)}function f(w){const E=Te("scalar",w),I=E.length;if(I!==n&&I!==o){let C=""+n+" or "+o;throw new Error("invalid scalar, expected "+C+" bytes, got "+I)}return Vi(a(E))}function m(w,E){const I=y(E),C=f(w),x=u(I,C);if(x===Gt)throw new Error("invalid private or public key received");return p(x)}const d=p(t.Gu);function g(w){return m(w,d)}return{scalarMult:m,scalarMultBase:g,getSharedSecret:(w,E)=>m(w,E),getPublicKey:w=>g(w),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:d}}const lr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const eu=BigInt(1),Sn=BigInt(2),tu=BigInt(3),iu=BigInt(5);BigInt(8);function su(e){const t=BigInt(10),i=BigInt(20),s=BigInt(40),r=BigInt(80),n=lr,o=e*e%n*e%n,a=Ge(o,Sn,n)*o%n,c=Ge(a,eu,n)*e%n,h=Ge(c,iu,n)*c%n,l=Ge(h,t,n)*h%n,u=Ge(l,i,n)*l%n,p=Ge(u,s,n)*u%n,y=Ge(p,r,n)*p%n,f=Ge(y,r,n)*p%n,m=Ge(f,t,n)*h%n;return{pow_p_5_8:Ge(m,Sn,n)*e%n,b2:o}}function ru(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const ur=Xl({P:lr,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:e=>{const t=lr,{pow_p_5_8:i,b2:s}=su(e);return Ae(Ge(i,tu,t)*s,t)},adjustScalarBytes:ru,randomBytes:Ii});function On(e){e.lowS!==void 0&&mi("lowS",e.lowS),e.prehash!==void 0&&mi("prehash",e.prehash)}function nu(e){const t=la(e);Pi(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:i,Fp:s,a:r}=t;if(i){if(!s.eql(r,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof i!="object"||typeof i.beta!="bigint"||typeof i.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:ou,hexToBytes:au}=Ml;var cu=class extends Error{constructor(e=""){super(e)}};const lt={Err:cu,_tlv:{encode:(e,t)=>{const{Err:i}=lt;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length&1)throw new i("tlv.encode: unpadded data");const s=t.length/2,r=hi(s);if(r.length/2&128)throw new i("tlv.encode: long form length too big");const n=s>127?hi(r.length/2|128):"";return hi(e)+n+r+t},decode(e,t){const{Err:i}=lt;let s=0;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length<2||t[s++]!==e)throw new i("tlv.decode: wrong tlv");const r=t[s++],n=!!(r&128);let o=0;if(!n)o=r;else{const c=r&127;if(!c)throw new i("tlv.decode(long): indefinite length not supported");if(c>4)throw new i("tlv.decode(long): byte length is too big");const h=t.subarray(s,s+c);if(h.length!==c)throw new i("tlv.decode: length bytes not complete");if(h[0]===0)throw new i("tlv.decode(long): zero leftmost byte");for(const l of h)o=o<<8|l;if(s+=c,o<128)throw new i("tlv.decode(long): not minimal encoding")}const a=t.subarray(s,s+o);if(a.length!==o)throw new i("tlv.decode: wrong value length");return{v:a,l:t.subarray(s+o)}}},_int:{encode(e){const{Err:t}=lt;if(e<ut)throw new t("integer: negative integers are not allowed");let i=hi(e);if(Number.parseInt(i[0],16)&8&&(i="00"+i),i.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return i},decode(e){const{Err:t}=lt;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return ou(e)}},toSig(e){const{Err:t,_int:i,_tlv:s}=lt,r=typeof e=="string"?au(e):e;Yi(r);const{v:n,l:o}=s.decode(48,r);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=s.decode(2,n),{v:h,l}=s.decode(2,c);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:i.decode(a),s:i.decode(h)}},hexFromSig(e){const{_tlv:t,_int:i}=lt,s=t.encode(2,i.encode(e.r)),r=t.encode(2,i.encode(e.s)),n=s+r;return t.encode(48,n)}},ut=BigInt(0),pe=BigInt(1);BigInt(2);const An=BigInt(3);BigInt(4);function hu(e){const t=nu(e),{Fp:i}=t,s=na(t.n,t.nBitLength),r=t.toBytes||((m,d,g)=>{const w=d.toAffine();return Ki(Uint8Array.from([4]),i.toBytes(w.x),i.toBytes(w.y))}),n=t.fromBytes||(m=>{const d=m.subarray(1),g=i.fromBytes(d.subarray(0,i.BYTES)),w=i.fromBytes(d.subarray(i.BYTES,2*i.BYTES));return{x:g,y:w}});function o(m){const{a:d,b:g}=t,w=i.sqr(m),E=i.mul(w,m);return i.add(i.add(E,i.mul(m,d)),g)}if(!i.eql(i.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function a(m){return Ss(m,pe,t.n)}function c(m){const{allowedPrivateKeyLengths:d,nByteLength:g,wrapPrivateKey:w,n:E}=t;if(d&&typeof m!="bigint"){if(Mt(m)&&(m=wi(m)),typeof m!="string"||!d.includes(m.length))throw new Error("invalid private key");m=m.padStart(g*2,"0")}let I;try{I=typeof m=="bigint"?m:jt(Te("private key",m,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof m)}return w&&(I=Ae(I,E)),pt("private key",I,pe,E),I}function h(m){if(!(m instanceof p))throw new Error("ProjectivePoint expected")}const l=ar((m,d)=>{const{px:g,py:w,pz:E}=m;if(i.eql(E,i.ONE))return{x:g,y:w};const I=m.is0();d??(d=I?i.ONE:i.inv(E));const C=i.mul(g,d),x=i.mul(w,d),O=i.mul(E,d);if(I)return{x:i.ZERO,y:i.ZERO};if(!i.eql(O,i.ONE))throw new Error("invZ was invalid");return{x:C,y:x}}),u=ar(m=>{if(m.is0()){if(t.allowInfinityPoint&&!i.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:d,y:g}=m.toAffine();if(!i.isValid(d)||!i.isValid(g))throw new Error("bad point: x or y not FE");const w=i.sqr(g),E=o(d);if(!i.eql(w,E))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(d,g,w){if(this.px=d,this.py=g,this.pz=w,d==null||!i.isValid(d))throw new Error("x required");if(g==null||!i.isValid(g))throw new Error("y required");if(w==null||!i.isValid(w))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:g,y:w}=d||{};if(!d||!i.isValid(g)||!i.isValid(w))throw new Error("invalid affine point");if(d instanceof p)throw new Error("projective point not allowed");const E=I=>i.eql(I,i.ZERO);return E(g)&&E(w)?p.ZERO:new p(g,w,i.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const g=i.invertBatch(d.map(w=>w.pz));return d.map((w,E)=>w.toAffine(g[E])).map(p.fromAffine)}static fromHex(d){const g=p.fromAffine(n(Te("pointHex",d)));return g.assertValidity(),g}static fromPrivateKey(d){return p.BASE.multiply(c(d))}static msm(d,g){return Ql(p,s,d,g)}_setWindowSize(d){f.setWindowSize(this,d)}assertValidity(){u(this)}hasEvenY(){const{y:d}=this.toAffine();if(i.isOdd)return!i.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){h(d);const{px:g,py:w,pz:E}=this,{px:I,py:C,pz:x}=d,O=i.eql(i.mul(g,x),i.mul(I,E)),v=i.eql(i.mul(w,x),i.mul(C,E));return O&&v}negate(){return new p(this.px,i.neg(this.py),this.pz)}double(){const{a:d,b:g}=t,w=i.mul(g,An),{px:E,py:I,pz:C}=this;let x=i.ZERO,O=i.ZERO,v=i.ZERO,N=i.mul(E,E),k=i.mul(I,I),q=i.mul(C,C),D=i.mul(E,I);return D=i.add(D,D),v=i.mul(E,C),v=i.add(v,v),x=i.mul(d,v),O=i.mul(w,q),O=i.add(x,O),x=i.sub(k,O),O=i.add(k,O),O=i.mul(x,O),x=i.mul(D,x),v=i.mul(w,v),q=i.mul(d,q),D=i.sub(N,q),D=i.mul(d,D),D=i.add(D,v),v=i.add(N,N),N=i.add(v,N),N=i.add(N,q),N=i.mul(N,D),O=i.add(O,N),q=i.mul(I,C),q=i.add(q,q),N=i.mul(q,D),x=i.sub(x,N),v=i.mul(q,k),v=i.add(v,v),v=i.add(v,v),new p(x,O,v)}add(d){h(d);const{px:g,py:w,pz:E}=this,{px:I,py:C,pz:x}=d;let O=i.ZERO,v=i.ZERO,N=i.ZERO;const k=t.a,q=i.mul(t.b,An);let D=i.mul(g,I),j=i.mul(w,C),$=i.mul(E,x),P=i.add(g,w),S=i.add(I,C);P=i.mul(P,S),S=i.add(D,j),P=i.sub(P,S),S=i.add(g,E);let R=i.add(I,x);return S=i.mul(S,R),R=i.add(D,$),S=i.sub(S,R),R=i.add(w,E),O=i.add(C,x),R=i.mul(R,O),O=i.add(j,$),R=i.sub(R,O),N=i.mul(k,S),O=i.mul(q,$),N=i.add(O,N),O=i.sub(j,N),N=i.add(j,N),v=i.mul(O,N),j=i.add(D,D),j=i.add(j,D),$=i.mul(k,$),S=i.mul(q,S),j=i.add(j,$),$=i.sub(D,$),$=i.mul(k,$),S=i.add(S,$),D=i.mul(j,S),v=i.add(v,D),D=i.mul(R,S),O=i.mul(P,O),O=i.sub(O,D),D=i.mul(P,j),N=i.mul(R,N),N=i.add(N,D),new p(O,v,N)}subtract(d){return this.add(d.negate())}is0(){return this.equals(p.ZERO)}wNAF(d){return f.wNAFCached(this,d,p.normalizeZ)}multiplyUnsafe(d){const{endo:g,n:w}=t;pt("scalar",d,ut,w);const E=p.ZERO;if(d===ut)return E;if(this.is0()||d===pe)return this;if(!g||f.hasPrecomputes(this))return f.wNAFCachedUnsafe(this,d,p.normalizeZ);let{k1neg:I,k1:C,k2neg:x,k2:O}=g.splitScalar(d),v=E,N=E,k=this;for(;C>ut||O>ut;)C&pe&&(v=v.add(k)),O&pe&&(N=N.add(k)),k=k.double(),C>>=pe,O>>=pe;return I&&(v=v.negate()),x&&(N=N.negate()),N=new p(i.mul(N.px,g.beta),N.py,N.pz),v.add(N)}multiply(d){const{endo:g,n:w}=t;pt("scalar",d,pe,w);let E,I;if(g){const{k1neg:C,k1:x,k2neg:O,k2:v}=g.splitScalar(d);let{p:N,f:k}=this.wNAF(x),{p:q,f:D}=this.wNAF(v);N=f.constTimeNegate(C,N),q=f.constTimeNegate(O,q),q=new p(i.mul(q.px,g.beta),q.py,q.pz),E=N.add(q),I=k.add(D)}else{const{p:C,f:x}=this.wNAF(d);E=C,I=x}return p.normalizeZ([E,I])[0]}multiplyAndAddUnsafe(d,g,w){const E=p.BASE,I=(x,O)=>O===ut||O===pe||!x.equals(E)?x.multiplyUnsafe(O):x.multiply(O),C=I(this,g).add(I(d,w));return C.is0()?void 0:C}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:g}=t;if(d===pe)return!0;if(g)return g(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:g}=t;return d===pe?this:g?g(p,this):this.multiplyUnsafe(t.h)}toRawBytes(d=!0){return mi("isCompressed",d),this.assertValidity(),r(p,this,d)}toHex(d=!0){return mi("isCompressed",d),wi(this.toRawBytes(d))}}p.BASE=new p(t.Gx,t.Gy,i.ONE),p.ZERO=new p(i.ZERO,i.ONE,i.ZERO);const y=t.nBitLength,f=Yl(p,t.endo?Math.ceil(y/2):y);return{CURVE:t,ProjectivePoint:p,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function lu(e){const t=la(e);return Pi(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function uu(e){const t=lu(e),{Fp:i,n:s}=t,r=i.BYTES+1,n=2*i.BYTES+1;function o($){return Ae($,s)}function a($){return hr($,s)}const{ProjectivePoint:c,normPrivateKeyToScalar:h,weierstrassEquation:l,isWithinCurveOrder:u}=hu({...t,toBytes($,P,S){const R=P.toAffine(),_=i.toBytes(R.x),T=Ki;return mi("isCompressed",S),S?T(Uint8Array.from([P.hasEvenY()?2:3]),_):T(Uint8Array.from([4]),_,i.toBytes(R.y))},fromBytes($){const P=$.length,S=$[0],R=$.subarray(1);if(P===r&&(S===2||S===3)){const _=jt(R);if(!Ss(_,pe,i.ORDER))throw new Error("Point is not on curve");const T=l(_);let B;try{B=i.sqrt(T)}catch(M){const K=M instanceof Error?": "+M.message:"";throw new Error("Point is not on curve"+K)}const z=(B&pe)===pe;return(S&1)===1!==z&&(B=i.neg(B)),{x:_,y:B}}else if(P===n&&S===4){const _=i.fromBytes(R.subarray(0,i.BYTES)),T=i.fromBytes(R.subarray(i.BYTES,2*i.BYTES));return{x:_,y:T}}else{const _=r,T=n;throw new Error("invalid Point, expected length of "+_+", or uncompressed "+T+", got "+P)}}}),p=$=>wi(bi($,t.nByteLength));function y($){const P=s>>pe;return $>P}function f($){return y($)?o(-$):$}const m=($,P,S)=>jt($.slice(P,S));class d{constructor(P,S,R){this.r=P,this.s=S,this.recovery=R,this.assertValidity()}static fromCompact(P){const S=t.nByteLength;return P=Te("compactSignature",P,S*2),new d(m(P,0,S),m(P,S,2*S))}static fromDER(P){const{r:S,s:R}=lt.toSig(Te("DER",P));return new d(S,R)}assertValidity(){pt("r",this.r,pe,s),pt("s",this.s,pe,s)}addRecoveryBit(P){return new d(this.r,this.s,P)}recoverPublicKey(P){const{r:S,s:R,recovery:_}=this,T=x(Te("msgHash",P));if(_==null||![0,1,2,3].includes(_))throw new Error("recovery id invalid");const B=_===2||_===3?S+t.n:S;if(B>=i.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=(_&1)===0?"02":"03",M=c.fromHex(z+p(B)),K=a(B),se=o(-T*K),ie=o(R*K),re=c.BASE.multiplyAndAddUnsafe(M,se,ie);if(!re)throw new Error("point at infinify");return re.assertValidity(),re}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return vi(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return vi(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const g={isValidPrivateKey($){try{return h($),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const $=aa(t.n);return Gl(t.randomBytes($),t.n)},precompute($=8,P=c.BASE){return P._setWindowSize($),P.multiply(BigInt(3)),P}};function w($,P=!0){return c.fromPrivateKey($).toRawBytes(P)}function E($){const P=Mt($),S=typeof $=="string",R=(P||S)&&$.length;return P?R===r||R===n:S?R===2*r||R===2*n:$ instanceof c}function I($,P,S=!0){if(E($))throw new Error("first arg must be private key");if(!E(P))throw new Error("second arg must be public key");return c.fromHex(P).multiply(h($)).toRawBytes(S)}const C=t.bits2int||function($){if($.length>8192)throw new Error("input is too large");const P=jt($),S=$.length*8-t.nBitLength;return S>0?P>>BigInt(S):P},x=t.bits2int_modN||function($){return o(C($))},O=jr(t.nBitLength);function v($){return pt("num < 2^"+t.nBitLength,$,ut,O),bi($,t.nByteLength)}function N($,P,S=k){if(["recovered","canonical"].some(oe=>oe in S))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:_}=t;let{lowS:T,prehash:B,extraEntropy:z}=S;T??(T=!0),$=Te("msgHash",$),On(S),B&&($=Te("prehashed msgHash",R($)));const M=x($),K=h(P),se=[v(K),v(M)];if(z!=null&&z!==!1){const oe=z===!0?_(i.BYTES):z;se.push(Te("extraEntropy",oe))}const ie=Ki(...se),re=M;function be(oe){const nt=C(oe);if(!u(nt))return;const gt=a(nt),ft=c.BASE.multiply(nt).toAffine(),yt=o(ft.x);if(yt===ut)return;const He=o(gt*o(re+yt*K));if(He===ut)return;let At=(ft.x===yt?0:2)|Number(ft.y&pe),Hr=He;return T&&y(He)&&(Hr=f(He),At^=1),new d(yt,Hr,At)}return{seed:ie,k2sig:be}}const k={lowS:t.lowS,prehash:!1},q={lowS:t.lowS,prehash:!1};function D($,P,S=k){const{seed:R,k2sig:_}=N($,P,S),T=t;return ia(T.hash.outputLen,T.nByteLength,T.hmac)(R,_)}c.BASE._setWindowSize(8);function j($,P,S,R=q){var _;const T=$;P=Te("msgHash",P),S=Te("publicKey",S);const{lowS:B,prehash:z,format:M}=R;if(On(R),"strict"in R)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const K=typeof T=="string"||Mt(T),se=!K&&!M&&typeof T=="object"&&T!==null&&typeof T.r=="bigint"&&typeof T.s=="bigint";if(!K&&!se)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let ie,re;try{if(se&&(ie=new d(T.r,T.s)),K){try{M!=="compact"&&(ie=d.fromDER(T))}catch(At){if(!(At instanceof lt.Err))throw At}!ie&&M!=="der"&&(ie=d.fromCompact(T))}re=c.fromHex(S)}catch{return!1}if(!ie||B&&ie.hasHighS())return!1;z&&(P=t.hash(P));const{r:be,s:oe}=ie,nt=x(P),gt=a(oe),ft=o(nt*gt),yt=o(be*gt),He=(_=c.BASE.multiplyAndAddUnsafe(re,ft,yt))===null||_===void 0?void 0:_.toAffine();return He?o(He.x)===be:!1}return{CURVE:t,getPublicKey:w,getSharedSecret:I,sign:D,verify:j,ProjectivePoint:c,Signature:d,utils:g}}function pu(e){return{hash:e,hmac:(t,...i)=>Es(e,t,yh(...i)),randomBytes:Ii}}function du(e,t){const i=s=>uu({...e,...pu(s)});return{...i(t),create:i}}const ua=na(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),gu=ua.create(BigInt("-3")),fu=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),yu=du({a:gu,b:fu,Fp:ua,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},Ji),pa="base10",Ie="base16",We="base64pad",$t="base64url",Qi="utf8",da=0,dt=1,Zi=2,mu=0,xn=1,Mi=12,Ur=32;function wu(){const e=ur.utils.randomPrivateKey(),t=ur.getPublicKey(e);return{privateKey:Ne(e,Ie),publicKey:Ne(t,Ie)}}function pr(){const e=Ii(Ur);return Ne(e,Ie)}function vu(e,t){const i=ur.getSharedSecret(Le(e,Ie),Le(t,Ie)),s=_l(Ji,i,void 0,void 0,Ur);return Ne(s,Ie)}function us(e){const t=Ji(Le(e,Ie));return Ne(t,Ie)}function tt(e){const t=Ji(Le(e,Qi));return Ne(t,Ie)}function ga(e){return Le(`${e}`,pa)}function Lt(e){return Number(Ne(e,pa))}function fa(e){return e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function ya(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),i=(4-t.length%4)%4;return t+"=".repeat(i)}function bu(e){const t=ga(typeof e.type<"u"?e.type:da);if(Lt(t)===dt&&typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const i=typeof e.senderPublicKey<"u"?Le(e.senderPublicKey,Ie):void 0,s=typeof e.iv<"u"?Le(e.iv,Ie):Ii(Mi),r=Le(e.symKey,Ie),n=Xo(r,s).encrypt(Le(e.message,Qi)),o=ma({type:t,sealed:n,iv:s,senderPublicKey:i});return e.encoding===$t?fa(o):o}function $u(e){const t=Le(e.symKey,Ie),{sealed:i,iv:s}=Fi({encoded:e.encoded,encoding:e.encoding}),r=Xo(t,s).decrypt(i);if(r===null)throw new Error("Failed to decrypt");return Ne(r,Qi)}function Eu(e,t){const i=ga(Zi),s=Ii(Mi),r=Le(e,Qi),n=ma({type:i,sealed:r,iv:s});return t===$t?fa(n):n}function _u(e,t){const{sealed:i}=Fi({encoded:e,encoding:t});return Ne(i,Qi)}function ma(e){if(Lt(e.type)===Zi)return Ne(Ui([e.type,e.sealed]),We);if(Lt(e.type)===dt){if(typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return Ne(Ui([e.type,e.senderPublicKey,e.iv,e.sealed]),We)}return Ne(Ui([e.type,e.iv,e.sealed]),We)}function Fi(e){const t=(e.encoding||We)===$t?ya(e.encoded):e.encoded,i=Le(t,We),s=i.slice(mu,xn),r=xn;if(Lt(s)===dt){const c=r+Ur,h=c+Mi,l=i.slice(r,c),u=i.slice(c,h),p=i.slice(h);return{type:s,sealed:p,iv:u,senderPublicKey:l}}if(Lt(s)===Zi){const c=i.slice(r),h=Ii(Mi);return{type:s,sealed:c,iv:h}}const n=r+Mi,o=i.slice(r,n),a=i.slice(n);return{type:s,sealed:a,iv:o}}function Iu(e,t){const i=Fi({encoded:e,encoding:t==null?void 0:t.encoding});return wa({type:Lt(i.type),senderPublicKey:typeof i.senderPublicKey<"u"?Ne(i.senderPublicKey,Ie):void 0,receiverPublicKey:t==null?void 0:t.receiverPublicKey})}function wa(e){const t=(e==null?void 0:e.type)||da;if(t===dt){if(typeof(e==null?void 0:e.senderPublicKey)>"u")throw new Error("missing sender public key");if(typeof(e==null?void 0:e.receiverPublicKey)>"u")throw new Error("missing receiver public key")}return{type:t,senderPublicKey:e==null?void 0:e.senderPublicKey,receiverPublicKey:e==null?void 0:e.receiverPublicKey}}function Nn(e){return e.type===dt&&typeof e.senderPublicKey=="string"&&typeof e.receiverPublicKey=="string"}function Cn(e){return e.type===Zi}function Pu(e){const t=Ee.from(e.x,"base64"),i=Ee.from(e.y,"base64");return Ui([new Uint8Array([4]),t,i])}function Su(e,t){const[i,s,r]=e.split("."),n=Ee.from(ya(r),"base64");if(n.length!==64)throw new Error("Invalid signature length");const o=n.slice(0,32),a=n.slice(32,64),c=`${i}.${s}`,h=Ji(c),l=Pu(t);if(!yu.verify(Ui([o,a]),h,l))throw new Error("Invalid signature");return er(e).payload}const Ou="irn";function ys(e){return(e==null?void 0:e.relay)||{protocol:Ou}}function Di(e){const t=tc[e];if(typeof t>"u")throw new Error(`Relay Protocol not supported: ${e}`);return t}function Au(e,t="-"){const i={},s="relay"+t;return Object.keys(e).forEach(r=>{if(r.startsWith(s)){const n=r.replace(s,""),o=e[r];i[n]=o}}),i}function Rn(e){if(!e.includes("wc:")){const h=Lo(e);h!=null&&h.includes("wc:")&&(e=h)}e=e.includes("wc://")?e.replace("wc://",""):e,e=e.includes("wc:")?e.replace("wc:",""):e;const t=e.indexOf(":"),i=e.indexOf("?")!==-1?e.indexOf("?"):void 0,s=e.substring(0,t),r=e.substring(t+1,i).split("@"),n=typeof i<"u"?e.substring(i):"",o=new URLSearchParams(n),a={};o.forEach((h,l)=>{a[l]=h});const c=typeof a.methods=="string"?a.methods.split(","):void 0;return{protocol:s,topic:xu(r[0]),version:parseInt(r[1],10),symKey:a.symKey,relay:Au(a),methods:c,expiryTimestamp:a.expiryTimestamp?parseInt(a.expiryTimestamp,10):void 0}}function xu(e){return e.startsWith("//")?e.substring(2):e}function Nu(e,t="-"){const i="relay",s={};return Object.keys(e).forEach(r=>{const n=r,o=i+t+n;e[n]&&(s[o]=e[n])}),s}function Tn(e){const t=new URLSearchParams,i=Nu(e.relay);Object.keys(i).sort().forEach(r=>{t.set(r,i[r])}),t.set("symKey",e.symKey),e.expiryTimestamp&&t.set("expiryTimestamp",e.expiryTimestamp.toString()),e.methods&&t.set("methods",e.methods.join(","));const s=t.toString();return`${e.protocol}:${e.topic}@${e.version}?${s}`}function rs(e,t,i){return`${e}?wc_ev=${i}&topic=${t}`}var Cu=Object.defineProperty,Ru=Object.defineProperties,Tu=Object.getOwnPropertyDescriptors,qn=Object.getOwnPropertySymbols,qu=Object.prototype.hasOwnProperty,Du=Object.prototype.propertyIsEnumerable,Dn=(e,t,i)=>t in e?Cu(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ku=(e,t)=>{for(var i in t||(t={}))qu.call(t,i)&&Dn(e,i,t[i]);if(qn)for(var i of qn(t))Du.call(t,i)&&Dn(e,i,t[i]);return e},ju=(e,t)=>Ru(e,Tu(t));function Si(e){const t=[];return e.forEach(i=>{const[s,r]=i.split(":");t.push(`${s}:${r}`)}),t}function Uu(e){const t=[];return Object.values(e).forEach(i=>{t.push(...Si(i.accounts))}),t}function Mu(e,t){const i=[];return Object.values(e).forEach(s=>{Si(s.accounts).includes(t)&&i.push(...s.methods)}),i}function Lu(e,t){const i=[];return Object.values(e).forEach(s=>{Si(s.accounts).includes(t)&&i.push(...s.events)}),i}function Os(e){return e.includes(":")}function li(e){return Os(e)?e.split(":")[0]:e}function kn(e){var t,i,s;const r={};if(!Pt(e))return r;for(const[n,o]of Object.entries(e)){const a=Os(n)?[n]:o.chains,c=o.methods||[],h=o.events||[],l=li(n);r[l]=ju(ku({},r[l]),{chains:it(a,(t=r[l])==null?void 0:t.chains),methods:it(c,(i=r[l])==null?void 0:i.methods),events:it(h,(s=r[l])==null?void 0:s.events)})}return r}function Bu(e){const t={};return e==null||e.forEach(i=>{var s;const[r,n]=i.split(":");t[r]||(t[r]={accounts:[],chains:[],events:[],methods:[]}),t[r].accounts.push(i),(s=t[r].chains)==null||s.push(`${r}:${n}`)}),t}function jn(e,t){t=t.map(s=>s.replace("did:pkh:",""));const i=Bu(t);for(const[s,r]of Object.entries(i))r.methods?r.methods=it(r.methods,e):r.methods=e,r.events=["chainChanged","accountsChanged"];return i}function zu(e,t){var i,s,r,n,o,a;const c=kn(e),h=kn(t),l={},u=Object.keys(c).concat(Object.keys(h));for(const p of u)l[p]={chains:it((i=c[p])==null?void 0:i.chains,(s=h[p])==null?void 0:s.chains),methods:it((r=c[p])==null?void 0:r.methods,(n=h[p])==null?void 0:n.methods),events:it((o=c[p])==null?void 0:o.events,(a=h[p])==null?void 0:a.events)};return l}const Hu={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},Vu={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function A(e,t){const{message:i,code:s}=Vu[e];return{message:t?`${i} ${t}`:i,code:s}}function Q(e,t){const{message:i,code:s}=Hu[e];return{message:t?`${i} ${t}`:i,code:s}}function It(e,t){return Array.isArray(e)?typeof t<"u"&&e.length?e.every(t):!0:!1}function Pt(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function we(e){return typeof e>"u"}function ce(e,t){return t&&we(e)?!0:typeof e=="string"&&!!e.trim().length}function Mr(e,t){return t&&we(e)?!0:typeof e=="number"&&!isNaN(e)}function Ku(e,t){const{requiredNamespaces:i}=t,s=Object.keys(e.namespaces),r=Object.keys(i);let n=!0;return kt(r,s)?(s.forEach(o=>{const{accounts:a,methods:c,events:h}=e.namespaces[o],l=Si(a),u=i[o];(!kt(Do(o,u),l)||!kt(u.methods,c)||!kt(u.events,h))&&(n=!1)}),n):!1}function ms(e){return ce(e,!1)&&e.includes(":")?e.split(":").length===2:!1}function Fu(e){if(ce(e,!1)&&e.includes(":")){const t=e.split(":");if(t.length===3){const i=t[0]+":"+t[1];return!!t[2]&&ms(i)}}return!1}function Gu(e){function t(i){try{return typeof new URL(i)<"u"}catch{return!1}}try{if(ce(e,!1)){if(t(e))return!0;const i=Lo(e);return t(i)}}catch{}return!1}function Wu(e){var t;return(t=e==null?void 0:e.proposer)==null?void 0:t.publicKey}function Ju(e){return e==null?void 0:e.topic}function Yu(e,t){let i=null;return ce(e==null?void 0:e.publicKey,!1)||(i=A("MISSING_OR_INVALID",`${t} controller public key should be a string`)),i}function Un(e){let t=!0;return It(e)?e.length&&(t=e.every(i=>ce(i,!1))):t=!1,t}function Qu(e,t,i){let s=null;return It(t)&&t.length?t.forEach(r=>{s||ms(r)||(s=Q("UNSUPPORTED_CHAINS",`${i}, chain ${r} should be a string and conform to "namespace:chainId" format`))}):ms(e)||(s=Q("UNSUPPORTED_CHAINS",`${i}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),s}function Zu(e,t,i){let s=null;return Object.entries(e).forEach(([r,n])=>{if(s)return;const o=Qu(r,Do(r,n),`${t} ${i}`);o&&(s=o)}),s}function Xu(e,t){let i=null;return It(e)?e.forEach(s=>{i||Fu(s)||(i=Q("UNSUPPORTED_ACCOUNTS",`${t}, account ${s} should be a string and conform to "namespace:chainId:address" format`))}):i=Q("UNSUPPORTED_ACCOUNTS",`${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),i}function ep(e,t){let i=null;return Object.values(e).forEach(s=>{if(i)return;const r=Xu(s==null?void 0:s.accounts,`${t} namespace`);r&&(i=r)}),i}function tp(e,t){let i=null;return Un(e==null?void 0:e.methods)?Un(e==null?void 0:e.events)||(i=Q("UNSUPPORTED_EVENTS",`${t}, events should be an array of strings or empty array for no events`)):i=Q("UNSUPPORTED_METHODS",`${t}, methods should be an array of strings or empty array for no methods`),i}function va(e,t){let i=null;return Object.values(e).forEach(s=>{if(i)return;const r=tp(s,`${t}, namespace`);r&&(i=r)}),i}function ip(e,t,i){let s=null;if(e&&Pt(e)){const r=va(e,t);r&&(s=r);const n=Zu(e,t,i);n&&(s=n)}else s=A("MISSING_OR_INVALID",`${t}, ${i} should be an object with data`);return s}function Bs(e,t){let i=null;if(e&&Pt(e)){const s=va(e,t);s&&(i=s);const r=ep(e,t);r&&(i=r)}else i=A("MISSING_OR_INVALID",`${t}, namespaces should be an object with data`);return i}function ba(e){return ce(e.protocol,!0)}function sp(e,t){let i=!1;return t&&!e?i=!0:e&&It(e)&&e.length&&e.forEach(s=>{i=ba(s)}),i}function rp(e){return typeof e=="number"}function Oe(e){return typeof e<"u"&&!0}function np(e){return!(!e||typeof e!="object"||!e.code||!Mr(e.code,!1)||!e.message||!ce(e.message,!1))}function op(e){return!(we(e)||!ce(e.method,!1))}function ap(e){return!(we(e)||we(e.result)&&we(e.error)||!Mr(e.id,!1)||!ce(e.jsonrpc,!1))}function cp(e){return!(we(e)||!ce(e.name,!1))}function Mn(e,t){return!(!ms(t)||!Uu(e).includes(t))}function hp(e,t,i){return ce(i,!1)?Mu(e,t).includes(i):!1}function lp(e,t,i){return ce(i,!1)?Lu(e,t).includes(i):!1}function Ln(e,t,i){let s=null;const r=up(e),n=pp(t),o=Object.keys(r),a=Object.keys(n),c=Bn(Object.keys(e)),h=Bn(Object.keys(t)),l=c.filter(u=>!h.includes(u));return l.length&&(s=A("NON_CONFORMING_NAMESPACES",`${i} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(t).toString()}`)),kt(o,a)||(s=A("NON_CONFORMING_NAMESPACES",`${i} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)),Object.keys(t).forEach(u=>{if(!u.includes(":")||s)return;const p=Si(t[u].accounts);p.includes(u)||(s=A("NON_CONFORMING_NAMESPACES",`${i} namespaces accounts don't satisfy namespace accounts for ${u}
        Required: ${u}
        Approved: ${p.toString()}`))}),o.forEach(u=>{s||(kt(r[u].methods,n[u].methods)?kt(r[u].events,n[u].events)||(s=A("NON_CONFORMING_NAMESPACES",`${i} namespaces events don't satisfy namespace events for ${u}`)):s=A("NON_CONFORMING_NAMESPACES",`${i} namespaces methods don't satisfy namespace methods for ${u}`))}),s}function up(e){const t={};return Object.keys(e).forEach(i=>{var s;i.includes(":")?t[i]=e[i]:(s=e[i].chains)==null||s.forEach(r=>{t[r]={methods:e[i].methods,events:e[i].events}})}),t}function Bn(e){return[...new Set(e.map(t=>t.includes(":")?t.split(":")[0]:t))]}function pp(e){const t={};return Object.keys(e).forEach(i=>{if(i.includes(":"))t[i]=e[i];else{const s=Si(e[i].accounts);s==null||s.forEach(r=>{t[r]={accounts:e[i].accounts.filter(n=>n.includes(`${r}:`)),methods:e[i].methods,events:e[i].events}})}}),t}function dp(e,t){return Mr(e,!1)&&e<=t.max&&e>=t.min}function zn(){const e=Gi();return new Promise(t=>{switch(e){case xe.browser:t(gp());break;case xe.reactNative:t(fp());break;case xe.node:t(yp());break;default:t(!0)}})}function gp(){var e;return _i()&&((e=navigator)===null||e===void 0?void 0:e.onLine)}async function fp(){if(Ot()&&typeof L<"u"&&L!=null&&L.NetInfo){const e=await(L==null?void 0:L.NetInfo.fetch());return e==null?void 0:e.isConnected}return!0}function yp(){return!0}function mp(e){switch(Gi()){case xe.browser:wp(e);break;case xe.reactNative:vp(e);break;case xe.node:break}}function wp(e){!Ot()&&_i()&&(window.addEventListener("online",()=>e(!0)),window.addEventListener("offline",()=>e(!1)))}function vp(e){Ot()&&typeof L<"u"&&L!=null&&L.NetInfo&&(L===null||L===void 0||L.NetInfo.addEventListener(t=>e(t==null?void 0:t.isConnected)))}function bp(){var e;return _i()&&(0,St.getDocument)()?((e=(0,St.getDocument)())==null?void 0:e.visibilityState)==="visible":!0}const zs={};var Ni=class{static get(e){return zs[e]}static set(e,t){zs[e]=t}static delete(e){delete zs[e]}};Or();Ro();var Bt=rt(vs()),U=rt(Cr()),$p=rt(qo());const $a="wc",Ea=2,ws="core",st=`${$a}@2:${ws}:`,Ep={name:ws,logger:"error"},_p={database:":memory:"},Ip="crypto",Hn="client_ed25519_seed",Pp=U.ONE_DAY,Sp="keychain",Op="0.3",Ap="messages",xp="0.3",Vn=U.SIX_HOURS,Np="publisher",_a="irn",Cp="error",Ia="wss://relay.walletconnect.org",Rp="relayer",de={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},Tp="_subscription",je={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},qp=.1;const dr="2.21.0";const te={link_mode:"link_mode",relay:"relay"},ps={inbound:"inbound",outbound:"outbound"},Dp="0.3",kp="WALLETCONNECT_CLIENT_ID",Kn="WALLETCONNECT_LINK_MODE_APPS",Re={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},yw=U.THIRTY_DAYS,jp="subscription",Up="0.3",mw=U.FIVE_SECONDS*1e3,Mp="pairing",Lp="0.3",ww=U.THIRTY_DAYS,Ci={wc_pairingDelete:{req:{ttl:U.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:U.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:U.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:U.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:U.ONE_DAY,prompt:!1,tag:0},res:{ttl:U.ONE_DAY,prompt:!1,tag:0}}},Tt={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},Ve={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Bp="history",zp="0.3",Hp="expirer",Me={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},Vp="0.3",vw=U.ONE_DAY,Kp="verify-api",Fp="https://verify.walletconnect.com",Pa="https://verify.walletconnect.org",Li=Pa,Gp=`${Li}/v3`,Wp=[Fp,Pa],Jp="echo",Yp="https://echo.walletconnect.com";const Xe={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},ht={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},Ke={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},xt={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},Nt={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},Ri={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},Qp=.1,Zp="event-client",Xp=86400,ed="https://pulse.walletconnect.org/batch";function td(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var i=new Uint8Array(256),s=0;s<i.length;s++)i[s]=255;for(var r=0;r<e.length;r++){var n=e.charAt(r),o=n.charCodeAt(0);if(i[o]!==255)throw new TypeError(n+" is ambiguous");i[o]=r}var a=e.length,c=e.charAt(0),h=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var m=0,d=0,g=0,w=f.length;g!==w&&f[g]===0;)g++,m++;for(var E=(w-g)*l+1>>>0,I=new Uint8Array(E);g!==w;){for(var C=f[g],x=0,O=E-1;(C!==0||x<d)&&O!==-1;O--,x++)C+=256*I[O]>>>0,I[O]=C%a>>>0,C=C/a>>>0;if(C!==0)throw new Error("Non-zero carry");d=x,g++}for(var v=E-d;v!==E&&I[v]===0;)v++;for(var N=c.repeat(m);v<E;++v)N+=e.charAt(I[v]);return N}function p(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var m=0;if(f[m]!==" "){for(var d=0,g=0;f[m]===c;)d++,m++;for(var w=(f.length-m)*h+1>>>0,E=new Uint8Array(w);f[m];){var I=i[f.charCodeAt(m)];if(I===255)return;for(var C=0,x=w-1;(I!==0||C<g)&&x!==-1;x--,C++)I+=a*E[x]>>>0,E[x]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");g=C,m++}if(f[m]!==" "){for(var O=w-g;O!==w&&E[O]===0;)O++;for(var v=new Uint8Array(d+(w-O)),N=d;O!==w;)v[N++]=E[O++];return v}}}function y(f){var m=p(f);if(m)return m;throw new Error(`Non-${t} character`)}return{encode:u,decodeUnsafe:p,decode:y}}var id=td,sd=id;const Sa=e=>{if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")},rd=e=>new TextEncoder().encode(e),nd=e=>new TextDecoder().decode(e);var od=class{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},ad=class{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Oa(this,e)}},cd=class{constructor(e){this.decoders=e}or(e){return Oa(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const Oa=(e,t)=>new cd({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});var hd=class{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new od(e,t,i),this.decoder=new ad(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const As=({name:e,prefix:t,encode:i,decode:s})=>new hd(e,t,i,s),Xi=({prefix:e,name:t,alphabet:i})=>{const{encode:s,decode:r}=sd(i,t);return As({prefix:e,name:t,encode:s,decode:n=>Sa(r(n))})},ld=(e,t,i,s)=>{const r={};for(let l=0;l<t.length;++l)r[t[l]]=l;let n=e.length;for(;e[n-1]==="=";)--n;const o=new Uint8Array(n*i/8|0);let a=0,c=0,h=0;for(let l=0;l<n;++l){const u=r[e[l]];if(u===void 0)throw new SyntaxError(`Non-${s} character`);c=c<<i|u,a+=i,a>=8&&(a-=8,o[h++]=255&c>>a)}if(a>=i||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o},ud=(e,t,i)=>{const s=t[t.length-1]==="=",r=(1<<i)-1;let n="",o=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],o+=8;o>i;)o-=i,n+=t[r&a>>o];if(o&&(n+=t[r&a<<i-o]),s)for(;n.length*i&7;)n+="=";return n},ve=({name:e,prefix:t,bitsPerChar:i,alphabet:s})=>As({prefix:t,name:e,encode(r){return ud(r,s,i)},decode(r){return ld(r,s,i,e)}}),pd=As({prefix:"\0",name:"identity",encode:e=>nd(e),decode:e=>rd(e)});var dd=Object.freeze({__proto__:null,identity:pd});const gd=ve({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var fd=Object.freeze({__proto__:null,base2:gd});const yd=ve({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var md=Object.freeze({__proto__:null,base8:yd});const wd=Xi({prefix:"9",name:"base10",alphabet:"0123456789"});var vd=Object.freeze({__proto__:null,base10:wd});const bd=ve({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),$d=ve({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Ed=Object.freeze({__proto__:null,base16:bd,base16upper:$d});const _d=ve({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Id=ve({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Pd=ve({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Sd=ve({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Od=ve({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Ad=ve({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),xd=ve({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Nd=ve({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Cd=ve({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Rd=Object.freeze({__proto__:null,base32:_d,base32upper:Id,base32pad:Pd,base32padupper:Sd,base32hex:Od,base32hexupper:Ad,base32hexpad:xd,base32hexpadupper:Nd,base32z:Cd});const Td=Xi({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),qd=Xi({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Dd=Object.freeze({__proto__:null,base36:Td,base36upper:qd});const kd=Xi({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),jd=Xi({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Ud=Object.freeze({__proto__:null,base58btc:kd,base58flickr:jd});const Md=ve({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ld=ve({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Bd=ve({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),zd=ve({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Hd=Object.freeze({__proto__:null,base64:Md,base64pad:Ld,base64url:Bd,base64urlpad:zd});const Aa=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Vd=Aa.reduce((e,t,i)=>(e[i]=t,e),[]),Kd=Aa.reduce((e,t,i)=>(e[t.codePointAt(0)]=i,e),[]);function Fd(e){return e.reduce((t,i)=>(t+=Vd[i],t),"")}function Gd(e){const t=[];for(const i of e){const s=Kd[i.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${i}`);t.push(s)}return new Uint8Array(t)}const Wd=As({prefix:"🚀",name:"base256emoji",encode:Fd,decode:Gd});var Jd=Object.freeze({__proto__:null,base256emoji:Wd}),Yd=xa,Fn=128,Qd=127,Zd=~Qd,Xd=Math.pow(2,31);function xa(e,t,i){t=t||[],i=i||0;for(var s=i;e>=Xd;)t[i++]=e&255|Fn,e/=128;for(;e&Zd;)t[i++]=e&255|Fn,e>>>=7;return t[i]=e|0,xa.bytes=i-s+1,t}var eg=gr,tg=128,Gn=127;function gr(e,s){var i=0,s=s||0,r=0,n=s,o,a=e.length;do{if(n>=a)throw gr.bytes=0,new RangeError("Could not decode varint");o=e[n++],i+=r<28?(o&Gn)<<r:(o&Gn)*Math.pow(2,r),r+=7}while(o>=tg);return gr.bytes=n-s,i}var ig=Math.pow(2,7),sg=Math.pow(2,14),rg=Math.pow(2,21),ng=Math.pow(2,28),og=Math.pow(2,35),ag=Math.pow(2,42),cg=Math.pow(2,49),hg=Math.pow(2,56),lg=Math.pow(2,63),ug=function(e){return e<ig?1:e<sg?2:e<rg?3:e<ng?4:e<og?5:e<ag?6:e<cg?7:e<hg?8:e<lg?9:10},pg={encode:Yd,decode:eg,encodingLength:ug},Na=pg;const Wn=(e,t,i=0)=>(Na.encode(e,t,i),t),Jn=e=>Na.encodingLength(e),fr=(e,t)=>{const i=t.byteLength,s=Jn(e),r=s+Jn(i),n=new Uint8Array(r+i);return Wn(e,n,0),Wn(i,n,s),n.set(t,r),new dg(e,i,t,n)};var dg=class{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}};const Ca=({name:e,code:t,encode:i})=>new gg(e,t,i);var gg=class{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?fr(this.code,t):t.then(i=>fr(this.code,i))}else throw Error("Unknown type, must be binary type")}};const Ra=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),fg=Ca({name:"sha2-256",code:18,encode:Ra("SHA-256")}),yg=Ca({name:"sha2-512",code:19,encode:Ra("SHA-512")});var mg=Object.freeze({__proto__:null,sha256:fg,sha512:yg});const Ta=0,wg="identity",qa=Sa,vg=e=>fr(Ta,qa(e)),bg={code:Ta,name:wg,encode:qa,digest:vg};var $g=Object.freeze({__proto__:null,identity:bg});new TextEncoder,new TextDecoder;const Yn={...dd,...fd,...md,...vd,...Ed,...Rd,...Dd,...Ud,...Hd,...Jd};({...mg,...$g});function Eg(e=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(e):new Uint8Array(e)}function Da(e,t,i,s){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:i},decoder:{decode:s}}}const Qn=Da("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),Hs=Da("ascii","a",e=>{let t="a";for(let i=0;i<e.length;i++)t+=String.fromCharCode(e[i]);return t},e=>{e=e.substring(1);const t=Eg(e.length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t}),_g={utf8:Qn,"utf-8":Qn,hex:Yn.base16,latin1:Hs,ascii:Hs,binary:Hs,...Yn};function Ig(e,t="utf8"){const i=_g[t];if(!i)throw new Error(`Unsupported encoding "${t}"`);return(t==="utf8"||t==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(e,"utf8"):i.decoder.decode(`${i.prefix}${e}`)}var Pg=Object.defineProperty,Sg=(e,t,i)=>t in e?Pg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Qe=(e,t,i)=>Sg(e,typeof t!="symbol"?t+"":t,i),Og=class{constructor(e,t){this.core=e,this.logger=t,Qe(this,"keychain",new Map),Qe(this,"name",Sp),Qe(this,"version",Op),Qe(this,"initialized",!1),Qe(this,"storagePrefix",st),Qe(this,"init",async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}}),Qe(this,"has",i=>(this.isInitialized(),this.keychain.has(i))),Qe(this,"set",async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()}),Qe(this,"get",i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:r}=A("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(r)}return s}),Qe(this,"del",async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()}),this.core=e,this.logger=Pe(t,this.name)}get context(){return ke(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,tr(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?ir(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}},Ag=Object.defineProperty,xg=(e,t,i)=>t in e?Ag(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ye=(e,t,i)=>xg(e,typeof t!="symbol"?t+"":t,i),Ng=class{constructor(e,t,i){this.core=e,this.logger=t,ye(this,"name",Ip),ye(this,"keychain"),ye(this,"randomSessionIdentifier",pr()),ye(this,"initialized",!1),ye(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),ye(this,"hasKeys",s=>(this.isInitialized(),this.keychain.has(s))),ye(this,"getClientId",async()=>{this.isInitialized();const s=await this.getClientSeed(),r=Vr(s);return ic(r.publicKey)}),ye(this,"generateKeyPair",()=>{this.isInitialized();const s=wu();return this.setPrivateKey(s.publicKey,s.privateKey)}),ye(this,"signJWT",async s=>{this.isInitialized();const r=await this.getClientSeed(),n=Vr(r),o=this.randomSessionIdentifier;return await sc(o,s,Pp,n)}),ye(this,"generateSharedKey",(s,r,n)=>{this.isInitialized();const o=this.getPrivateKey(s),a=vu(o,r);return this.setSymKey(a,n)}),ye(this,"setSymKey",async(s,r)=>{this.isInitialized();const n=r||us(s);return await this.keychain.set(n,s),n}),ye(this,"deleteKeyPair",async s=>{this.isInitialized(),await this.keychain.del(s)}),ye(this,"deleteSymKey",async s=>{this.isInitialized(),await this.keychain.del(s)}),ye(this,"encode",async(s,r,n)=>{this.isInitialized();const o=wa(n),a=hc(r);if(Cn(o))return Eu(a,n==null?void 0:n.encoding);if(Nn(o)){const u=o.senderPublicKey,p=o.receiverPublicKey;s=await this.generateSharedKey(u,p)}const c=this.getSymKey(s),{type:h,senderPublicKey:l}=o;return bu({type:h,symKey:c,message:a,senderPublicKey:l,encoding:n==null?void 0:n.encoding})}),ye(this,"decode",async(s,r,n)=>{this.isInitialized();const o=Iu(r,n);if(Cn(o)){const a=_u(r,n==null?void 0:n.encoding);return Kr(a)}if(Nn(o)){const a=o.receiverPublicKey,c=o.senderPublicKey;s=await this.generateSharedKey(a,c)}try{const a=this.getSymKey(s),c=$u({symKey:a,encoded:r,encoding:n==null?void 0:n.encoding});return Kr(c)}catch(a){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(a)}}),ye(this,"getPayloadType",(s,r=We)=>{const n=Fi({encoded:s,encoding:r});return Lt(n.type)}),ye(this,"getPayloadSenderPublicKey",(s,r=We)=>{const n=Fi({encoded:s,encoding:r});return n.senderPublicKey?Ne(n.senderPublicKey,Ie):void 0}),this.core=e,this.logger=Pe(t,this.name),this.keychain=i||new Og(this.core,this.logger)}get context(){return ke(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(Hn)}catch{e=pr(),await this.keychain.set(Hn,e)}return Ig(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}},Cg=Object.defineProperty,Rg=Object.defineProperties,Tg=Object.getOwnPropertyDescriptors,Zn=Object.getOwnPropertySymbols,qg=Object.prototype.hasOwnProperty,Dg=Object.prototype.propertyIsEnumerable,yr=(e,t,i)=>t in e?Cg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,kg=(e,t)=>{for(var i in t||(t={}))qg.call(t,i)&&yr(e,i,t[i]);if(Zn)for(var i of Zn(t))Dg.call(t,i)&&yr(e,i,t[i]);return e},jg=(e,t)=>Rg(e,Tg(t)),Ce=(e,t,i)=>yr(e,typeof t!="symbol"?t+"":t,i),Ug=class extends bc{constructor(e,t){super(e,t),this.logger=e,this.core=t,Ce(this,"messages",new Map),Ce(this,"messagesWithoutClientAck",new Map),Ce(this,"name",Ap),Ce(this,"version",xp),Ce(this,"initialized",!1),Ce(this,"storagePrefix",st),Ce(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i);const s=await this.getRelayerMessagesWithoutClientAck();typeof s<"u"&&(this.messagesWithoutClientAck=s),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}}),Ce(this,"set",async(i,s,r)=>{this.isInitialized();const n=tt(s);let o=this.messages.get(i);if(typeof o>"u"&&(o={}),typeof o[n]<"u")return n;if(o[n]=s,this.messages.set(i,o),r===ps.inbound){const a=this.messagesWithoutClientAck.get(i)||{};this.messagesWithoutClientAck.set(i,jg(kg({},a),{[n]:s}))}return await this.persist(),n}),Ce(this,"get",i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s}),Ce(this,"getWithoutAck",i=>{this.isInitialized();const s={};for(const r of i){const n=this.messagesWithoutClientAck.get(r)||{};s[r]=Object.values(n)}return s}),Ce(this,"has",(i,s)=>{this.isInitialized();const r=this.get(i),n=tt(s);return typeof r[n]<"u"}),Ce(this,"ack",async(i,s)=>{this.isInitialized();const r=this.messagesWithoutClientAck.get(i);if(typeof r>"u")return;const n=tt(s);delete r[n],Object.keys(r).length===0?this.messagesWithoutClientAck.delete(i):this.messagesWithoutClientAck.set(i,r),await this.persist()}),Ce(this,"del",async i=>{this.isInitialized(),this.messages.delete(i),this.messagesWithoutClientAck.delete(i),await this.persist()}),this.logger=Pe(e,this.name),this.core=t}get context(){return ke(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,tr(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,tr(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?ir(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?ir(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}},Mg=Object.defineProperty,Lg=Object.defineProperties,Bg=Object.getOwnPropertyDescriptors,Xn=Object.getOwnPropertySymbols,zg=Object.prototype.hasOwnProperty,Hg=Object.prototype.propertyIsEnumerable,mr=(e,t,i)=>t in e?Mg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ns=(e,t)=>{for(var i in t||(t={}))zg.call(t,i)&&mr(e,i,t[i]);if(Xn)for(var i of Xn(t))Hg.call(t,i)&&mr(e,i,t[i]);return e},Vs=(e,t)=>Lg(e,Bg(t)),Fe=(e,t,i)=>mr(e,typeof t!="symbol"?t+"":t,i),Vg=class extends $c{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,Fe(this,"events",new Bt.EventEmitter),Fe(this,"name",Np),Fe(this,"queue",new Map),Fe(this,"publishTimeout",(0,U.toMiliseconds)(U.ONE_MINUTE)),Fe(this,"initialPublishTimeout",(0,U.toMiliseconds)(U.ONE_SECOND*15)),Fe(this,"needsTransportRestart",!1),Fe(this,"publish",async(i,s,r)=>{var n;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:r}});const o=(r==null?void 0:r.ttl)||Vn,a=ys(r),c=(r==null?void 0:r.prompt)||!1,h=(r==null?void 0:r.tag)||0,l=(r==null?void 0:r.id)||ci().toString(),u={topic:i,message:s,opts:{ttl:o,relay:a,prompt:c,tag:h,id:l,attestation:r==null?void 0:r.attestation,tvf:r==null?void 0:r.tvf}},p=`Failed to publish payload, please try again. id:${l} tag:${h}`;try{const y=new Promise(async f=>{const m=({id:g})=>{u.opts.id===g&&(this.removeRequestFromQueue(g),this.relayer.events.removeListener(de.publish,m),f(u))};this.relayer.events.on(de.publish,m);const d=Et(new Promise((g,w)=>{this.rpcPublish({topic:i,message:s,ttl:o,prompt:c,tag:h,id:l,attestation:r==null?void 0:r.attestation,tvf:r==null?void 0:r.tvf}).then(g).catch(E=>{this.logger.warn(E,E==null?void 0:E.message),w(E)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${l} tag:${h}`);try{await d,this.events.removeListener(de.publish,m)}catch(g){this.queue.set(l,Vs(ns({},u),{attempt:1})),this.logger.warn(g,g==null?void 0:g.message)}});this.logger.trace({type:"method",method:"publish",params:{id:l,topic:i,message:s,opts:r}}),await Et(y,this.publishTimeout,p)}catch(y){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(y),(n=r==null?void 0:r.internal)!=null&&n.throwOnFailedPublish)throw y}finally{this.queue.delete(l)}}),Fe(this,"on",(i,s)=>{this.events.on(i,s)}),Fe(this,"once",(i,s)=>{this.events.once(i,s)}),Fe(this,"off",(i,s)=>{this.events.off(i,s)}),Fe(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.relayer=e,this.logger=Pe(t,this.name),this.registerEventListeners()}get context(){return ke(this.logger)}async rpcPublish(e){var t,i,s,r;const{topic:n,message:o,ttl:a=Vn,prompt:c,tag:h,id:l,attestation:u,tvf:p}=e,y={method:Di(ys().protocol).publish,params:ns({topic:n,message:o,ttl:a,prompt:c,tag:h,attestation:u},p),id:l};we((t=y.params)==null?void 0:t.prompt)&&((i=y.params)==null||delete i.prompt),we((s=y.params)==null?void 0:s.tag)&&((r=y.params)==null||delete r.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:y});const f=await this.relayer.request(y);return this.relayer.events.emit(de.publish,e),this.logger.debug("Successfully Published Payload"),f}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{const i=e.attempt+1;this.queue.set(t,Vs(ns({},e),{attempt:i}));const{topic:s,message:r,opts:n,attestation:o}=e;this.logger.warn({},`Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i}`),await this.rpcPublish(Vs(ns({},e),{topic:s,message:r,ttl:n.ttl,prompt:n.prompt,tag:n.tag,id:n.id,attestation:o,tvf:n.tvf})),this.logger.warn({},`Publisher: queue->published: ${e.opts.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(Ei.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(de.connection_stalled);return}this.checkQueue()}),this.relayer.on(de.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}},Kg=Object.defineProperty,Fg=(e,t,i)=>t in e?Kg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Wt=(e,t,i)=>Fg(e,typeof t!="symbol"?t+"":t,i),Gg=class{constructor(){Wt(this,"map",new Map),Wt(this,"set",(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])}),Wt(this,"get",e=>this.map.get(e)||[]),Wt(this,"exists",(e,t)=>this.get(e).includes(t)),Wt(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(r=>r!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)}),Wt(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}},Wg=Object.defineProperty,Jg=Object.defineProperties,Yg=Object.getOwnPropertyDescriptors,eo=Object.getOwnPropertySymbols,Qg=Object.prototype.hasOwnProperty,Zg=Object.prototype.propertyIsEnumerable,wr=(e,t,i)=>t in e?Wg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ti=(e,t)=>{for(var i in t||(t={}))Qg.call(t,i)&&wr(e,i,t[i]);if(eo)for(var i of eo(t))Zg.call(t,i)&&wr(e,i,t[i]);return e},Ks=(e,t)=>Jg(e,Yg(t)),Z=(e,t,i)=>wr(e,typeof t!="symbol"?t+"":t,i),Xg=class extends Ic{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,Z(this,"subscriptions",new Map),Z(this,"topicMap",new Gg),Z(this,"events",new Bt.EventEmitter),Z(this,"name",jp),Z(this,"version",Up),Z(this,"pending",new Map),Z(this,"cached",[]),Z(this,"initialized",!1),Z(this,"storagePrefix",st),Z(this,"subscribeTimeout",(0,U.toMiliseconds)(U.ONE_MINUTE)),Z(this,"initialSubscribeTimeout",(0,U.toMiliseconds)(U.ONE_SECOND*15)),Z(this,"clientId"),Z(this,"batchSubscribeTopicsLimit",500),Z(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),Z(this,"subscribe",async(i,s)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const r=ys(s),n={topic:i,relay:r,transportType:s==null?void 0:s.transportType};this.pending.set(i,n);const o=await this.rpcSubscribe(i,r,s);return typeof o=="string"&&(this.onSubscribe(o,n),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}})),o}catch(r){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(r),r}}),Z(this,"unsubscribe",async(i,s)=>{this.isInitialized(),typeof(s==null?void 0:s.id)<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)}),Z(this,"isSubscribed",i=>new Promise(s=>{s(this.topicMap.topics.includes(i))})),Z(this,"isKnownTopic",i=>new Promise(s=>{s(this.topicMap.topics.includes(i)||this.pending.has(i)||this.cached.some(r=>r.topic===i))})),Z(this,"on",(i,s)=>{this.events.on(i,s)}),Z(this,"once",(i,s)=>{this.events.once(i,s)}),Z(this,"off",(i,s)=>{this.events.off(i,s)}),Z(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),Z(this,"start",async()=>{await this.onConnect()}),Z(this,"stop",async()=>{await this.onDisconnect()}),Z(this,"restart",async()=>{await this.restore(),await this.onRestart()}),Z(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const i=[];this.pending.forEach(s=>{i.push(s)}),await this.batchSubscribe(i)}),Z(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(Ei.pulse,async()=>{await this.checkPending()}),this.events.on(Re.created,async i=>{const s=Re.created;this.logger.info(`Emitting ${s}`),this.logger.debug({type:"event",event:s,data:i}),await this.persist()}),this.events.on(Re.deleted,async i=>{const s=Re.deleted;this.logger.info(`Emitting ${s}`),this.logger.debug({type:"event",event:s,data:i}),await this.persist()})}),this.relayer=e,this.logger=Pe(t,this.name),this.clientId=""}get context(){return ke(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}reset(){this.cached=[],this.initialized=!0}onDisable(){this.values.length>0&&(this.cached=this.values),this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=ys(i);await this.restartToComplete({topic:e,id:t,relay:s}),await this.rpcUnsubscribe(e,t,s);const r=Q("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t,i){var s;(!i||(i==null?void 0:i.transportType)===te.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const r={method:Di(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:r});const n=(s=i==null?void 0:i.internal)==null?void 0:s.throwOnFailedPublish;try{const o=await this.getSubscriptionId(e);if((i==null?void 0:i.transportType)===te.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(r).catch(h=>this.logger.warn(h))},(0,U.toMiliseconds)(U.ONE_SECOND)),o;const a=new Promise(async h=>{const l=u=>{u.topic===e&&(this.events.removeListener(Re.created,l),h(u.id))};this.events.on(Re.created,l);try{const u=await Et(new Promise((p,y)=>{this.relayer.request(r).catch(f=>{this.logger.warn(f,f==null?void 0:f.message),y(f)}).then(p)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(Re.created,l),h(u)}catch{}}),c=await Et(a,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!c&&n)throw new Error(`Subscribing to ${e} failed, please try again`);return c?o:null}catch(o){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(de.connection_stalled),n)throw o}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:Di(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await Et(new Promise(s=>{this.relayer.request(i).catch(r=>this.logger.warn(r)).then(s)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(de.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,i={method:Di(t.protocol).batchFetchMessages,params:{topics:e.map(r=>r.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});let s;try{s=await await Et(new Promise((r,n)=>{this.relayer.request(i).catch(o=>{this.logger.warn(o),n(o)}).then(r)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(de.connection_stalled)}return s}rpcUnsubscribe(e,t,i){const s={method:Di(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,Ks(Ti({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,Ti({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,Ti({},t)),this.topicMap.set(t.topic,e),this.events.emit(Re.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=A("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(Re.deleted,Ks(Ti({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(Re.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let i=0;i<t;i++){const s=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(s)}}this.events.emit(Re.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=A("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>Ks(Ti({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await nh((0,U.toMiliseconds)(U.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return tt(e+await this.getClientId())}},ef=Object.defineProperty,to=Object.getOwnPropertySymbols,tf=Object.prototype.hasOwnProperty,sf=Object.prototype.propertyIsEnumerable,vr=(e,t,i)=>t in e?ef(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,io=(e,t)=>{for(var i in t||(t={}))tf.call(t,i)&&vr(e,i,t[i]);if(to)for(var i of to(t))sf.call(t,i)&&vr(e,i,t[i]);return e},G=(e,t,i)=>vr(e,typeof t!="symbol"?t+"":t,i),rf=class extends Ec{constructor(e){super(e),G(this,"protocol","wc"),G(this,"version",2),G(this,"core"),G(this,"logger"),G(this,"events",new Bt.EventEmitter),G(this,"provider"),G(this,"messages"),G(this,"subscriber"),G(this,"publisher"),G(this,"name",Rp),G(this,"transportExplicitlyClosed",!1),G(this,"initialized",!1),G(this,"connectionAttemptInProgress",!1),G(this,"relayUrl"),G(this,"projectId"),G(this,"packageName"),G(this,"bundleId"),G(this,"hasExperiencedNetworkDisruption",!1),G(this,"pingTimeout"),G(this,"heartBeatTimeout",(0,U.toMiliseconds)(U.THIRTY_SECONDS+U.FIVE_SECONDS)),G(this,"reconnectTimeout"),G(this,"connectPromise"),G(this,"reconnectInProgress",!1),G(this,"requestsInFlight",[]),G(this,"connectTimeout",(0,U.toMiliseconds)(U.ONE_SECOND*15)),G(this,"request",async t=>{var i,s;this.logger.debug("Publishing Request Payload");const r=t.id||ci().toString();await this.toEstablishConnection();try{this.logger.trace({id:r,method:t.method,topic:(i=t.params)==null?void 0:i.topic},"relayer.request - publishing...");const n=`${r}:${((s=t.params)==null?void 0:s.tag)||""}`;this.requestsInFlight.push(n);const o=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(a=>a!==n),o}catch(n){throw this.logger.debug(`Failed to Publish Request: ${r}`),n}}),G(this,"resetPingTimeout",()=>{gs()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,i,s,r;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(r=(s=(i=(t=this.provider)==null?void 0:t.connection)==null?void 0:i.socket)==null?void 0:s.terminate)==null||r.call(s)}catch(n){this.logger.warn(n,n==null?void 0:n.message)}},this.heartBeatTimeout))}),G(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),G(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected 🛜"),this.startPingTimeout(),this.events.emit(de.connect)}),G(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected 🛑"),this.requestsInFlight=[],this.onProviderDisconnect()}),G(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(de.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),G(this,"registerProviderListeners",()=>{this.provider.on(je.payload,this.onPayloadHandler),this.provider.on(je.connect,this.onConnectHandler),this.provider.on(je.disconnect,this.onDisconnectHandler),this.provider.on(je.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?Pe(e.logger,this.name):(0,Ar.default)($s({level:e.logger||Cp})),this.messages=new Ug(this.logger,e.core),this.subscriber=new Xg(this,this.logger),this.publisher=new Vg(this,this.logger),this.relayUrl=(e==null?void 0:e.relayUrl)||Ia,this.projectId=e.projectId,Hc()?this.packageName=Xr():Vc()&&(this.bundleId=Xr()),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.hasAnyTopics)try{await this.transportOpen()}catch(e){this.logger.warn(e,e==null?void 0:e.message)}}get context(){return ke(this.logger)}get connected(){var e,t,i;return((i=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:i.readyState)===1||!1}get connecting(){var e,t,i;return((i=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:i.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:te.relay},ps.outbound)}async subscribe(e,t){var i,s,r;this.isInitialized(),(!(t!=null&&t.transportType)||(t==null?void 0:t.transportType)==="relay")&&await this.toEstablishConnection();const n=typeof((i=t==null?void 0:t.internal)==null?void 0:i.throwOnFailedPublish)>"u"?!0:(s=t==null?void 0:t.internal)==null?void 0:s.throwOnFailedPublish;let o=((r=this.subscriber.topicMap.get(e))==null?void 0:r[0])||"",a;const c=h=>{h.topic===e&&(this.subscriber.off(Re.created,c),a())};return await Promise.all([new Promise(h=>{a=h,this.subscriber.on(Re.created,c)}),new Promise(async(h,l)=>{o=await this.subscriber.subscribe(e,io({internal:{throwOnFailedPublish:n}},t)).catch(u=>{n&&l(u)})||o,h()})]),o}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await Et(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,i)=>{await this.connect(e).then(t).catch(i).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await zn())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if((e==null?void 0:e.length)===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((i,s)=>i.publishedAt-s.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const i of t)try{await this.onMessageEvent(i)}catch(s){this.logger.warn(s,"Error while processing batch message event: "+(s==null?void 0:s.message))}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:i}=e;if(!t.sessionExists){const s=he(U.FIVE_MINUTES),r={topic:i,expiry:s,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(i,r)}this.events.emit(de.message,e),await this.recordMessageEvent(e,ps.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(i,s)=>{const r=()=>{s(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(je.disconnect,r),await Et(new Promise((n,o)=>{this.provider.connect().then(n).catch(o)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(n=>{s(n)}).finally(()=>{this.provider.off(je.disconnect,r),clearTimeout(this.reconnectTimeout)}),await new Promise(async(n,o)=>{const a=()=>{o(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(je.disconnect,a),await this.subscriber.start().then(n).catch(o).finally(()=>{this.provider.off(je.disconnect,a)})}),this.hasExperiencedNetworkDisruption=!1,i()})}catch(i){await this.subscriber.stop();const s=i;this.logger.warn({},s.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(i=>setTimeout(i,(0,U.toMiliseconds)(t*1))),t++}}startPingTimeout(){var e,t,i,s,r;if(gs())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((r=(s=(i=this.provider)==null?void 0:i.connection)==null?void 0:s.socket)==null||r.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(n){this.logger.warn(n,n==null?void 0:n.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new Be(new nc(Jc({sdkVersion:dr,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:i,message:s}=e;await this.messages.set(i,s,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||i.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.warn(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),xr(e)){if(!e.method.endsWith(Tp))return;const t=e.params,{topic:i,message:s,publishedAt:r,attestation:n}=t.data,o={topic:i,message:s,publishedAt:r,transportType:te.relay,attestation:n};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(io({type:"event",event:t.id},o)),this.events.emit(t.id,o),await this.acknowledgePayload(e),await this.onMessageEvent(o)}else Nr(e)&&this.events.emit(de.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,ps.inbound),this.events.emit(de.message,e))}async acknowledgePayload(e){const t=bs(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(je.payload,this.onPayloadHandler),this.provider.off(je.connect,this.onConnectHandler),this.provider.off(je.disconnect,this.onDisconnectHandler),this.provider.off(je.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await zn();mp(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(i=>this.logger.error(i,i==null?void 0:i.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}),this.core.heartbeat.on(Ei.pulse,async()=>{if(!this.transportExplicitlyClosed&&!this.connected&&bp())try{await this.confirmOnlineStateOrThrow(),await this.transportOpen()}catch(t){this.logger.warn(t,t==null?void 0:t.message)}})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(de.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e==null?void 0:e.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},(0,U.toMiliseconds)(qp)))))}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectPromise){await this.connectPromise;return}await this.connect()}}};function nf(){}function so(e){if(!e||typeof e!="object")return!1;const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype||Object.getPrototypeOf(t)===null?Object.prototype.toString.call(e)==="[object Object]":!1}function ro(e){return Object.getOwnPropertySymbols(e).filter(t=>Object.prototype.propertyIsEnumerable.call(e,t))}function no(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const of="[object RegExp]",af="[object String]",cf="[object Number]",hf="[object Boolean]",oo="[object Arguments]",lf="[object Symbol]",uf="[object Date]",pf="[object Map]",df="[object Set]",gf="[object Array]",ff="[object Function]",yf="[object ArrayBuffer]",Fs="[object Object]",mf="[object Error]",wf="[object DataView]",vf="[object Uint8Array]",bf="[object Uint8ClampedArray]",$f="[object Uint16Array]",Ef="[object Uint32Array]",_f="[object BigUint64Array]",If="[object Int8Array]",Pf="[object Int16Array]",Sf="[object Int32Array]",Of="[object BigInt64Array]",Af="[object Float32Array]",xf="[object Float64Array]";function Nf(e,t){return e===t||Number.isNaN(e)&&Number.isNaN(t)}function Cf(e,t,i){return ki(e,t,void 0,void 0,void 0,void 0,i)}function ki(e,t,i,s,r,n,o){const a=o(e,t,i,s,r,n);if(a!==void 0)return a;if(typeof e==typeof t)switch(typeof e){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return e===t;case"number":return e===t||Object.is(e,t);case"function":return e===t;case"object":return Bi(e,t,n,o)}return Bi(e,t,n,o)}function Bi(e,t,i,s){if(Object.is(e,t))return!0;let r=no(e),n=no(t);if(r===oo&&(r=Fs),n===oo&&(n=Fs),r!==n)return!1;switch(r){case af:return e.toString()===t.toString();case cf:{const c=e.valueOf(),h=t.valueOf();return Nf(c,h)}case hf:case uf:case lf:return Object.is(e.valueOf(),t.valueOf());case of:return e.source===t.source&&e.flags===t.flags;case ff:return e===t}i=i??new Map;const o=i.get(e),a=i.get(t);if(o!=null&&a!=null)return o===t;i.set(e,t),i.set(t,e);try{switch(r){case pf:{if(e.size!==t.size)return!1;for(const[c,h]of e.entries())if(!t.has(c)||!ki(h,t.get(c),c,e,t,i,s))return!1;return!0}case df:{if(e.size!==t.size)return!1;const c=Array.from(e.values()),h=Array.from(t.values());for(let l=0;l<c.length;l++){const u=c[l],p=h.findIndex(y=>ki(u,y,void 0,e,t,i,s));if(p===-1)return!1;h.splice(p,1)}return!0}case gf:case vf:case bf:case $f:case Ef:case _f:case If:case Pf:case Sf:case Of:case Af:case xf:{if(typeof Ee<"u"&&Ee.isBuffer(e)!==Ee.isBuffer(t)||e.length!==t.length)return!1;for(let c=0;c<e.length;c++)if(!ki(e[c],t[c],c,e,t,i,s))return!1;return!0}case yf:return e.byteLength!==t.byteLength?!1:Bi(new Uint8Array(e),new Uint8Array(t),i,s);case wf:return e.byteLength!==t.byteLength||e.byteOffset!==t.byteOffset?!1:Bi(new Uint8Array(e),new Uint8Array(t),i,s);case mf:return e.name===t.name&&e.message===t.message;case Fs:{if(!(Bi(e.constructor,t.constructor,i,s)||so(e)&&so(t)))return!1;const c=[...Object.keys(e),...ro(e)],h=[...Object.keys(t),...ro(t)];if(c.length!==h.length)return!1;for(let l=0;l<c.length;l++){const u=c[l],p=e[u];if(!Object.hasOwn(t,u))return!1;const y=t[u];if(!ki(p,y,u,e,t,i,s))return!1}return!0}default:return!1}}finally{i.delete(e),i.delete(t)}}function Rf(e,t){return Cf(e,t,nf)}var Tf=Object.defineProperty,ao=Object.getOwnPropertySymbols,qf=Object.prototype.hasOwnProperty,Df=Object.prototype.propertyIsEnumerable,br=(e,t,i)=>t in e?Tf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,co=(e,t)=>{for(var i in t||(t={}))qf.call(t,i)&&br(e,i,t[i]);if(ao)for(var i of ao(t))Df.call(t,i)&&br(e,i,t[i]);return e},Se=(e,t,i)=>br(e,typeof t!="symbol"?t+"":t,i),zt=class extends _c{constructor(e,t,i,s=st,r=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,Se(this,"map",new Map),Se(this,"version",Dp),Se(this,"cached",[]),Se(this,"initialized",!1),Se(this,"getKey"),Se(this,"storagePrefix",st),Se(this,"recentlyDeleted",[]),Se(this,"recentlyDeletedLimit",200),Se(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(n=>{this.getKey&&n!==null&&!we(n)?this.map.set(this.getKey(n),n):Wu(n)?this.map.set(n.id,n):Ju(n)&&this.map.set(n.topic,n)}),this.cached=[],this.initialized=!0)}),Se(this,"set",async(n,o)=>{this.isInitialized(),this.map.has(n)?await this.update(n,o):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:n,value:o}),this.map.set(n,o),await this.persist())}),Se(this,"get",n=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:n}),this.getData(n))),Se(this,"getAll",n=>(this.isInitialized(),n?this.values.filter(o=>Object.keys(n).every(a=>Rf(o[a],n[a]))):this.values)),Se(this,"update",async(n,o)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:n,update:o});const a=co(co({},this.getData(n)),o);this.map.set(n,a),await this.persist()}),Se(this,"delete",async(n,o)=>{this.isInitialized(),this.map.has(n)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:n,reason:o}),this.map.delete(n),this.addToRecentlyDeleted(n),await this.persist())}),this.logger=Pe(t,this.name),this.storagePrefix=s,this.getKey=r}get context(){return ke(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:s}=A("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}const{message:i}=A("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=A("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}},kf=Object.defineProperty,jf=(e,t,i)=>t in e?kf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,H=(e,t,i)=>jf(e,typeof t!="symbol"?t+"":t,i),Uf=class{constructor(e,t){this.core=e,this.logger=t,H(this,"name",Mp),H(this,"version",Lp),H(this,"events",new Bt.default),H(this,"pairings"),H(this,"initialized",!1),H(this,"storagePrefix",st),H(this,"ignoredPayloadTypes",[dt]),H(this,"registeredMethods",[]),H(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),H(this,"register",({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]}),H(this,"create",async i=>{this.isInitialized();const s=pr(),r=await this.core.crypto.setSymKey(s),n=he(U.FIVE_MINUTES),o={protocol:_a},a={topic:r,expiry:n,relay:o,active:!1,methods:i==null?void 0:i.methods},c=Tn({protocol:this.core.protocol,version:this.core.version,topic:r,symKey:s,relay:o,expiryTimestamp:n,methods:i==null?void 0:i.methods});return this.events.emit(Tt.create,a),this.core.expirer.set(r,n),await this.pairings.set(r,a),await this.core.relayer.subscribe(r,{transportType:i==null?void 0:i.transportType}),{topic:r,uri:c}}),H(this,"pair",async i=>{this.isInitialized();const s=this.core.eventClient.createEvent({properties:{topic:i==null?void 0:i.uri,trace:[Xe.pairing_started]}});this.isValidPair(i,s);const{topic:r,symKey:n,relay:o,expiryTimestamp:a,methods:c}=Rn(i.uri);s.props.properties.topic=r,s.addTrace(Xe.pairing_uri_validation_success),s.addTrace(Xe.pairing_uri_not_expired);let h;if(this.pairings.keys.includes(r)){if(h=this.pairings.get(r),s.addTrace(Xe.existing_pairing),h.active)throw s.setError(ht.active_pairing_already_exists),new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);s.addTrace(Xe.pairing_not_expired)}const l=a||he(U.FIVE_MINUTES),u={topic:r,relay:o,expiry:l,active:!1,methods:c};this.core.expirer.set(r,l),await this.pairings.set(r,u),s.addTrace(Xe.store_new_pairing),i.activatePairing&&await this.activate({topic:r}),this.events.emit(Tt.create,u),s.addTrace(Xe.emit_inactive_pairing),this.core.crypto.keychain.has(r)||await this.core.crypto.setSymKey(n,r),s.addTrace(Xe.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{s.setError(ht.no_internet_connection)}try{await this.core.relayer.subscribe(r,{relay:o})}catch(p){throw s.setError(ht.subscribe_pairing_topic_failure),p}return s.addTrace(Xe.subscribe_pairing_topic_success),u}),H(this,"activate",async({topic:i})=>{this.isInitialized();const s=he(U.FIVE_MINUTES);this.core.expirer.set(i,s),await this.pairings.update(i,{active:!0,expiry:s})}),H(this,"ping",async i=>{this.isInitialized(),await this.isValidPing(i),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:s}=i;if(this.pairings.keys.includes(s)){const r=await this.sendRequest(s,"wc_pairingPing",{}),{done:n,resolve:o,reject:a}=Ct();this.events.once(Y("pairing_ping",r),({error:c})=>{c?a(c):o()}),await n()}}),H(this,"updateExpiry",async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})}),H(this,"updateMetadata",async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})}),H(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),H(this,"disconnect",async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",Q("USER_DISCONNECTED")),await this.deletePairing(s))}),H(this,"formatUriFromPairing",i=>{this.isInitialized();const{topic:s,relay:r,expiry:n,methods:o}=i,a=this.core.crypto.keychain.get(s);return Tn({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:a,relay:r,expiryTimestamp:n,methods:o})}),H(this,"sendRequest",async(i,s,r)=>{const n=Dt(s,r),o=await this.core.crypto.encode(i,n),a=Ci[s].req;return this.core.history.set(i,n),this.core.relayer.publish(i,o,a),n.id}),H(this,"sendResult",async(i,s,r)=>{const n=bs(i,r),o=await this.core.crypto.encode(s,n),a=(await this.core.history.get(s,i)).request.method,c=Ci[a].res;await this.core.relayer.publish(s,o,c),await this.core.history.resolve(n)}),H(this,"sendError",async(i,s,r)=>{const n=To(i,r),o=await this.core.crypto.encode(s,n),a=(await this.core.history.get(s,i)).request.method,c=Ci[a]?Ci[a].res:Ci.unregistered_method.res;await this.core.relayer.publish(s,o,c),await this.core.history.resolve(n)}),H(this,"deletePairing",async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,Q("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])}),H(this,"cleanup",async()=>{const i=this.pairings.getAll().filter(s=>bt(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))}),H(this,"onRelayEventRequest",async i=>{const{topic:s,payload:r}=i;switch(r.method){case"wc_pairingPing":return await this.onPairingPingRequest(s,r);case"wc_pairingDelete":return await this.onPairingDeleteRequest(s,r);default:return await this.onUnknownRpcMethodRequest(s,r)}}),H(this,"onRelayEventResponse",async i=>{const{topic:s,payload:r}=i,n=(await this.core.history.get(s,r.id)).request.method;switch(n){case"wc_pairingPing":return this.onPairingPingResponse(s,r);default:return this.onUnknownRpcMethodResponse(n)}}),H(this,"onPairingPingRequest",async(i,s)=>{const{id:r}=s;try{this.isValidPing({topic:i}),await this.sendResult(r,i,!0),this.events.emit(Tt.ping,{id:r,topic:i})}catch(n){await this.sendError(r,i,n),this.logger.error(n)}}),H(this,"onPairingPingResponse",(i,s)=>{const{id:r}=s;setTimeout(()=>{ct(s)?this.events.emit(Y("pairing_ping",r),{}):et(s)&&this.events.emit(Y("pairing_ping",r),{error:s.error})},500)}),H(this,"onPairingDeleteRequest",async(i,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit(Tt.delete,{id:r,topic:i})}catch(n){await this.sendError(r,i,n),this.logger.error(n)}}),H(this,"onUnknownRpcMethodRequest",async(i,s)=>{const{id:r,method:n}=s;try{if(this.registeredMethods.includes(n))return;const o=Q("WC_METHOD_UNSUPPORTED",n);await this.sendError(r,i,o),this.logger.error(o)}catch(o){await this.sendError(r,i,o),this.logger.error(o)}}),H(this,"onUnknownRpcMethodResponse",i=>{this.registeredMethods.includes(i)||this.logger.error(Q("WC_METHOD_UNSUPPORTED",i))}),H(this,"isValidPair",(i,s)=>{var r;if(!Oe(i)){const{message:o}=A("MISSING_OR_INVALID",`pair() params: ${i}`);throw s.setError(ht.malformed_pairing_uri),new Error(o)}if(!Gu(i.uri)){const{message:o}=A("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw s.setError(ht.malformed_pairing_uri),new Error(o)}const n=Rn(i==null?void 0:i.uri);if(!((r=n==null?void 0:n.relay)!=null&&r.protocol)){const{message:o}=A("MISSING_OR_INVALID","pair() uri#relay-protocol");throw s.setError(ht.malformed_pairing_uri),new Error(o)}if(!(n!=null&&n.symKey)){const{message:o}=A("MISSING_OR_INVALID","pair() uri#symKey");throw s.setError(ht.malformed_pairing_uri),new Error(o)}if(n!=null&&n.expiryTimestamp&&(0,U.toMiliseconds)(n==null?void 0:n.expiryTimestamp)<Date.now()){s.setError(ht.pairing_expired);const{message:o}=A("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(o)}}),H(this,"isValidPing",async i=>{if(!Oe(i)){const{message:r}=A("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s)}),H(this,"isValidDisconnect",async i=>{if(!Oe(i)){const{message:r}=A("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s)}),H(this,"isValidPairingTopic",async i=>{if(!ce(i,!1)){const{message:s}=A("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=A("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(bt(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=A("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}}),this.core=e,this.logger=Pe(t,this.name),this.pairings=new zt(this.core,this.logger,this.name,this.storagePrefix)}get context(){return ke(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(de.message,async e=>{const{topic:t,message:i,transportType:s}=e;if(this.pairings.keys.includes(t)&&s!==te.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))try{const r=await this.core.crypto.decode(t,i);xr(r)?(this.core.history.set(t,r),await this.onRelayEventRequest({topic:t,payload:r})):Nr(r)&&(await this.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.core.history.delete(t,r.id)),await this.core.relayer.messages.ack(t,i)}catch(r){this.logger.error(r)}})}registerExpirerEvents(){this.core.expirer.on(Me.expired,async e=>{const{topic:t}=Mo(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(Tt.expire,{topic:t}))})}},Mf=Object.defineProperty,Lf=(e,t,i)=>t in e?Mf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,me=(e,t,i)=>Lf(e,typeof t!="symbol"?t+"":t,i),Bf=class extends vc{constructor(e,t){super(e,t),this.core=e,this.logger=t,me(this,"records",new Map),me(this,"events",new Bt.EventEmitter),me(this,"name",Bp),me(this,"version",zp),me(this,"cached",[]),me(this,"initialized",!1),me(this,"storagePrefix",st),me(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),me(this,"set",(i,s,r)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:r}),this.records.has(s.id))return;const n={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:r,expiry:he(U.THIRTY_DAYS)};this.records.set(n.id,n),this.persist(),this.events.emit(Ve.created,n)}),me(this,"resolve",async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=et(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.persist(),this.events.emit(Ve.updated,s))}),me(this,"get",async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s))),me(this,"delete",(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(r=>{if(r.topic===i){if(typeof s<"u"&&r.id!==s)return;this.records.delete(r.id),this.events.emit(Ve.deleted,r)}}),this.persist()}),me(this,"exists",async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1)),me(this,"on",(i,s)=>{this.events.on(i,s)}),me(this,"once",(i,s)=>{this.events.once(i,s)}),me(this,"off",(i,s)=>{this.events.off(i,s)}),me(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.logger=Pe(t,this.name)}get context(){return ke(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:Dt(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=A("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(Ve.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=A("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(Ve.created,e=>{const t=Ve.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(Ve.updated,e=>{const t=Ve.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(Ve.deleted,e=>{const t=Ve.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(Ei.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{(0,U.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(Ve.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}},zf=Object.defineProperty,Hf=(e,t,i)=>t in e?zf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,$e=(e,t,i)=>Hf(e,typeof t!="symbol"?t+"":t,i),Vf=class extends Pc{constructor(e,t){super(e,t),this.core=e,this.logger=t,$e(this,"expirations",new Map),$e(this,"events",new Bt.EventEmitter),$e(this,"name",Hp),$e(this,"version",Vp),$e(this,"cached",[]),$e(this,"initialized",!1),$e(this,"storagePrefix",st),$e(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),$e(this,"has",i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}}),$e(this,"set",(i,s)=>{this.isInitialized();const r=this.formatTarget(i),n={target:r,expiry:s};this.expirations.set(r,n),this.checkExpiry(r,n),this.events.emit(Me.created,{target:r,expiration:n})}),$e(this,"get",i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)}),$e(this,"del",i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),r=this.getExpiration(s);this.expirations.delete(s),this.events.emit(Me.deleted,{target:s,expiration:r})}}),$e(this,"on",(i,s)=>{this.events.on(i,s)}),$e(this,"once",(i,s)=>{this.events.once(i,s)}),$e(this,"off",(i,s)=>{this.events.off(i,s)}),$e(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.logger=Pe(t,this.name)}get context(){return ke(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return Yc(e);if(typeof e=="number")return Qc(e);const{message:t}=A("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(Me.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=A("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=A("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;(0,U.toMiliseconds)(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(Me.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(Ei.pulse,()=>this.checkExpirations()),this.events.on(Me.created,e=>{const t=Me.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Me.expired,e=>{const t=Me.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Me.deleted,e=>{const t=Me.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}},Kf=Object.defineProperty,Ff=(e,t,i)=>t in e?Kf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ae=(e,t,i)=>Ff(e,typeof t!="symbol"?t+"":t,i),Gf=class extends Sc{constructor(e,t,i){super(e,t,i),this.core=e,this.logger=t,this.store=i,ae(this,"name",Kp),ae(this,"abortController"),ae(this,"isDevEnv"),ae(this,"verifyUrlV3",Gp),ae(this,"storagePrefix",st),ae(this,"version",Ea),ae(this,"publicKey"),ae(this,"fetchPromise"),ae(this,"init",async()=>{var s;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,U.toMiliseconds)((s=this.publicKey)==null?void 0:s.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),ae(this,"register",async s=>{if(!_i()||this.isDevEnv)return;const r=window.location.origin,{id:n,decryptedId:o}=s,a=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r}&id=${n}&decryptedId=${o}`;try{const c=(0,$p.getDocument)(),h=this.startAbortTimer(U.ONE_SECOND*5),l=await new Promise((u,p)=>{const y=()=>{window.removeEventListener("message",m),c.body.removeChild(f),p("attestation aborted")};this.abortController.signal.addEventListener("abort",y);const f=c.createElement("iframe");f.src=a,f.style.display="none",f.addEventListener("error",y,{signal:this.abortController.signal});const m=d=>{if(d.data&&typeof d.data=="string")try{const g=JSON.parse(d.data);if(g.type==="verify_attestation"){if(er(g.attestation).payload.id!==n)return;clearInterval(h),c.body.removeChild(f),this.abortController.signal.removeEventListener("abort",y),window.removeEventListener("message",m),u(g.attestation===null?"":g.attestation)}}catch(g){this.logger.warn(g)}};c.body.appendChild(f),window.addEventListener("message",m,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",l),l}catch(c){this.logger.warn(c)}return""}),ae(this,"resolve",async s=>{if(this.isDevEnv)return"";const{attestationId:r,hash:n,encryptedId:o}=s;if(r===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(r){if(er(r).payload.id!==o)return;const c=await this.isValidJwtAttestation(r);if(c){if(!c.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return c}}if(!n)return;const a=this.getVerifyUrl(s==null?void 0:s.verifyUrl);return this.fetchAttestation(n,a)}),ae(this,"fetchAttestation",async(s,r)=>{this.logger.debug(`resolving attestation: ${s} from url: ${r}`);const n=this.startAbortTimer(U.ONE_SECOND*5),o=await fetch(`${r}/attestation/${s}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(n),o.status===200?await o.json():void 0}),ae(this,"getVerifyUrl",s=>{let r=s||Li;return Wp.includes(r)||(this.logger.info(`verify url: ${r}, not included in trusted list, assigning default: ${Li}`),r=Li),r}),ae(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const s=this.startAbortTimer(U.FIVE_SECONDS),r=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(s),await r.json()}catch(s){this.logger.warn(s)}}),ae(this,"persistPublicKey",async s=>{this.logger.debug("persisting public key to local storage",s),await this.store.setItem(this.storeKey,s),this.publicKey=s}),ae(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),ae(this,"isValidJwtAttestation",async s=>{const r=await this.getPublicKey();try{if(r)return this.validateAttestation(s,r)}catch(o){this.logger.error(o),this.logger.warn("error validating attestation")}const n=await this.fetchAndPersistPublicKey();try{if(n)return this.validateAttestation(s,n)}catch(o){this.logger.error(o),this.logger.warn("error validating attestation")}}),ae(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),ae(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async r=>{const n=await this.fetchPublicKey();n&&(await this.persistPublicKey(n),r(n))});const s=await this.fetchPromise;return this.fetchPromise=void 0,s}),ae(this,"validateAttestation",(s,r)=>{const n=Su(s,r.publicKey),o={hasExpired:(0,U.toMiliseconds)(n.exp)<Date.now(),payload:n};if(o.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:o.payload.origin,isScam:o.payload.isScam,isVerified:o.payload.isVerified}}),this.logger=Pe(t,this.name),this.abortController=new AbortController,this.isDevEnv=Rr(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return ke(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),(0,U.toMiliseconds)(e))}},Wf=Object.defineProperty,Jf=(e,t,i)=>t in e?Wf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ho=(e,t,i)=>Jf(e,typeof t!="symbol"?t+"":t,i),Yf=class extends Oc{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,ho(this,"context",Jp),ho(this,"registerDeviceToken",async i=>{const{clientId:s,token:r,notificationType:n,enableEncrypted:o=!1}=i,a=`${Yp}/${this.projectId}/clients`;await fetch(a,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:s,type:n,token:r,always_raw:o})})}),this.logger=Pe(t,this.context)}},Qf=Object.defineProperty,lo=Object.getOwnPropertySymbols,Zf=Object.prototype.hasOwnProperty,Xf=Object.prototype.propertyIsEnumerable,$r=(e,t,i)=>t in e?Qf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,qi=(e,t)=>{for(var i in t||(t={}))Zf.call(t,i)&&$r(e,i,t[i]);if(lo)for(var i of lo(t))Xf.call(t,i)&&$r(e,i,t[i]);return e},le=(e,t,i)=>$r(e,typeof t!="symbol"?t+"":t,i),ey=class extends Ac{constructor(e,t,i=!0){super(e,t,i),this.core=e,this.logger=t,le(this,"context",Zp),le(this,"storagePrefix",st),le(this,"storageVersion",Qp),le(this,"events",new Map),le(this,"shouldPersist",!1),le(this,"init",async()=>{if(!Rr())try{const s={eventId:tn(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:jo(this.core.relayer.protocol,this.core.relayer.version,dr)}}};await this.sendEvent([s])}catch(s){this.logger.warn(s)}}),le(this,"createEvent",s=>{const{event:r="ERROR",type:n="",properties:{topic:o,trace:a}}=s,c=tn(),h=this.core.projectId||"",l=Date.now(),u=qi({eventId:c,timestamp:l,props:{event:r,type:n,properties:{topic:o,trace:a}},bundleId:h,domain:this.getAppDomain()},this.setMethods(c));return this.telemetryEnabled&&(this.events.set(c,u),this.shouldPersist=!0),u}),le(this,"getEvent",s=>{const{eventId:r,topic:n}=s;if(r)return this.events.get(r);const o=Array.from(this.events.values()).find(a=>a.props.properties.topic===n);if(o)return qi(qi({},o),this.setMethods(o.eventId))}),le(this,"deleteEvent",s=>{const{eventId:r}=s;this.events.delete(r),this.shouldPersist=!0}),le(this,"setEventListeners",()=>{this.core.heartbeat.on(Ei.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(s=>{(0,U.fromMiliseconds)(Date.now())-(0,U.fromMiliseconds)(s.timestamp)>Xp&&(this.events.delete(s.eventId),this.shouldPersist=!0)})})}),le(this,"setMethods",s=>({addTrace:r=>this.addTrace(s,r),setError:r=>this.setError(s,r)})),le(this,"addTrace",(s,r)=>{const n=this.events.get(s);n&&(n.props.properties.trace.push(r),this.events.set(s,n),this.shouldPersist=!0)}),le(this,"setError",(s,r)=>{const n=this.events.get(s);n&&(n.props.type=r,n.timestamp=Date.now(),this.events.set(s,n),this.shouldPersist=!0)}),le(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),le(this,"restore",async()=>{try{const s=await this.core.storage.getItem(this.storageKey)||[];if(!s.length)return;s.forEach(r=>{this.events.set(r.eventId,qi(qi({},r),this.setMethods(r.eventId)))})}catch(s){this.logger.warn(s)}}),le(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const s=[];for(const[r,n]of this.events)n.props.type&&s.push(n);if(s.length!==0)try{if((await this.sendEvent(s)).ok)for(const r of s)this.events.delete(r.eventId),this.shouldPersist=!0}catch(r){this.logger.warn(r)}}),le(this,"sendEvent",async s=>{const r=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${ed}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${dr}${r}`,{method:"POST",body:JSON.stringify(s)})}),le(this,"getAppDomain",()=>ko().url),this.logger=Pe(t,this.context),this.telemetryEnabled=i,i?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}},ty=Object.defineProperty,uo=Object.getOwnPropertySymbols,iy=Object.prototype.hasOwnProperty,sy=Object.prototype.propertyIsEnumerable,Er=(e,t,i)=>t in e?ty(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,po=(e,t)=>{for(var i in t||(t={}))iy.call(t,i)&&Er(e,i,t[i]);if(uo)for(var i of uo(t))sy.call(t,i)&&Er(e,i,t[i]);return e},ee=(e,t,i)=>Er(e,typeof t!="symbol"?t+"":t,i),ry=class ka extends fc{constructor(t){var i;super(t),ee(this,"protocol",$a),ee(this,"version",Ea),ee(this,"name",ws),ee(this,"relayUrl"),ee(this,"projectId"),ee(this,"customStoragePrefix"),ee(this,"events",new Bt.EventEmitter),ee(this,"logger"),ee(this,"heartbeat"),ee(this,"relayer"),ee(this,"crypto"),ee(this,"storage"),ee(this,"history"),ee(this,"expirer"),ee(this,"pairing"),ee(this,"verify"),ee(this,"echoClient"),ee(this,"linkModeSupportedApps"),ee(this,"eventClient"),ee(this,"initialized",!1),ee(this,"logChunkController"),ee(this,"on",(a,c)=>this.events.on(a,c)),ee(this,"once",(a,c)=>this.events.once(a,c)),ee(this,"off",(a,c)=>this.events.off(a,c)),ee(this,"removeListener",(a,c)=>this.events.removeListener(a,c)),ee(this,"dispatchEnvelope",({topic:a,message:c,sessionExists:h})=>{if(!a||!c)return;const l={topic:a,message:c,publishedAt:Date.now(),transportType:te.link_mode};this.relayer.onLinkMessageEvent(l,{sessionExists:h})});const s=this.getGlobalCore(t==null?void 0:t.customStoragePrefix);if(s)try{return this.customStoragePrefix=s.customStoragePrefix,this.logger=s.logger,this.heartbeat=s.heartbeat,this.crypto=s.crypto,this.history=s.history,this.expirer=s.expirer,this.storage=s.storage,this.relayer=s.relayer,this.pairing=s.pairing,this.verify=s.verify,this.echoClient=s.echoClient,this.linkModeSupportedApps=s.linkModeSupportedApps,this.eventClient=s.eventClient,this.initialized=s.initialized,this.logChunkController=s.logChunkController,s}catch(a){console.warn("Failed to copy global core",a)}this.projectId=t==null?void 0:t.projectId,this.relayUrl=(t==null?void 0:t.relayUrl)||Ia,this.customStoragePrefix=t!=null&&t.customStoragePrefix?`:${t.customStoragePrefix}`:"";const r=$s({level:typeof(t==null?void 0:t.logger)=="string"&&t.logger?t.logger:Ep.logger,name:ws}),{logger:n,chunkLoggerController:o}=ec({opts:r,maxSizeInBytes:t==null?void 0:t.maxLogBlobSizeInBytes,loggerOverride:t==null?void 0:t.logger});this.logChunkController=o,(i=this.logChunkController)!=null&&i.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var a,c;(a=this.logChunkController)!=null&&a.downloadLogsBlobInBrowser&&((c=this.logChunkController)==null||c.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=Pe(n,this.name),this.heartbeat=new ac,this.crypto=new Ng(this,this.logger,t==null?void 0:t.keychain),this.history=new Bf(this,this.logger),this.expirer=new Vf(this,this.logger),this.storage=t!=null&&t.storage?t.storage:new oc(po(po({},_p),t==null?void 0:t.storageOptions)),this.relayer=new rf({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new Uf(this,this.logger),this.verify=new Gf(this,this.logger,this.storage),this.echoClient=new Yf(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new ey(this,this.logger,t==null?void 0:t.telemetryEnabled),this.setGlobalCore(this)}static async init(t){const i=new ka(t);await i.initialize();const s=await i.crypto.getClientId();return await i.storage.setItem(kp,s),i}get context(){return ke(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var t;return(t=this.logChunkController)==null?void 0:t.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(t){this.linkModeSupportedApps.includes(t)||(this.linkModeSupportedApps.push(t),await this.storage.setItem(Kn,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(Kn)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(t){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,t),this.logger.error(t.message),t}}getGlobalCore(t=""){try{if(this.isGlobalCoreDisabled())return;const i=`_walletConnectCore_${t}`,s=`${i}_count`;return globalThis[s]=(globalThis[s]||0)+1,globalThis[s]>1&&console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[s]} times.`),globalThis[i]}catch(i){console.warn("Failed to get global WalletConnect core",i);return}}setGlobalCore(t){var i;try{if(this.isGlobalCoreDisabled())return;const s=`_walletConnectCore_${((i=t.opts)==null?void 0:i.customStoragePrefix)||""}`;globalThis[s]=t}catch(s){console.warn("Failed to set global WalletConnect core",s)}}isGlobalCoreDisabled(){try{return typeof ji<"u"&&{}.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}};const ny=ry;Co();var W=rt(Cr()),ja=rt(vs());const Ua="wc",Ma=2,La="client",Lr=`${Ua}@${Ma}:${La}:`,Gs={name:La,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"};const go="WALLETCONNECT_DEEPLINK_CHOICE";const oy="proposal",bw=W.THIRTY_DAYS,fo="Proposal expired",ay="session",Jt=W.SEVEN_DAYS,cy="engine",ue={wc_sessionPropose:{req:{ttl:W.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:W.ONE_DAY,prompt:!1,tag:1104},res:{ttl:W.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:W.ONE_DAY,prompt:!1,tag:1106},res:{ttl:W.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:W.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:W.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:W.ONE_DAY,prompt:!1,tag:1112},res:{ttl:W.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:W.ONE_DAY,prompt:!1,tag:1114},res:{ttl:W.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:W.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:W.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:W.FIVE_MINUTES,prompt:!1,tag:1119}}},Ws={min:W.FIVE_MINUTES,max:W.SEVEN_DAYS},Ze={idle:"IDLE",active:"ACTIVE"},yo={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},hy="request",ly=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],uy="wc";const py="auth",dy="authKeys",gy="pairingTopics",fy="requests",xs=`${uy}@1.5:${py}:`,ds=`${xs}:PUB_KEY`;var yy=Object.defineProperty,my=Object.defineProperties,wy=Object.getOwnPropertyDescriptors,mo=Object.getOwnPropertySymbols,vy=Object.prototype.hasOwnProperty,by=Object.prototype.propertyIsEnumerable,_r=(e,t,i)=>t in e?yy(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,X=(e,t)=>{for(var i in t||(t={}))vy.call(t,i)&&_r(e,i,t[i]);if(mo)for(var i of mo(t))by.call(t,i)&&_r(e,i,t[i]);return e},_e=(e,t)=>my(e,wy(t)),b=(e,t,i)=>_r(e,typeof t!="symbol"?t+"":t,i),$y=class extends Rc{constructor(e){super(e),b(this,"name",cy),b(this,"events",new ja.default),b(this,"initialized",!1),b(this,"requestQueue",{state:Ze.idle,queue:[]}),b(this,"sessionRequestQueue",{state:Ze.idle,queue:[]}),b(this,"requestQueueDelay",W.ONE_SECOND),b(this,"expectedPairingMethodMap",new Map),b(this,"recentlyDeletedMap",new Map),b(this,"recentlyDeletedLimit",200),b(this,"relayMessageCache",[]),b(this,"pendingSessions",new Map),b(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(ue)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,W.toMiliseconds)(this.requestQueueDelay)))}),b(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const i=_e(X({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(i),i.optionalNamespaces=zu(i.requiredNamespaces,i.optionalNamespaces),i.requiredNamespaces={};const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:o,scopedProperties:a,relays:c}=i;let h=s,l,u=!1;try{if(h){const C=this.client.core.pairing.pairings.get(h);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),u=C.active}}catch(C){throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`),C}if(!h||!u){const{topic:C,uri:x}=await this.client.core.pairing.create();h=C,l=x}if(!h){const{message:C}=A("NO_MATCHING_KEY",`connect() pairing topic: ${h}`);throw new Error(C)}const p=await this.client.core.crypto.generateKeyPair(),y=ue.wc_sessionPropose.req.ttl||W.FIVE_MINUTES,f=he(y),m=_e(X(X({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:_a}],proposer:{publicKey:p,metadata:this.client.metadata},expiryTimestamp:f,pairingTopic:h},o&&{sessionProperties:o}),a&&{scopedProperties:a}),{id:mt()}),d=Y("session_connect",m.id),{reject:g,resolve:w,done:E}=Ct(y,fo),I=({id:C})=>{C===m.id&&(this.client.events.off("proposal_expire",I),this.pendingSessions.delete(m.id),this.events.emit(d,{error:{message:fo,code:0}}))};return this.client.events.on("proposal_expire",I),this.events.once(d,({error:C,session:x})=>{this.client.events.off("proposal_expire",I),C?g(C):x&&w(x)}),await this.sendRequest({topic:h,method:"wc_sessionPropose",params:m,throwOnFailedPublish:!0,clientRpcId:m.id}),await this.setProposal(m.id,m),{uri:l,approval:E}}),b(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(i){throw this.client.logger.error("pair() failed"),i}}),b(this,"approve",async t=>{var i,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:(i=t==null?void 0:t.id)==null?void 0:i.toString(),trace:[Ke.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(v){throw n.setError(xt.no_internet_connection),v}try{await this.isValidProposalId(t==null?void 0:t.id)}catch(v){throw this.client.logger.error(`approve() -> proposal.get(${t==null?void 0:t.id}) failed`),n.setError(xt.proposal_not_found),v}try{await this.isValidApprove(t)}catch(v){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(xt.session_approve_namespace_validation_failure),v}const{id:o,relayProtocol:a,namespaces:c,sessionProperties:h,scopedProperties:l,sessionConfig:u}=t,p=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:y,proposer:f,requiredNamespaces:m,optionalNamespaces:d}=p;let g=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:y});g||(g=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:Ke.session_approve_started,properties:{topic:y,trace:[Ke.session_approve_started,Ke.session_namespaces_validation_success]}}));const w=await this.client.core.crypto.generateKeyPair(),E=f.publicKey,I=await this.client.core.crypto.generateSharedKey(w,E),C=X(X(X({relay:{protocol:a??"irn"},namespaces:c,controller:{publicKey:w,metadata:this.client.metadata},expiry:he(Jt)},h&&{sessionProperties:h}),l&&{scopedProperties:l}),u&&{sessionConfig:u}),x=te.relay;g.addTrace(Ke.subscribing_session_topic);try{await this.client.core.relayer.subscribe(I,{transportType:x})}catch(v){throw g.setError(xt.subscribe_session_topic_failure),v}g.addTrace(Ke.subscribe_session_topic_success);const O=_e(X({},C),{topic:I,requiredNamespaces:m,optionalNamespaces:d,pairingTopic:y,acknowledged:!1,self:C.controller,peer:{publicKey:f.publicKey,metadata:f.metadata},controller:w,transportType:te.relay});await this.client.session.set(I,O),g.addTrace(Ke.store_session);try{g.addTrace(Ke.publishing_session_settle),await this.sendRequest({topic:I,method:"wc_sessionSettle",params:C,throwOnFailedPublish:!0}).catch(v=>{throw g==null||g.setError(xt.session_settle_publish_failure),v}),g.addTrace(Ke.session_settle_publish_success),g.addTrace(Ke.publishing_session_approve),await this.sendResult({id:o,topic:y,result:{relay:{protocol:a??"irn"},responderPublicKey:w},throwOnFailedPublish:!0}).catch(v=>{throw g==null||g.setError(xt.session_approve_publish_failure),v}),g.addTrace(Ke.session_approve_publish_success)}catch(v){throw this.client.logger.error(v),this.client.session.delete(I,Q("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(I),v}return this.client.core.eventClient.deleteEvent({eventId:g.eventId}),await this.client.core.pairing.updateMetadata({topic:y,metadata:f.metadata}),await this.client.proposal.delete(o,Q("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:y}),await this.setExpiry(I,he(Jt)),{topic:I,acknowledged:()=>Promise.resolve(this.client.session.get(I))}}),b(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:i,reason:s}=t;let r;try{r=this.client.proposal.get(i).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${i}) failed`),n}r&&(await this.sendError({id:i,topic:r,error:s,rpcOpts:ue.wc_sessionPropose.reject}),await this.client.proposal.delete(i,Q("USER_DISCONNECTED")))}),b(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(l){throw this.client.logger.error("update() -> isValidUpdate() failed"),l}const{topic:i,namespaces:s}=t,{done:r,resolve:n,reject:o}=Ct(),a=mt(),c=ci().toString(),h=this.client.session.get(i).namespaces;return this.events.once(Y("session_update",a),({error:l})=>{l?o(l):n()}),await this.client.session.update(i,{namespaces:s}),await this.sendRequest({topic:i,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:c}).catch(l=>{this.client.logger.error(l),this.client.session.update(i,{namespaces:h}),o(l)}),{acknowledged:r}}),b(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(a){throw this.client.logger.error("extend() -> isValidExtend() failed"),a}const{topic:i}=t,s=mt(),{done:r,resolve:n,reject:o}=Ct();return this.events.once(Y("session_extend",s),({error:a})=>{a?o(a):n()}),await this.setExpiry(i,he(Jt)),this.sendRequest({topic:i,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(a=>{o(a)}),{acknowledged:r}}),b(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(d){throw this.client.logger.error("request() -> isValidRequest() failed"),d}const{chainId:i,request:s,topic:r,expiry:n=ue.wc_sessionRequest.req.ttl}=t,o=this.client.session.get(r);(o==null?void 0:o.transportType)===te.relay&&await this.confirmOnlineStateOrThrow();const a=mt(),c=ci().toString(),{done:h,resolve:l,reject:u}=Ct(n,"Request expired. Please try again.");this.events.once(Y("session_request",a),({error:d,result:g})=>{d?u(d):l(g)});const p="wc_sessionRequest",y=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);if(y)return await this.sendRequest({clientRpcId:a,relayRpcId:c,topic:r,method:p,params:{request:_e(X({},s),{expiryTimestamp:he(n)}),chainId:i},expiry:n,throwOnFailedPublish:!0,appLink:y}).catch(d=>u(d)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:i,id:a}),await h();const f={request:_e(X({},s),{expiryTimestamp:he(n)}),chainId:i},m=this.shouldSetTVF(p,f);return await Promise.all([new Promise(async d=>{await this.sendRequest(X({clientRpcId:a,relayRpcId:c,topic:r,method:p,params:f,expiry:n,throwOnFailedPublish:!0},m&&{tvf:this.getTVFParams(a,f)})).catch(g=>u(g)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:i,id:a}),d()}),new Promise(async d=>{var g;if(!((g=o.sessionConfig)!=null&&g.disableDeepLink)){const w=await th(this.client.core.storage,go);await Zc({id:a,topic:r,wcDeepLink:w})}d()}),h()]).then(d=>d[2])}),b(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:i,response:s}=t,{id:r}=s,n=this.client.session.get(i);n.transportType===te.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);ct(s)?await this.sendResult({id:r,topic:i,result:s.result,throwOnFailedPublish:!0,appLink:o}):et(s)&&await this.sendError({id:r,topic:i,error:s.error,appLink:o}),this.cleanupAfterResponse(t)}),b(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:i}=t;if(this.client.session.keys.includes(i)){const s=mt(),r=ci().toString(),{done:n,resolve:o,reject:a}=Ct();this.events.once(Y("session_ping",s),({error:c})=>{c?a(c):o()}),await Promise.all([this.sendRequest({topic:i,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(i)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:i}))}),b(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:i,event:s,chainId:r}=t,n=ci().toString(),o=mt();await this.sendRequest({topic:i,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n,clientRpcId:o})}),b(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:i}=t;if(this.client.session.keys.includes(i))await this.sendRequest({topic:i,method:"wc_sessionDelete",params:Q("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:i,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(i))await this.client.core.pairing.disconnect({topic:i});else{const{message:s}=A("MISMATCHED_TOPIC",`Session or pairing topic not found: ${i}`);throw new Error(s)}}),b(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(i=>Ku(i,t)))),b(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),b(this,"authenticate",async(t,i)=>{var s;this.isInitialized(),this.isValidAuthenticate(t);const r=i&&this.client.core.linkModeSupportedApps.includes(i)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),n=r?te.link_mode:te.relay;n===te.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:a="",uri:c,domain:h,nonce:l,type:u,exp:p,nbf:y,methods:f=[],expiry:m}=t,d=[...t.resources||[]],{topic:g,uri:w}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:g,uri:w}});const E=await this.client.core.crypto.generateKeyPair(),I=us(E);if(await Promise.all([this.client.auth.authKeys.set(ds,{responseTopic:I,publicKey:E}),this.client.auth.pairingTopics.set(I,{topic:I,pairingTopic:g})]),await this.client.core.relayer.subscribe(I,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${g}`),f.length>0){const{namespace:_}=di(o[0]);let T=Gh(_,"request",f);ls(d)&&(T=Jh(T,d.pop())),d.push(T)}const C=m&&m>ue.wc_sessionAuthenticate.req.ttl?m:ue.wc_sessionAuthenticate.req.ttl,x={authPayload:{type:u??"caip122",chains:o,statement:a,aud:c,domain:h,version:"1",nonce:l,iat:new Date().toISOString(),exp:p,nbf:y,resources:d},requester:{publicKey:E,metadata:this.client.metadata},expiryTimestamp:he(C)},O={eip155:{chains:o,methods:[...new Set(["personal_sign",...f])],events:["chainChanged","accountsChanged"]}},v={requiredNamespaces:{},optionalNamespaces:O,relays:[{protocol:"irn"}],pairingTopic:g,proposer:{publicKey:E,metadata:this.client.metadata},expiryTimestamp:he(ue.wc_sessionPropose.req.ttl),id:mt()},{done:N,resolve:k,reject:q}=Ct(C,"Request expired"),D=mt(),j=Y("session_connect",v.id),$=Y("session_request",D),P=async({error:_,session:T})=>{this.events.off($,S),_?q(_):T&&k({session:T})},S=async _=>{var T,B,z;if(await this.deletePendingAuthRequest(D,{message:"fulfilled",code:0}),_.error){const oe=Q("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return _.error.code===oe.code?void 0:(this.events.off(j,P),q(_.error.message))}await this.deleteProposal(v.id),this.events.off(j,P);const{cacaos:M,responder:K}=_.result,se=[],ie=[];for(const oe of M){await ln({cacao:oe,projectId:this.client.core.projectId})||(this.client.logger.error(oe,"Signature verification failed"),q(Q("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:nt}=oe,gt=ls(nt.resources),ft=[sr(nt.iss)],yt=fs(nt.iss);if(gt){const He=un(gt),At=pn(gt);se.push(...He),ft.push(...At)}for(const He of ft)ie.push(`${He}:${yt}`)}const re=await this.client.core.crypto.generateSharedKey(E,K.publicKey);let be;se.length>0&&(be={topic:re,acknowledged:!0,self:{publicKey:E,metadata:this.client.metadata},peer:K,controller:K.publicKey,expiry:he(Jt),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:g,namespaces:jn([...new Set(se)],[...new Set(ie)]),transportType:n},await this.client.core.relayer.subscribe(re,{transportType:n}),await this.client.session.set(re,be),g&&await this.client.core.pairing.updateMetadata({topic:g,metadata:K.metadata}),be=this.client.session.get(re)),(T=this.client.metadata.redirect)!=null&&T.linkMode&&(B=K.metadata.redirect)!=null&&B.linkMode&&(z=K.metadata.redirect)!=null&&z.universal&&i&&(this.client.core.addLinkModeSupportedApp(K.metadata.redirect.universal),this.client.session.update(re,{transportType:te.link_mode})),k({auths:M,session:be})};this.events.once(j,P),this.events.once($,S);let R;try{if(r){const _=Dt("wc_sessionAuthenticate",x,D);this.client.core.history.set(g,_);const T=await this.client.core.crypto.encode("",_,{type:Zi,encoding:$t});R=rs(i,g,T)}else await Promise.all([this.sendRequest({topic:g,method:"wc_sessionAuthenticate",params:x,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:D}),this.sendRequest({topic:g,method:"wc_sessionPropose",params:v,expiry:ue.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:v.id})])}catch(_){throw this.events.off(j,P),this.events.off($,S),_}return await this.setProposal(v.id,v),await this.setAuthRequest(D,{request:_e(X({},x),{verifyContext:{}}),pairingTopic:g,transportType:n}),{uri:R??w,response:N}}),b(this,"approveSessionAuthenticate",async t=>{const{id:i,auths:s}=t,r=this.client.core.eventClient.createEvent({properties:{topic:i.toString(),trace:[Nt.authenticated_session_approve_started]}});try{this.isInitialized()}catch(m){throw r.setError(Ri.no_internet_connection),m}const n=this.getPendingAuthRequest(i);if(!n)throw r.setError(Ri.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${i}`);const o=n.transportType||te.relay;o===te.relay&&await this.confirmOnlineStateOrThrow();const a=n.requester.publicKey,c=await this.client.core.crypto.generateKeyPair(),h=us(a),l={type:dt,receiverPublicKey:a,senderPublicKey:c},u=[],p=[];for(const m of s){if(!await ln({cacao:m,projectId:this.client.core.projectId})){r.setError(Ri.invalid_cacao);const I=Q("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:i,topic:h,error:I,encodeOpts:l}),new Error(I.message)}r.addTrace(Nt.cacaos_verified);const{p:d}=m,g=ls(d.resources),w=[sr(d.iss)],E=fs(d.iss);if(g){const I=un(g),C=pn(g);u.push(...I),w.push(...C)}for(const I of w)p.push(`${I}:${E}`)}const y=await this.client.core.crypto.generateSharedKey(c,a);r.addTrace(Nt.create_authenticated_session_topic);let f;if((u==null?void 0:u.length)>0){f={topic:y,acknowledged:!0,self:{publicKey:c,metadata:this.client.metadata},peer:{publicKey:a,metadata:n.requester.metadata},controller:a,expiry:he(Jt),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:jn([...new Set(u)],[...new Set(p)]),transportType:o},r.addTrace(Nt.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(y,{transportType:o})}catch(m){throw r.setError(Ri.subscribe_authenticated_session_topic_failure),m}r.addTrace(Nt.subscribe_authenticated_session_topic_success),await this.client.session.set(y,f),r.addTrace(Nt.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(Nt.publishing_authenticated_session_approve);try{await this.sendResult({topic:h,id:i,result:{cacaos:s,responder:{publicKey:c,metadata:this.client.metadata}},encodeOpts:l,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,o)})}catch(m){throw r.setError(Ri.authenticated_session_approve_publish_failure),m}return await this.client.auth.requests.delete(i,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:f}}),b(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:i,reason:s}=t,r=this.getPendingAuthRequest(i);if(!r)throw new Error(`Could not find pending auth request with id ${i}`);r.transportType===te.relay&&await this.confirmOnlineStateOrThrow();const n=r.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=us(n),c={type:dt,receiverPublicKey:n,senderPublicKey:o};await this.sendError({id:i,topic:a,error:s,encodeOpts:c,rpcOpts:ue.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(i,{message:"rejected",code:0}),await this.client.proposal.delete(i,Q("USER_DISCONNECTED"))}),b(this,"formatAuthMessage",t=>{this.isInitialized();const{request:i,iss:s}=t;return Wo(i,s)}),b(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),b(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const i=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,o;return((n=r.peerMetadata)==null?void 0:n.url)&&((o=r.peerMetadata)==null?void 0:o.url)===t.peer.metadata.url&&r.topic&&r.topic!==i.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(i){this.client.logger.error(i)}}),b(this,"deleteSession",async t=>{var i;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:o=0}=t,{self:a}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,Q("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(go).catch(c=>this.client.logger.warn(c)),this.getPendingSessionRequests().forEach(c=>{c.topic===s&&this.deletePendingSessionRequest(c.id,Q("USER_DISCONNECTED"))}),s===((i=this.sessionRequestQueue.queue[0])==null?void 0:i.topic)&&(this.sessionRequestQueue.state=Ze.idle),n&&this.client.events.emit("session_delete",{id:o,topic:s})}),b(this,"deleteProposal",async(t,i)=>{if(i)try{const s=this.client.proposal.get(t),r=this.client.core.eventClient.getEvent({topic:s.pairingTopic});r==null||r.setError(xt.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,Q("USER_DISCONNECTED")),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),b(this,"deletePendingSessionRequest",async(t,i,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,i),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),s&&(this.sessionRequestQueue.state=Ze.idle,this.client.events.emit("session_request_expire",{id:t}))}),b(this,"deletePendingAuthRequest",async(t,i,s=!1)=>{await Promise.all([this.client.auth.requests.delete(t,i),s?Promise.resolve():this.client.core.expirer.del(t)])}),b(this,"setExpiry",async(t,i)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,i),await this.client.session.update(t,{expiry:i}))}),b(this,"setProposal",async(t,i)=>{this.client.core.expirer.set(t,he(ue.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,i)}),b(this,"setAuthRequest",async(t,i)=>{const{request:s,pairingTopic:r,transportType:n=te.relay}=i;this.client.core.expirer.set(t,s.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:t,pairingTopic:r,verifyContext:s.verifyContext,transportType:n})}),b(this,"setPendingSessionRequest",async t=>{const{id:i,topic:s,params:r,verifyContext:n}=t,o=r.request.expiryTimestamp||he(ue.wc_sessionRequest.req.ttl);this.client.core.expirer.set(i,o),await this.client.pendingRequest.set(i,{id:i,topic:s,params:r,verifyContext:n})}),b(this,"sendRequest",async t=>{const{topic:i,method:s,params:r,expiry:n,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:c,appLink:h,tvf:l}=t,u=Dt(s,r,a);let p;const y=!!h;try{const d=y?$t:We;p=await this.client.core.crypto.encode(i,u,{encoding:d})}catch(d){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${i} failed`),d}let f;if(ly.includes(s)){const d=tt(JSON.stringify(u)),g=tt(p);f=await this.client.core.verify.register({id:g,decryptedId:d})}const m=ue[s].req;if(m.attestation=f,n&&(m.ttl=n),o&&(m.id=o),this.client.core.history.set(i,u),y){const d=rs(h,i,p);await L.Linking.openURL(d,this.client.name)}else{const d=ue[s].req;n&&(d.ttl=n),o&&(d.id=o),d.tvf=_e(X({},l),{correlationId:u.id}),c?(d.internal=_e(X({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,p,d)):this.client.core.relayer.publish(i,p,d).catch(g=>this.client.logger.error(g))}return u.id}),b(this,"sendResult",async t=>{const{id:i,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:o,appLink:a}=t,c=bs(i,r);let h;const l=a&&typeof(L==null?void 0:L.Linking)<"u";try{const y=l?$t:We;h=await this.client.core.crypto.encode(s,c,_e(X({},o||{}),{encoding:y}))}catch(y){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),y}let u,p;try{u=await this.client.core.history.get(s,i);const y=u.request;try{this.shouldSetTVF(y.method,y.params)&&(p=this.getTVFParams(i,y.params,r))}catch(f){this.client.logger.warn("sendResult() -> getTVFParams() failed",f)}}catch(y){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${i}) failed`),y}if(l){const y=rs(a,s,h);await L.Linking.openURL(y,this.client.name)}else{const y=u.request.method,f=ue[y].res;f.tvf=_e(X({},p),{correlationId:i}),n?(f.internal=_e(X({},f.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,h,f)):this.client.core.relayer.publish(s,h,f).catch(m=>this.client.logger.error(m))}await this.client.core.history.resolve(c)}),b(this,"sendError",async t=>{const{id:i,topic:s,error:r,encodeOpts:n,rpcOpts:o,appLink:a}=t,c=To(i,r);let h;const l=a&&typeof(L==null?void 0:L.Linking)<"u";try{const p=l?$t:We;h=await this.client.core.crypto.encode(s,c,_e(X({},n||{}),{encoding:p}))}catch(p){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),p}let u;try{u=await this.client.core.history.get(s,i)}catch(p){throw this.client.logger.error(`sendError() -> history.get(${s}, ${i}) failed`),p}if(l){const p=rs(a,s,h);await L.Linking.openURL(p,this.client.name)}else{const p=u.request.method,y=o||ue[p].res;this.client.core.relayer.publish(s,h,y)}await this.client.core.history.resolve(c)}),b(this,"cleanup",async()=>{const t=[],i=[];this.client.session.getAll().forEach(s=>{let r=!1;bt(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{bt(s.expiryTimestamp)&&i.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...i.map(s=>this.deleteProposal(s))])}),b(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),b(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),b(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===Ze.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=Ze.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(i){this.client.logger.warn(i)}}this.requestQueue.state=Ze.idle}),b(this,"processRequest",async t=>{const{topic:i,payload:s,attestation:r,transportType:n,encryptedId:o}=t,a=s.method;if(!this.shouldIgnorePairingRequest({topic:i,requestMethod:a}))switch(a){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:i,payload:s,attestation:r,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(i,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(i,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(i,s);case"wc_sessionPing":return await this.onSessionPingRequest(i,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(i,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:i,payload:s,attestation:r,encryptedId:o,transportType:n});case"wc_sessionEvent":return await this.onSessionEventRequest(i,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:i,payload:s,attestation:r,encryptedId:o,transportType:n});default:return this.client.logger.info(`Unsupported request method ${a}`)}}),b(this,"onRelayEventResponse",async t=>{const{topic:i,payload:s,transportType:r}=t,n=(await this.client.core.history.get(i,s.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(i,s,r);case"wc_sessionSettle":return this.onSessionSettleResponse(i,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(i,s);case"wc_sessionExtend":return this.onSessionExtendResponse(i,s);case"wc_sessionPing":return this.onSessionPingResponse(i,s);case"wc_sessionRequest":return this.onSessionRequestResponse(i,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(i,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}}),b(this,"onRelayEventUnknownPayload",t=>{const{topic:i}=t,{message:s}=A("MISSING_OR_INVALID",`Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),b(this,"shouldIgnorePairingRequest",t=>{const{topic:i,requestMethod:s}=t,r=this.expectedPairingMethodMap.get(i);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),b(this,"onSessionProposeRequest",async t=>{const{topic:i,payload:s,attestation:r,encryptedId:n}=t,{params:o,id:a}=s;try{const c=this.client.core.eventClient.getEvent({topic:i});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),c==null||c.setError(ht.proposal_listener_not_found)),this.isValidConnect(X({},s.params));const h=o.expiryTimestamp||he(ue.wc_sessionPropose.req.ttl),l=X({id:a,pairingTopic:i,expiryTimestamp:h},o);await this.setProposal(a,l);const u=await this.getVerifyContext({attestationId:r,hash:tt(JSON.stringify(s)),encryptedId:n,metadata:l.proposer.metadata});c==null||c.addTrace(Xe.emit_session_proposal),this.client.events.emit("session_proposal",{id:a,params:l,verifyContext:u})}catch(c){await this.sendError({id:a,topic:i,error:c,rpcOpts:ue.wc_sessionPropose.autoReject}),this.client.logger.error(c)}}),b(this,"onSessionProposeResponse",async(t,i,s)=>{const{id:r}=i;if(ct(i)){const{result:n}=i;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const o=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const a=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const c=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const h=await this.client.core.crypto.generateSharedKey(a,c);this.pendingSessions.set(r,{sessionTopic:h,pairingTopic:t,proposalId:r,publicKey:a});const l=await this.client.core.relayer.subscribe(h,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:l}),await this.client.core.pairing.activate({topic:t})}else if(et(i)){await this.client.proposal.delete(r,Q("USER_DISCONNECTED"));const n=Y("session_connect",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners, 954`);this.events.emit(n,{error:i.error})}}),b(this,"onSessionSettleRequest",async(t,i)=>{const{id:s,params:r}=i;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:o,expiry:a,namespaces:c,sessionProperties:h,scopedProperties:l,sessionConfig:u}=i.params,p=[...this.pendingSessions.values()].find(m=>m.sessionTopic===t);if(!p)return this.client.logger.error(`Pending session not found for topic ${t}`);const y=this.client.proposal.get(p.proposalId),f=_e(X(X(X({topic:t,relay:n,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:p.pairingTopic,requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces,controller:o.publicKey,self:{publicKey:p.publicKey,metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},h&&{sessionProperties:h}),l&&{scopedProperties:l}),u&&{sessionConfig:u}),{transportType:te.relay});await this.client.session.set(f.topic,f),await this.setExpiry(f.topic,f.expiry),await this.client.core.pairing.updateMetadata({topic:p.pairingTopic,metadata:f.peer.metadata}),this.client.events.emit("session_connect",{session:f}),this.events.emit(Y("session_connect",p.proposalId),{session:f}),this.pendingSessions.delete(p.proposalId),this.deleteProposal(p.proposalId,!1),this.cleanupDuplicatePairings(f),await this.sendResult({id:i.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}}),b(this,"onSessionSettleResponse",async(t,i)=>{const{id:s}=i;ct(i)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(Y("session_approve",s),{})):et(i)&&(await this.client.session.delete(t,Q("USER_DISCONNECTED")),this.events.emit(Y("session_approve",s),{error:i.error}))}),b(this,"onSessionUpdateRequest",async(t,i)=>{const{params:s,id:r}=i;try{const n=`${t}_session_update`,o=Ni.get(n);if(o&&this.isRequestOutOfSync(o,r)){this.client.logger.warn(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:Q("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(X({topic:t},s));try{Ni.set(n,r),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(a){throw Ni.delete(n),a}this.client.events.emit("session_update",{id:r,topic:t,params:s})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}}),b(this,"isRequestOutOfSync",(t,i)=>i.toString().slice(0,-3)<t.toString().slice(0,-3)),b(this,"onSessionUpdateResponse",(t,i)=>{const{id:s}=i,r=Y("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);ct(i)?this.events.emit(Y("session_update",s),{}):et(i)&&this.events.emit(Y("session_update",s),{error:i.error})}),b(this,"onSessionExtendRequest",async(t,i)=>{const{id:s}=i;try{this.isValidExtend({topic:t}),await this.setExpiry(t,he(Jt)),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}}),b(this,"onSessionExtendResponse",(t,i)=>{const{id:s}=i,r=Y("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);ct(i)?this.events.emit(Y("session_extend",s),{}):et(i)&&this.events.emit(Y("session_extend",s),{error:i.error})}),b(this,"onSessionPingRequest",async(t,i)=>{const{id:s}=i;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}}),b(this,"onSessionPingResponse",(t,i)=>{const{id:s}=i,r=Y("session_ping",s);setTimeout(()=>{if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners 2176`);ct(i)?this.events.emit(Y("session_ping",s),{}):et(i)&&this.events.emit(Y("session_ping",s),{error:i.error})},500)}),b(this,"onSessionDeleteRequest",async(t,i)=>{const{id:s}=i;try{this.isValidDisconnect({topic:t,reason:i.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(de.publish,async()=>{r(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:Q("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}}),b(this,"onSessionRequest",async t=>{var i,s,r;const{topic:n,payload:o,attestation:a,encryptedId:c,transportType:h}=t,{id:l,params:u}=o;try{await this.isValidRequest(X({topic:n},u));const p=this.client.session.get(n),y=await this.getVerifyContext({attestationId:a,hash:tt(JSON.stringify(Dt("wc_sessionRequest",u,l))),encryptedId:c,metadata:p.peer.metadata,transportType:h}),f={id:l,topic:n,params:u,verifyContext:y};await this.setPendingSessionRequest(f),h===te.link_mode&&(i=p.peer.metadata.redirect)!=null&&i.universal&&this.client.core.addLinkModeSupportedApp((s=p.peer.metadata.redirect)==null?void 0:s.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(f):(this.addSessionRequestToSessionRequestQueue(f),this.processSessionRequestQueue())}catch(p){await this.sendError({id:l,topic:n,error:p}),this.client.logger.error(p)}}),b(this,"onSessionRequestResponse",(t,i)=>{const{id:s}=i,r=Y("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);ct(i)?this.events.emit(Y("session_request",s),{result:i.result}):et(i)&&this.events.emit(Y("session_request",s),{error:i.error})}),b(this,"onSessionEventRequest",async(t,i)=>{const{id:s,params:r}=i;try{const n=`${t}_session_event_${r.event.name}`,o=Ni.get(n);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(X({topic:t},r)),this.client.events.emit("session_event",{id:s,topic:t,params:r}),Ni.set(n,s)}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}}),b(this,"onSessionAuthenticateResponse",(t,i)=>{const{id:s}=i;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:i}),ct(i)?this.events.emit(Y("session_request",s),{result:i.result}):et(i)&&this.events.emit(Y("session_request",s),{error:i.error})}),b(this,"onSessionAuthenticateRequest",async t=>{var i;const{topic:s,payload:r,attestation:n,encryptedId:o,transportType:a}=t;try{const{requester:c,authPayload:h,expiryTimestamp:l}=r.params,u=await this.getVerifyContext({attestationId:n,hash:tt(JSON.stringify(r)),encryptedId:o,metadata:c.metadata,transportType:a}),p={requester:c,pairingTopic:s,id:r.id,authPayload:h,verifyContext:u,expiryTimestamp:l};await this.setAuthRequest(r.id,{request:p,pairingTopic:s,transportType:a}),a===te.link_mode&&(i=c.metadata.redirect)!=null&&i.universal&&this.client.core.addLinkModeSupportedApp(c.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:r.params,id:r.id,verifyContext:u})}catch(c){this.client.logger.error(c);const h=r.params.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),u=this.getAppLinkIfEnabled(r.params.requester.metadata,a),p={type:dt,receiverPublicKey:h,senderPublicKey:l};await this.sendError({id:r.id,topic:s,error:c,encodeOpts:p,rpcOpts:ue.wc_sessionAuthenticate.autoReject,appLink:u})}}),b(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),b(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=Ze.idle,this.processSessionRequestQueue()},(0,W.toMiliseconds)(this.requestQueueDelay))}),b(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:i})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,o=Y("session_request",n);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(Y("session_request",r.request.id),{error:i})})}),b(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===Ze.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=Ze.active,this.emitSessionRequest(t)}catch(i){this.client.logger.error(i)}}),b(this,"emitSessionRequest",t=>{this.client.events.emit("session_request",t)}),b(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const i=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);i&&this.onSessionProposeRequest({topic:t.topic,payload:Dt("wc_sessionPropose",_e(X({},i),{requiredNamespaces:i.requiredNamespaces,optionalNamespaces:i.optionalNamespaces,relays:i.relays,proposer:i.proposer,sessionProperties:i.sessionProperties,scopedProperties:i.scopedProperties}),i.id)})}),b(this,"isValidConnect",async t=>{if(!Oe(t)){const{message:c}=A("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(c)}const{pairingTopic:i,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,scopedProperties:o,relays:a}=t;if(we(i)||await this.isValidPairingTopic(i),!sp(a,!0)){const{message:c}=A("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}if(!we(s)&&Pt(s)!==0){const c="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(c):this.client.logger.warn(c),this.validateNamespaces(s,"requiredNamespaces")}if(!we(r)&&Pt(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),we(n)||this.validateSessionProps(n,"sessionProperties"),!we(o)){this.validateSessionProps(o,"scopedProperties");const c=Object.keys(s||{}).concat(Object.keys(r||{}));if(!Object.keys(o).every(h=>c.includes(h)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(c)}`)}}),b(this,"validateNamespaces",(t,i)=>{const s=ip(t,"connect()",i);if(s)throw new Error(s.message)}),b(this,"isValidApprove",async t=>{if(!Oe(t))throw new Error(A("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:i,namespaces:s,relayProtocol:r,sessionProperties:n,scopedProperties:o}=t;this.checkRecentlyDeleted(i),await this.isValidProposalId(i);const a=this.client.proposal.get(i),c=Bs(s,"approve()");if(c)throw new Error(c.message);const h=Ln(a.requiredNamespaces,s,"approve()");if(h)throw new Error(h.message);if(!ce(r,!0)){const{message:l}=A("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(l)}if(we(n)||this.validateSessionProps(n,"sessionProperties"),!we(o)){this.validateSessionProps(o,"scopedProperties");const l=new Set(Object.keys(s));if(!Object.keys(o).every(u=>l.has(u)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(l).join(", ")}`)}}),b(this,"isValidReject",async t=>{if(!Oe(t)){const{message:r}=A("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:i,reason:s}=t;if(this.checkRecentlyDeleted(i),await this.isValidProposalId(i),!np(s)){const{message:r}=A("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}}),b(this,"isValidSessionSettleRequest",t=>{if(!Oe(t)){const{message:c}=A("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(c)}const{relay:i,controller:s,namespaces:r,expiry:n}=t;if(!ba(i)){const{message:c}=A("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(c)}const o=Yu(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=Bs(r,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(bt(n)){const{message:c}=A("EXPIRED","onSessionSettleRequest()");throw new Error(c)}}),b(this,"isValidUpdate",async t=>{if(!Oe(t)){const{message:a}=A("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(a)}const{topic:i,namespaces:s}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i);const r=this.client.session.get(i),n=Bs(s,"update()");if(n)throw new Error(n.message);const o=Ln(r.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)}),b(this,"isValidExtend",async t=>{if(!Oe(t)){const{message:s}=A("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:i}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i)}),b(this,"isValidRequest",async t=>{if(!Oe(t)){const{message:a}=A("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(a)}const{topic:i,request:s,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i);const{namespaces:o}=this.client.session.get(i);if(!Mn(o,r)){const{message:a}=A("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(a)}if(!op(s)){const{message:a}=A("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(a)}if(!hp(o,r,s.method)){const{message:a}=A("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(a)}if(n&&!dp(n,Ws)){const{message:a}=A("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${Ws.min} and ${Ws.max}`);throw new Error(a)}}),b(this,"isValidRespond",async t=>{var i;if(!Oe(t)){const{message:n}=A("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:s,response:r}=t;try{await this.isValidSessionTopic(s)}catch(n){throw(i=t==null?void 0:t.response)!=null&&i.id&&this.cleanupAfterResponse(t),n}if(!ap(r)){const{message:n}=A("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}}),b(this,"isValidPing",async t=>{if(!Oe(t)){const{message:s}=A("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:i}=t;await this.isValidSessionOrPairingTopic(i)}),b(this,"isValidEmit",async t=>{if(!Oe(t)){const{message:o}=A("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(o)}const{topic:i,event:s,chainId:r}=t;await this.isValidSessionTopic(i);const{namespaces:n}=this.client.session.get(i);if(!Mn(n,r)){const{message:o}=A("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(o)}if(!cp(s)){const{message:o}=A("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!lp(n,r,s.name)){const{message:o}=A("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}}),b(this,"isValidDisconnect",async t=>{if(!Oe(t)){const{message:s}=A("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:i}=t;await this.isValidSessionOrPairingTopic(i)}),b(this,"isValidAuthenticate",t=>{const{chains:i,uri:s,domain:r,nonce:n}=t;if(!Array.isArray(i)||i.length===0)throw new Error("chains is required and must be a non-empty array");if(!ce(s,!1))throw new Error("uri is required parameter");if(!ce(r,!1))throw new Error("domain is required parameter");if(!ce(n,!1))throw new Error("nonce is required parameter");if([...new Set(i.map(a=>di(a).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=di(i[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),b(this,"getVerifyContext",async t=>{const{attestationId:i,hash:s,encryptedId:r,metadata:n,transportType:o}=t,a={verified:{verifyUrl:n.verifyUrl||Li,validation:"UNKNOWN",origin:n.url||""}};try{if(o===te.link_mode){const h=this.getAppLinkIfEnabled(n,o);return a.verified.validation=h&&new URL(h).origin===new URL(n.url).origin?"VALID":"INVALID",a}const c=await this.client.core.verify.resolve({attestationId:i,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});c&&(a.verified.origin=c.origin,a.verified.isScam=c.isScam,a.verified.validation=c.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(c){this.client.logger.warn(c)}return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`),a}),b(this,"validateSessionProps",(t,i)=>{Object.values(t).forEach((s,r)=>{if(s==null){const{message:n}=A("MISSING_OR_INVALID",`${i} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[r]}`);throw new Error(n)}})}),b(this,"getPendingAuthRequest",t=>{const i=this.client.auth.requests.get(t);return typeof i=="object"?i:void 0}),b(this,"addToRecentlyDeleted",(t,i)=>{if(this.recentlyDeletedMap.set(t,i),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}}),b(this,"checkRecentlyDeleted",t=>{const i=this.recentlyDeletedMap.get(t);if(i){const{message:s}=A("MISSING_OR_INVALID",`Record was recently deleted - ${i}: ${t}`);throw new Error(s)}}),b(this,"isLinkModeEnabled",(t,i)=>{var s,r,n,o,a,c,h,l,u;return!t||i!==te.link_mode?!1:((r=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:r.linkMode)===!0&&((o=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:o.universal)!==void 0&&((c=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:c.universal)!==""&&((h=t==null?void 0:t.redirect)==null?void 0:h.universal)!==void 0&&((l=t==null?void 0:t.redirect)==null?void 0:l.universal)!==""&&((u=t==null?void 0:t.redirect)==null?void 0:u.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(L==null?void 0:L.Linking)<"u"}),b(this,"getAppLinkIfEnabled",(t,i)=>{var s;return this.isLinkModeEnabled(t,i)?(s=t==null?void 0:t.redirect)==null?void 0:s.universal:void 0}),b(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const i=en(t,"topic")||"",s=decodeURIComponent(en(t,"wc_ev")||""),r=this.client.session.keys.includes(i);r&&this.client.session.update(i,{transportType:te.link_mode}),this.client.core.dispatchEnvelope({topic:i,message:s,sessionExists:r})}),b(this,"registerLinkModeListeners",async()=>{var t;if(Rr()||Ot()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const i=L==null?void 0:L.Linking;if(typeof i<"u"){i.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await i.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),b(this,"shouldSetTVF",(t,i)=>{if(!i||t!=="wc_sessionRequest")return!1;const{request:s}=i;return Object.keys(yo).includes(s.method)}),b(this,"getTVFParams",(t,i,s)=>{var r,n;try{const o=i.request.method,a=this.extractTxHashesFromResult(o,s);return _e(X({correlationId:t,rpcMethods:[o],chainId:i.chainId},this.isValidContractData(i.request.params)&&{contractAddresses:[(n=(r=i.request.params)==null?void 0:r[0])==null?void 0:n.to]}),{txHashes:a})}catch(o){this.client.logger.warn("Error getting TVF params",o)}return{}}),b(this,"isValidContractData",t=>{var i;if(!t)return!1;try{const s=(t==null?void 0:t.data)||((i=t==null?void 0:t[0])==null?void 0:i.data);if(!s.startsWith("0x"))return!1;const r=s.slice(2);return/^[0-9a-fA-F]*$/.test(r)?r.length%2===0:!1}catch{}return!1}),b(this,"extractTxHashesFromResult",(t,i)=>{try{const s=yo[t];if(typeof i=="string")return[i];const r=i[s.key];if(It(r))return t==="solana_signAllTransactions"?r.map(n=>Th(n)):r;if(typeof r=="string")return[r]}catch(s){this.client.logger.warn("Error extracting tx hashes from result",s)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[i,s]of Object.entries(t))for(const r of s)try{await this.onProviderMessageEvent({topic:i,message:r,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${i}, message: ${r}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=A("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(de.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:i,attestation:s,transportType:r}=e,{publicKey:n}=this.client.auth.authKeys.keys.includes(ds)?this.client.auth.authKeys.get(ds):{responseTopic:void 0,publicKey:void 0};try{const o=await this.client.core.crypto.decode(t,i,{receiverPublicKey:n,encoding:r===te.link_mode?$t:We});xr(o)?(this.client.core.history.set(t,o),await this.onRelayEventRequest({topic:t,payload:o,attestation:s,transportType:r,encryptedId:tt(i)})):Nr(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:t,payload:o,transportType:r}),this.client.core.history.delete(t,o.id)):await this.onRelayEventUnknownPayload({topic:t,payload:o,transportType:r}),await this.client.core.relayer.messages.ack(t,i)}catch(o){this.client.logger.error(o)}}registerExpirerEvents(){this.client.core.expirer.on(Me.expired,async e=>{const{topic:t,id:i}=Mo(e.target);if(i&&this.client.pendingRequest.keys.includes(i))return await this.deletePendingSessionRequest(i,A("EXPIRED"),!0);if(i&&this.client.auth.requests.keys.includes(i))return await this.deletePendingAuthRequest(i,A("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):i&&(await this.deleteProposal(i,!0),this.client.events.emit("proposal_expire",{id:i}))})}registerPairingEvents(){this.client.core.pairing.events.on(Tt.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(Tt.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!ce(e,!1)){const{message:t}=A("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=A("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if(bt(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=A("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!ce(e,!1)){const{message:t}=A("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=A("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if(bt(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=A("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=A("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if(ce(e,!1)){const{message:t}=A("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=A("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!rp(e)){const{message:t}=A("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=A("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if(bt(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=A("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}},Ey=class extends zt{constructor(e,t){super(e,t,oy,Lr),this.core=e,this.logger=t}},_y=class extends zt{constructor(e,t){super(e,t,ay,Lr),this.core=e,this.logger=t}},Iy=class extends zt{constructor(e,t){super(e,t,hy,Lr,i=>i.id),this.core=e,this.logger=t}},Py=class extends zt{constructor(e,t){super(e,t,dy,xs,()=>ds),this.core=e,this.logger=t}},Sy=class extends zt{constructor(e,t){super(e,t,gy,xs),this.core=e,this.logger=t}},Oy=class extends zt{constructor(e,t){super(e,t,fy,xs,i=>i.id),this.core=e,this.logger=t}},Ay=Object.defineProperty,xy=(e,t,i)=>t in e?Ay(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Js=(e,t,i)=>xy(e,typeof t!="symbol"?t+"":t,i),Ny=class{constructor(e,t){this.core=e,this.logger=t,Js(this,"authKeys"),Js(this,"pairingTopics"),Js(this,"requests"),this.authKeys=new Py(this.core,this.logger),this.pairingTopics=new Sy(this.core,this.logger),this.requests=new Oy(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}},Cy=Object.defineProperty,Ry=(e,t,i)=>t in e?Cy(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,V=(e,t,i)=>Ry(e,typeof t!="symbol"?t+"":t,i),Ty=class Ba extends Cc{constructor(t){super(t),V(this,"protocol",Ua),V(this,"version",Ma),V(this,"name",Gs.name),V(this,"metadata"),V(this,"core"),V(this,"logger"),V(this,"events",new ja.EventEmitter),V(this,"engine"),V(this,"session"),V(this,"proposal"),V(this,"pendingRequest"),V(this,"auth"),V(this,"signConfig"),V(this,"on",(s,r)=>this.events.on(s,r)),V(this,"once",(s,r)=>this.events.once(s,r)),V(this,"off",(s,r)=>this.events.off(s,r)),V(this,"removeListener",(s,r)=>this.events.removeListener(s,r)),V(this,"removeAllListeners",s=>this.events.removeAllListeners(s)),V(this,"connect",async s=>{try{return await this.engine.connect(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"pair",async s=>{try{return await this.engine.pair(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"approve",async s=>{try{return await this.engine.approve(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"reject",async s=>{try{return await this.engine.reject(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"update",async s=>{try{return await this.engine.update(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"extend",async s=>{try{return await this.engine.extend(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"request",async s=>{try{return await this.engine.request(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"respond",async s=>{try{return await this.engine.respond(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"ping",async s=>{try{return await this.engine.ping(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"emit",async s=>{try{return await this.engine.emit(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"disconnect",async s=>{try{return await this.engine.disconnect(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"find",s=>{try{return this.engine.find(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}}),V(this,"authenticate",async(s,r)=>{try{return await this.engine.authenticate(s,r)}catch(n){throw this.logger.error(n.message),n}}),V(this,"formatAuthMessage",s=>{try{return this.engine.formatAuthMessage(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"approveSessionAuthenticate",async s=>{try{return await this.engine.approveSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),V(this,"rejectSessionAuthenticate",async s=>{try{return await this.engine.rejectSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),this.name=(t==null?void 0:t.name)||Gs.name,this.metadata=Fc(t==null?void 0:t.metadata),this.signConfig=t==null?void 0:t.signConfig;const i=typeof(t==null?void 0:t.logger)<"u"&&typeof(t==null?void 0:t.logger)!="string"?t.logger:(0,Ar.default)($s({level:(t==null?void 0:t.logger)||Gs.logger}));this.core=(t==null?void 0:t.core)||new ny(t),this.logger=Pe(i,this.name),this.session=new _y(this.core,this.logger),this.proposal=new Ey(this.core,this.logger),this.pendingRequest=new Iy(this.core,this.logger),this.engine=new $y(this),this.auth=new Ny(this.core,this.logger)}static async init(t){const i=new Ba(t);return await i.initialize(),i}get context(){return ke(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},(0,W.toMiliseconds)(W.ONE_SECOND))}catch(t){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(t.message),t}}};Or();var qy=rt(vs());const wo="error",Dy="wss://relay.walletconnect.org",ky="wc",jy="universal_provider",os=`${ky}@2:${jy}:`,za="https://rpc.walletconnect.org/v1/",ai="generic",Uy=`${za}bundler`,ze={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function My(){}function Br(e){return e==null||typeof e!="object"&&typeof e!="function"}function zr(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}function Ly(e){if(Br(e))return e;if(Array.isArray(e)||zr(e)||e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer)return e.slice(0);const t=Object.getPrototypeOf(e),i=t.constructor;if(e instanceof Date||e instanceof Map||e instanceof Set)return new i(e);if(e instanceof RegExp){const s=new i(e);return s.lastIndex=e.lastIndex,s}if(e instanceof DataView)return new i(e.buffer.slice(0));if(e instanceof Error){const s=new i(e.message);return s.stack=e.stack,s.name=e.name,s.cause=e.cause,s}if(typeof File<"u"&&e instanceof File)return new i([e],e.name,{type:e.type,lastModified:e.lastModified});if(typeof e=="object"){const s=Object.create(t);return Object.assign(s,e)}return e}function vo(e){return typeof e=="object"&&e!==null}function Ha(e){return Object.getOwnPropertySymbols(e).filter(t=>Object.prototype.propertyIsEnumerable.call(e,t))}function Va(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const By="[object RegExp]",Ka="[object String]",Fa="[object Number]",Ga="[object Boolean]",Wa="[object Arguments]",zy="[object Symbol]",Hy="[object Date]",Vy="[object Map]",Ky="[object Set]",Fy="[object Array]",Gy="[object ArrayBuffer]",Wy="[object Object]",Jy="[object DataView]",Yy="[object Uint8Array]",Qy="[object Uint8ClampedArray]",Zy="[object Uint16Array]",Xy="[object Uint32Array]",em="[object Int8Array]",tm="[object Int16Array]",im="[object Int32Array]",sm="[object Float32Array]",rm="[object Float64Array]";function nm(e,t){return ui(e,void 0,e,new Map,t)}function ui(e,t,i,s=new Map,r=void 0){const n=r==null?void 0:r(e,t,i,s);if(n!=null)return n;if(Br(e))return e;if(s.has(e))return s.get(e);if(Array.isArray(e)){const o=new Array(e.length);s.set(e,o);for(let a=0;a<e.length;a++)o[a]=ui(e[a],a,i,s,r);return Object.hasOwn(e,"index")&&(o.index=e.index),Object.hasOwn(e,"input")&&(o.input=e.input),o}if(e instanceof Date)return new Date(e.getTime());if(e instanceof RegExp){const o=new RegExp(e.source,e.flags);return o.lastIndex=e.lastIndex,o}if(e instanceof Map){const o=new Map;s.set(e,o);for(const[a,c]of e)o.set(a,ui(c,a,i,s,r));return o}if(e instanceof Set){const o=new Set;s.set(e,o);for(const a of e)o.add(ui(a,void 0,i,s,r));return o}if(typeof Ee<"u"&&Ee.isBuffer(e))return e.subarray();if(zr(e)){const o=new(Object.getPrototypeOf(e)).constructor(e.length);s.set(e,o);for(let a=0;a<e.length;a++)o[a]=ui(e[a],a,i,s,r);return o}if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer)return e.slice(0);if(e instanceof DataView){const o=new DataView(e.buffer.slice(0),e.byteOffset,e.byteLength);return s.set(e,o),qt(o,e,i,s,r),o}if(typeof File<"u"&&e instanceof File){const o=new File([e],e.name,{type:e.type});return s.set(e,o),qt(o,e,i,s,r),o}if(e instanceof Blob){const o=new Blob([e],{type:e.type});return s.set(e,o),qt(o,e,i,s,r),o}if(e instanceof Error){const o=new e.constructor;return s.set(e,o),o.message=e.message,o.name=e.name,o.stack=e.stack,o.cause=e.cause,qt(o,e,i,s,r),o}if(typeof e=="object"&&om(e)){const o=Object.create(Object.getPrototypeOf(e));return s.set(e,o),qt(o,e,i,s,r),o}return e}function qt(e,t,i=e,s,r){const n=[...Object.keys(t),...Ha(t)];for(let o=0;o<n.length;o++){const a=n[o],c=Object.getOwnPropertyDescriptor(e,a);(c==null||c.writable)&&(e[a]=ui(t[a],a,i,s,r))}}function om(e){switch(Va(e)){case Wa:case Fy:case Gy:case Jy:case Ga:case Hy:case sm:case rm:case em:case tm:case im:case Vy:case Fa:case Wy:case By:case Ky:case Ka:case zy:case Yy:case Qy:case Zy:case Xy:return!0;default:return!1}}function am(e,t){return nm(e,(i,s,r,n)=>{const o=t==null?void 0:t(i,s,r,n);if(o!=null)return o;if(typeof e=="object")switch(Object.prototype.toString.call(e)){case Fa:case Ka:case Ga:{const a=new e.constructor(e==null?void 0:e.valueOf());return qt(a,e),a}case Wa:{const a={};return qt(a,e),a.length=e.length,a[Symbol.iterator]=e[Symbol.iterator],a}default:return}})}function bo(e){return am(e)}function $o(e){return e!==null&&typeof e=="object"&&Va(e)==="[object Arguments]"}function cm(e){return zr(e)}function hm(e){if(typeof e!="object"||e==null)return!1;if(Object.getPrototypeOf(e)===null)return!0;if(Object.prototype.toString.call(e)!=="[object Object]"){var t;const s=e[Symbol.toStringTag];return s==null||!(!((t=Object.getOwnPropertyDescriptor(e,Symbol.toStringTag))===null||t===void 0)&&t.writable)?!1:e.toString()===`[object ${s}]`}let i=e;for(;Object.getPrototypeOf(i)!==null;)i=Object.getPrototypeOf(i);return Object.getPrototypeOf(e)===i}function lm(e,...t){const i=t.slice(0,-1),s=t[t.length-1];let r=e;for(let n=0;n<i.length;n++){const o=i[n];r=Ir(r,o,s,new Map)}return r}function Ir(e,t,i,s){if(Br(e)&&(e=Object(e)),t==null||typeof t!="object")return e;if(s.has(t))return Ly(s.get(t));if(s.set(t,e),Array.isArray(t)){t=t.slice();for(let n=0;n<t.length;n++)t[n]=t[n]??void 0}const r=[...Object.keys(t),...Ha(t)];for(let n=0;n<r.length;n++){const o=r[n];let a=t[o],c=e[o];if($o(a)&&(a={...a}),$o(c)&&(c={...c}),typeof Ee<"u"&&Ee.isBuffer(a)&&(a=bo(a)),Array.isArray(a))if(typeof c=="object"&&c!=null){const l=[],u=Reflect.ownKeys(c);for(let p=0;p<u.length;p++){const y=u[p];l[y]=c[y]}c=l}else c=[];const h=i(c,a,o,e,t,s);h!=null?e[o]=h:Array.isArray(a)||vo(c)&&vo(a)?e[o]=Ir(c,a,i,s):c==null&&hm(a)?e[o]=Ir({},a,i,s):c==null&&cm(a)?e[o]=bo(a):(c===void 0||a!==void 0)&&(e[o]=a)}return e}function um(e,...t){return lm(e,...t,My)}var pm=Object.defineProperty,dm=Object.defineProperties,gm=Object.getOwnPropertyDescriptors,Eo=Object.getOwnPropertySymbols,fm=Object.prototype.hasOwnProperty,ym=Object.prototype.propertyIsEnumerable,_o=(e,t,i)=>t in e?pm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,as=(e,t)=>{for(var i in t||(t={}))fm.call(t,i)&&_o(e,i,t[i]);if(Eo)for(var i of Eo(t))ym.call(t,i)&&_o(e,i,t[i]);return e},mm=(e,t)=>dm(e,gm(t));function De(e,t,i){var s;const r=di(e);return((s=t.rpcMap)==null?void 0:s[r.reference])||`${za}?chainId=${r.namespace}:${r.reference}&projectId=${i}`}function Ht(e){return e.includes(":")?e.split(":")[1]:e}function Ja(e){return e.map(t=>`${t.split(":")[0]}:${t.split(":")[1]}`)}function wm(e,t){const i=Object.keys(t.namespaces).filter(r=>r.includes(e));if(!i.length)return[];const s=[];return i.forEach(r=>{const n=t.namespaces[r].accounts;s.push(...n)}),s}function cs(e={},t={}){const i=Io(e),s=Io(t);return um(i,s)}function Io(e){var t,i,s,r,n;const o={};if(!Pt(e))return o;for(const[a,c]of Object.entries(e)){const h=Os(a)?[a]:c.chains,l=c.methods||[],u=c.events||[],p=c.rpcMap||{},y=li(a);o[y]=mm(as(as({},o[y]),c),{chains:it(h,(t=o[y])==null?void 0:t.chains),methods:it(l,(i=o[y])==null?void 0:i.methods),events:it(u,(s=o[y])==null?void 0:s.events)}),(Pt(p)||Pt(((r=o[y])==null?void 0:r.rpcMap)||{}))&&(o[y].rpcMap=as(as({},p),(n=o[y])==null?void 0:n.rpcMap))}return o}function Po(e){return e.includes(":")?e.split(":")[2]:e}function So(e){const t={};for(const[i,s]of Object.entries(e)){const r=s.methods||[],n=s.events||[],o=s.accounts||[],a=Os(i)?[i]:s.chains?s.chains:Ja(s.accounts);t[i]={chains:a,methods:r,events:n,accounts:o}}return t}function Ys(e){return typeof e=="number"?e:e.includes("0x")?parseInt(e,16):(e=e.includes(":")?e.split(":")[1]:e,isNaN(Number(e))?e:Number(e))}const Ya={},J=e=>Ya[e],Qs=(e,t)=>{Ya[e]=t};var vm=Object.defineProperty,bm=(e,t,i)=>t in e?vm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Yt=(e,t,i)=>bm(e,typeof t!="symbol"?t+"":t,i),$m=class{constructor(e){Yt(this,"name","polkadot"),Yt(this,"client"),Yt(this,"httpProviders"),Yt(this,"events"),Yt(this,"namespace"),Yt(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=Ht(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},Em=Object.defineProperty,_m=Object.defineProperties,Im=Object.getOwnPropertyDescriptors,Oo=Object.getOwnPropertySymbols,Pm=Object.prototype.hasOwnProperty,Sm=Object.prototype.propertyIsEnumerable,Pr=(e,t,i)=>t in e?Em(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ao=(e,t)=>{for(var i in t||(t={}))Pm.call(t,i)&&Pr(e,i,t[i]);if(Oo)for(var i of Oo(t))Sm.call(t,i)&&Pr(e,i,t[i]);return e},xo=(e,t)=>_m(e,Im(t)),Qt=(e,t,i)=>Pr(e,typeof t!="symbol"?t+"":t,i),Om=class{constructor(e){Qt(this,"name","eip155"),Qt(this,"client"),Qt(this,"chainId"),Qt(this,"namespace"),Qt(this,"httpProviders"),Qt(this,"events"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const i=t||De(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=parseInt(Ht(t));e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}async handleSwitchChain(e){var t,i;let s=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";s=s.startsWith("0x")?s:`0x${s}`;const r=parseInt(s,16);if(this.isChainApproved(r))this.setDefaultChain(`${r}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:s}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${r}`);else throw new Error(`Failed to switch to chain 'eip155:${r}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,i,s,r,n;const o=(i=(t=e.request)==null?void 0:t.params)==null?void 0:i[0],a=((r=(s=e.request)==null?void 0:s.params)==null?void 0:r[1])||[],c=`${o}${a.join(",")}`;if(!o)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const h=this.client.session.get(e.topic),l=((n=h==null?void 0:h.sessionProperties)==null?void 0:n.capabilities)||{};if(l!=null&&l[c])return l==null?void 0:l[c];const u=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:xo(Ao({},h.sessionProperties||{}),{capabilities:xo(Ao({},l||{}),{[c]:u})})})}catch(p){console.warn("Failed to update session with capabilities",p)}return u}async getCallStatus(e){var t,i;const s=this.client.session.get(e.topic),r=(t=s.sessionProperties)==null?void 0:t.bundler_name;if(r){const o=this.getBundlerUrl(e.chainId,r);try{return await this.getUserOperationReceipt(o,e)}catch(a){console.warn("Failed to fetch call status from bundler",a,o)}}const n=(i=s.sessionProperties)==null?void 0:i.bundler_url;if(n)try{return await this.getUserOperationReceipt(n,e)}catch(o){console.warn("Failed to fetch call status from custom bundler",o,n)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var i;const s=new URL(e),r=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(Dt("eth_getUserOperationReceipt",[(i=t.request.params)==null?void 0:i[0]]))});if(!r.ok)throw new Error(`Failed to fetch user operation receipt - ${r.status}`);return await r.json()}getBundlerUrl(e,t){return`${Uy}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}},Am=Object.defineProperty,xm=(e,t,i)=>t in e?Am(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Zt=(e,t,i)=>xm(e,typeof t!="symbol"?t+"":t,i),Nm=class{constructor(e){Zt(this,"name","solana"),Zt(this,"client"),Zt(this,"httpProviders"),Zt(this,"events"),Zt(this,"namespace"),Zt(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=Ht(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},Cm=Object.defineProperty,Rm=(e,t,i)=>t in e?Cm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Xt=(e,t,i)=>Rm(e,typeof t!="symbol"?t+"":t,i),Tm=class{constructor(e){Xt(this,"name","cosmos"),Xt(this,"client"),Xt(this,"httpProviders"),Xt(this,"events"),Xt(this,"namespace"),Xt(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=Ht(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},qm=Object.defineProperty,Dm=(e,t,i)=>t in e?qm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ei=(e,t,i)=>Dm(e,typeof t!="symbol"?t+"":t,i),km=class{constructor(e){ei(this,"name","algorand"),ei(this,"client"),ei(this,"httpProviders"),ei(this,"events"),ei(this,"namespace"),ei(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const i=t||De(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;e[t]=this.createHttpProvider(t,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);return typeof i>"u"?void 0:new Be(new Je(i,J("disableProviderPing")))}},jm=Object.defineProperty,Um=(e,t,i)=>t in e?jm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ti=(e,t,i)=>Um(e,typeof t!="symbol"?t+"":t,i),Mm=class{constructor(e){ti(this,"name","cip34"),ti(this,"client"),ti(this,"httpProviders"),ti(this,"events"),ti(this,"namespace"),ti(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const i=this.getCardanoRPCUrl(t),s=Ht(t);e[s]=this.createHttpProvider(s,i)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||this.getCardanoRPCUrl(e);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},Lm=Object.defineProperty,Bm=(e,t,i)=>t in e?Lm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ii=(e,t,i)=>Bm(e,typeof t!="symbol"?t+"":t,i),zm=class{constructor(e){ii(this,"name","elrond"),ii(this,"client"),ii(this,"httpProviders"),ii(this,"events"),ii(this,"namespace"),ii(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=Ht(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},Hm=Object.defineProperty,Vm=(e,t,i)=>t in e?Hm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,si=(e,t,i)=>Vm(e,typeof t!="symbol"?t+"":t,i),Km=class{constructor(e){si(this,"name","multiversx"),si(this,"client"),si(this,"httpProviders"),si(this,"events"),si(this,"namespace"),si(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=Ht(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},Fm=Object.defineProperty,Gm=(e,t,i)=>t in e?Fm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ri=(e,t,i)=>Gm(e,typeof t!="symbol"?t+"":t,i),Wm=class{constructor(e){ri(this,"name","near"),ri(this,"client"),ri(this,"httpProviders"),ri(this,"events"),ri(this,"namespace"),ri(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||De(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;e[t]=this.createHttpProvider(t,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace);return typeof i>"u"?void 0:new Be(new Je(i,J("disableProviderPing")))}},Jm=Object.defineProperty,Ym=(e,t,i)=>t in e?Jm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ni=(e,t,i)=>Ym(e,typeof t!="symbol"?t+"":t,i),Qm=class{constructor(e){ni(this,"name","tezos"),ni(this,"client"),ni(this,"httpProviders"),ni(this,"events"),ni(this,"namespace"),ni(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||De(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace);return typeof i>"u"?void 0:new Be(new Je(i))}},Zm=Object.defineProperty,Xm=(e,t,i)=>t in e?Zm(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,oi=(e,t,i)=>Xm(e,typeof t!="symbol"?t+"":t,i),ew=class{constructor(e){oi(this,"name",ai),oi(this,"client"),oi(this,"httpProviders"),oi(this,"events"),oi(this,"namespace"),oi(this,"chainId"),this.namespace=e.namespace,this.events=J("events"),this.client=J("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ze.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const i={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(s=>{const r=di(s);i[`${r.namespace}:${r.reference}`]=this.createHttpProvider(s)}),i}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||De(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Be(new Je(i,J("disableProviderPing")))}},tw=Object.defineProperty,iw=Object.defineProperties,sw=Object.getOwnPropertyDescriptors,No=Object.getOwnPropertySymbols,rw=Object.prototype.hasOwnProperty,nw=Object.prototype.propertyIsEnumerable,Sr=(e,t,i)=>t in e?tw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,hs=(e,t)=>{for(var i in t||(t={}))rw.call(t,i)&&Sr(e,i,t[i]);if(No)for(var i of No(t))nw.call(t,i)&&Sr(e,i,t[i]);return e},Zs=(e,t)=>iw(e,sw(t)),Ue=(e,t,i)=>Sr(e,typeof t!="symbol"?t+"":t,i),$w=class Qa{constructor(t){Ue(this,"client"),Ue(this,"namespaces"),Ue(this,"optionalNamespaces"),Ue(this,"sessionProperties"),Ue(this,"scopedProperties"),Ue(this,"events",new qy.default),Ue(this,"rpcProviders",{}),Ue(this,"session"),Ue(this,"providerOpts"),Ue(this,"logger"),Ue(this,"uri"),Ue(this,"disableProviderPing",!1),this.providerOpts=t,this.logger=typeof(t==null?void 0:t.logger)<"u"&&typeof(t==null?void 0:t.logger)!="string"?t.logger:(0,Ar.default)($s({level:(t==null?void 0:t.logger)||wo})),this.disableProviderPing=(t==null?void 0:t.disableProviderPing)||!1}static async init(t){const i=new Qa(t);return await i.initialize(),i}async request(t,i,s){const[r,n]=this.validateChain(i);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:hs({},t),chainId:`${r}:${n}`,topic:this.session.topic,expiry:s})}sendAsync(t,i,s,r){const n=new Date().getTime();this.request(t,s,r).then(o=>i(null,bs(n,o))).catch(o=>i(o,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:Q("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}async authenticate(t,i){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(t),await this.cleanupPendingPairings();const{uri:s,response:r}=await this.client.authenticate(t,i);s&&(this.uri=s,this.events.emit("display_uri",s));const n=await r();if(this.session=n.session,this.session){const o=So(this.session.namespaces);this.namespaces=cs(this.namespaces,o),await this.persist("namespaces",this.namespaces),this.onConnect()}return n}on(t,i){this.events.on(t,i)}once(t,i){this.events.once(t,i)}removeListener(t,i){this.events.removeListener(t,i)}off(t,i){this.events.off(t,i)}get isWalletConnect(){return!0}async pair(t){const{uri:i,approval:s}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});i&&(this.uri=i,this.events.emit("display_uri",i));const r=await s();this.session=r;const n=So(r.namespaces);return this.namespaces=cs(this.namespaces,n),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(t,i){try{if(!this.session)return;const[s,r]=this.validateChain(t),n=this.getProvider(s);n.name===ai?n.setDefaultChain(`${s}:${r}`,i):n.setDefaultChain(r,i)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const i=this.client.pairing.getAll();if(It(i)){for(const s of i)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${i.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var t,i;if(this.client=this.providerOpts.client||await Ty.init({core:this.providerOpts.core,logger:this.providerOpts.logger||wo,relayUrl:this.providerOpts.relayUrl||Dy,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(s){throw this.logger.error("Failed to get session",s),new Error(`The provided session: ${(i=(t=this.providerOpts)==null?void 0:t.session)==null?void 0:i.topic} doesn't exist in the Sign client`)}else{const s=this.client.session.getAll();this.session=s[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const t=[...new Set(Object.keys(this.session.namespaces).map(i=>li(i)))];Qs("client",this.client),Qs("events",this.events),Qs("disableProviderPing",this.disableProviderPing),t.forEach(i=>{if(!this.session)return;const s=wm(i,this.session),r=Ja(s),n=cs(this.namespaces,this.optionalNamespaces),o=Zs(hs({},n[i]),{accounts:s,chains:r});switch(i){case"eip155":this.rpcProviders[i]=new Om({namespace:o});break;case"algorand":this.rpcProviders[i]=new km({namespace:o});break;case"solana":this.rpcProviders[i]=new Nm({namespace:o});break;case"cosmos":this.rpcProviders[i]=new Tm({namespace:o});break;case"polkadot":this.rpcProviders[i]=new $m({namespace:o});break;case"cip34":this.rpcProviders[i]=new Mm({namespace:o});break;case"elrond":this.rpcProviders[i]=new zm({namespace:o});break;case"multiversx":this.rpcProviders[i]=new Km({namespace:o});break;case"near":this.rpcProviders[i]=new Wm({namespace:o});break;case"tezos":this.rpcProviders[i]=new Qm({namespace:o});break;default:this.rpcProviders[ai]?this.rpcProviders[ai].updateNamespace(o):this.rpcProviders[ai]=new ew({namespace:o})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{var i;const{topic:s}=t;s===((i=this.session)==null?void 0:i.topic)&&this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{var i;const{params:s,topic:r}=t;if(r!==((i=this.session)==null?void 0:i.topic))return;const{event:n}=s;if(n.name==="accountsChanged"){const o=n.data;o&&It(o)&&this.events.emit("accountsChanged",o.map(Po))}else if(n.name==="chainChanged"){const o=s.chainId,a=s.event.data,c=li(o),h=Ys(o)!==Ys(a)?`${c}:${Ys(a)}`:o;this.onChainChanged(h)}else this.events.emit(n.name,n.data);this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:i})=>{var s,r;if(t!==((s=this.session)==null?void 0:s.topic))return;const{namespaces:n}=i,o=(r=this.client)==null?void 0:r.session.get(t);this.session=Zs(hs({},o),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:i})}),this.client.on("session_delete",async t=>{var i;t.topic===((i=this.session)==null?void 0:i.topic)&&(await this.cleanup(),this.events.emit("session_delete",t),this.events.emit("disconnect",Zs(hs({},Q("USER_DISCONNECTED")),{data:t.topic})))}),this.on(ze.DEFAULT_CHAIN_CHANGED,t=>{this.onChainChanged(t,!0)})}getProvider(t){return this.rpcProviders[t]||this.rpcProviders[ai]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var i;this.getProvider(t).updateNamespace((i=this.session)==null?void 0:i.namespaces[t])})}setNamespaces(t){const{namespaces:i={},optionalNamespaces:s={},sessionProperties:r,scopedProperties:n}=t;this.optionalNamespaces=cs(i,s),this.sessionProperties=r,this.scopedProperties=n}validateChain(t){const[i,s]=(t==null?void 0:t.split(":"))||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[i,s];if(i&&!Object.keys(this.namespaces||{}).map(o=>li(o)).includes(i))throw new Error(`Namespace '${i}' is not configured. Please call connect() first with namespace config.`);if(i&&s)return[i,s];const r=li(Object.keys(this.namespaces)[0]),n=this.rpcProviders[r].getDefaultChain();return[r,n]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}async onChainChanged(t,i=!1){if(!this.namespaces)return;const[s,r]=this.validateChain(t);if(!r)return;this.updateNamespaceChain(s,r),this.events.emit("chainChanged",r);const n=this.getProvider(s).getDefaultChain();i||this.getProvider(s).setDefaultChain(r),this.emitAccountsChangedOnChainChange({namespace:s,previousChainId:n,newChainId:t}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:t,previousChainId:i,newChainId:s}){var r,n;try{if(i===s)return;const o=(n=(r=this.session)==null?void 0:r.namespaces[t])==null?void 0:n.accounts;if(!o)return;const a=o.filter(c=>c.includes(`${s}:`)).map(Po);if(!It(a))return;this.events.emit("accountsChanged",a)}catch(o){this.logger.warn("Failed to emit accountsChanged on chain change",o)}}updateNamespaceChain(t,i){if(!this.namespaces)return;const s=this.namespaces[t]?t:`${t}:${i}`,r={chains:[],methods:[],events:[],defaultChain:i};this.namespaces[s]?this.namespaces[s]&&(this.namespaces[s].defaultChain=i):this.namespaces[s]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(t,i){var s;const r=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.setItem(`${os}/${t}${r}`,i)}async getFromStore(t){var i;const s=((i=this.session)==null?void 0:i.topic)||"";return await this.client.core.storage.getItem(`${os}/${t}${s}`)}async deleteFromStore(t){var i;const s=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.removeItem(`${os}/${t}${s}`)}async cleanupStorage(){var t;try{if(((t=this.client)==null?void 0:t.session.length)>0)return;const i=await this.client.core.storage.getKeys();for(const s of i)s.startsWith(os)&&await this.client.core.storage.removeItem(s)}catch(i){this.logger.warn("Failed to cleanup storage",i)}}};const Xs={getSIWX(){return es.state.siwx},async initializeIfEnabled(){const e=es.state.siwx,t=ot.getActiveCaipAddress();if(!(e&&t))return;const[i,s,r]=t.split(":");if(ot.checkIfSupportedNetwork(i))try{if((await e.getSessions(`${i}:${s}`,r)).length)return;await Oi.open({view:"SIWXSignMessage"})}catch(o){var n;console.error("SIWXUtil:initializeIfEnabled",o),Vt.sendEvent({type:"track",event:"SIWX_AUTH_ERROR",properties:this.getSIWXEventProperties()}),await((n=Ns._getClient())===null||n===void 0?void 0:n.disconnect().catch(console.error)),Kt.reset("Connect"),Ai.showError("A problem occurred while trying initialize authentication")}},async requestSignMessage(){const e=es.state.siwx,t=Gr.getPlainAddress(ot.getActiveCaipAddress()),i=ot.getActiveCaipNetwork(),s=Ns._getClient();if(!e)throw new Error("SIWX is not enabled");if(!t)throw new Error("No ActiveCaipAddress found");if(!i)throw new Error("No ActiveCaipNetwork or client found");if(!s)throw new Error("No ConnectionController client found");try{const r=await e.createMessage({chainId:i.caipNetworkId,accountAddress:t}),n=r.toString();lc.getConnectorId(i.chainNamespace)===uc.CONNECTOR_ID.AUTH&&Kt.pushTransactionStack({});const a=await s.signMessage(n);await e.addSession({data:r,message:n,signature:a}),Oi.close(),Vt.sendEvent({type:"track",event:"SIWX_AUTH_SUCCESS",properties:this.getSIWXEventProperties()})}catch(r){const n=this.getSIWXEventProperties();(!Oi.state.open||Kt.state.view==="ApproveTransaction")&&await Oi.open({view:"SIWXSignMessage"}),n.isSmartAccount?Ai.showError("This application might not support Smart Accounts"):Ai.showError("Signature declined"),Vt.sendEvent({type:"track",event:"SIWX_AUTH_ERROR",properties:n}),console.error("SWIXUtil:requestSignMessage",r)}},async cancelSignMessage(){try{var e;const t=this.getSIWX();(t==null||(e=t.getRequired)===null||e===void 0?void 0:e.call(t))?await Ns.disconnect():Oi.close(),Kt.reset("Connect"),Vt.sendEvent({event:"CLICK_CANCEL_SIWX",type:"track",properties:this.getSIWXEventProperties()})}catch(t){console.error("SIWXUtil:cancelSignMessage",t)}},async getSessions(){const e=es.state.siwx,t=Gr.getPlainAddress(ot.getActiveCaipAddress()),i=ot.getActiveCaipNetwork();return e&&t&&i?e.getSessions(i.caipNetworkId,t):[]},async isSIWXCloseDisabled(){const e=this.getSIWX();if(e){var t;const i=Kt.state.view==="ApproveTransaction",s=Kt.state.view==="SIWXSignMessage";if(i||s)return((t=e.getRequired)===null||t===void 0?void 0:t.call(e))&&(await this.getSessions()).length===0}return!1},async universalProviderAuthenticate({universalProvider:e,chains:t,methods:i}){var s,r,n;const o=Xs.getSIWX(),a=new Set(t.map(l=>l.split(":")[0]));if(!o||a.size!==1||!a.has("eip155"))return!1;const c=await o.createMessage({chainId:((s=ot.getActiveCaipNetwork())===null||s===void 0?void 0:s.caipNetworkId)||"",accountAddress:""}),h=await e.authenticate({nonce:c.nonce,domain:c.domain,uri:c.uri,exp:c.expirationTime,iat:c.issuedAt,nbf:c.notBefore,requestId:c.requestId,version:c.version,resources:c.resources,statement:c.statement,chainId:c.chainId,methods:i,chains:[c.chainId,...t.filter(l=>l!==c.chainId)]});if(Ai.showLoading("Authenticating...",{autoClose:!1}),Fr.setConnectedWalletInfo({...h.session.peer.metadata,name:h.session.peer.metadata.name,icon:(r=h.session.peer.metadata.icons)===null||r===void 0?void 0:r[0],type:"WALLET_CONNECT"},Array.from(a)[0]),!(h==null||(n=h.auths)===null||n===void 0)&&n.length){const l=h.auths.map(u=>{const p=e.client.formatAuthMessage({request:u.p,iss:u.p.iss});return{data:{...u.p,accountAddress:u.p.iss.split(":").slice(-1).join(""),chainId:u.p.iss.split(":").slice(2,4).join(":"),uri:u.p.aud,version:u.p.version||c.version,expirationTime:u.p.exp,issuedAt:u.p.iat,notBefore:u.p.nbf},message:p,signature:u.s.s,cacao:u}});try{await o.setSessions(l),Vt.sendEvent({type:"track",event:"SIWX_AUTH_SUCCESS",properties:Xs.getSIWXEventProperties()})}catch(u){throw console.error("SIWX:universalProviderAuth - failed to set sessions",u),Vt.sendEvent({type:"track",event:"SIWX_AUTH_ERROR",properties:Xs.getSIWXEventProperties()}),await e.disconnect().catch(console.error),u}finally{Ai.hide()}}return!0},getSIWXEventProperties(){var e,t;const i=ot.state.activeChain;return{network:((e=ot.state.activeCaipNetwork)===null||e===void 0?void 0:e.caipNetworkId)||"",isSmartAccount:((t=Fr.state.preferredAccountTypes)===null||t===void 0?void 0:t[i])===pc.ACCOUNT_TYPES.SMART_ACCOUNT}},async clearSessions(){const e=this.getSIWX();e&&await e.setSessions([])}};export{$w as B,Xs as SIWXUtil};
