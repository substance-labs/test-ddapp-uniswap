import{BaseError as _}from"./isAddress-P2vaZgmG.js";import{ExecutionRevertedError as A}from"./node-C_BraYgX.js";import{stringify as x}from"./stringify-B82RFruy.js";import{HttpRequestError as S,RpcRequestError as D,TimeoutError as P,TransactionRejectedRpcError as B,UserRejectedRequestError as F}from"./rpc-nQR4Ijs4.js";import{createBatchScheduler as H}from"./createBatchScheduler-BJBpfhFD.js";import{createTransport as U,wait as M}from"./createTransport-WEDNYdh5.js";function $(r,i={}){const{key:l="fallback",name:s="Fallback",rank:p=!1,shouldThrow:y=N,retryCount:d,retryDelay:o}=i;return({chain:g,pollingInterval:C=4e3,timeout:m,...w})=>{let e=r,a=()=>{};const T=U({key:l,name:s,async request({method:t,params:n}){let u;const h=async(c=0)=>{const b=e[c]({...w,chain:g,retryCount:0,timeout:m});try{const f=await b.request({method:t,params:n});return a({method:t,params:n,response:f,transport:b,status:"success"}),f}catch(f){if(a({error:f,method:t,params:n,transport:b,status:"error"}),y(f)||c===e.length-1||(u??(u=e.slice(c+1).some(R=>{const{include:q,exclude:k}=R({chain:g}).config.methods||{};return q?q.includes(t):k?!k.includes(t):!0})),!u))throw f;return h(c+1)}};return h()},retryCount:d,retryDelay:o,type:"fallback"},{onResponse:t=>a=t,transports:e.map(t=>t({chain:g,retryCount:0}))});if(p){const t=typeof p=="object"?p:{};W({chain:g,interval:t.interval??C,onTransports:n=>e=n,ping:t.ping,sampleCount:t.sampleCount,timeout:t.timeout,transports:e,weights:t.weights})}return T}}function N(r){return!!("code"in r&&typeof r.code=="number"&&(r.code===B.code||r.code===F.code||A.nodeMessage.test(r.message)||r.code===5e3))}function W({chain:r,interval:i=4e3,onTransports:l,ping:s,sampleCount:p=10,timeout:y=1e3,transports:d,weights:o={}}){const{stability:g=.7,latency:C=.3}=o,m=[],w=async()=>{const e=await Promise.all(d.map(async t=>{const n=t({chain:r,retryCount:0,timeout:y}),u=Date.now();let h,c;try{await(s?s({transport:n}):n.request({method:"net_listening"})),c=1}catch{c=0}finally{h=Date.now()}return{latency:h-u,success:c}}));m.push(e),m.length>p&&m.shift();const a=Math.max(...m.map(t=>Math.max(...t.map(({latency:n})=>n)))),T=d.map((t,n)=>{const u=m.map(R=>R[n].latency),c=1-u.reduce((R,q)=>R+q,0)/u.length/a,b=m.map(R=>R[n].success),f=b.reduce((R,q)=>R+q,0)/b.length;return f===0?[0,n]:[C*c+g*f,n]}).sort((t,n)=>n[0]-t[0]);l(T.map(([,t])=>d[t])),await M(i),w()};w()}var I=class extends _{constructor(){super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",{docsPath:"/docs/clients/intro",name:"UrlRequiredError"})}};function J(r,{errorInstance:i=new Error("timed out"),timeout:l,signal:s}){return new Promise((p,y)=>{(async()=>{let d;try{const o=new AbortController;l>0&&(d=setTimeout(()=>{s?o.abort():y(i)},l)),p(await r({signal:(o==null?void 0:o.signal)||null}))}catch(o){(o==null?void 0:o.name)==="AbortError"&&y(i),y(o)}finally{clearTimeout(d)}})()})}function z(){return{current:0,take(){return this.current++},reset(){this.current=0}}}const j=z();function G(r,i={}){return{async request(l){const{body:s,onRequest:p=i.onRequest,onResponse:y=i.onResponse,timeout:d=i.timeout??1e4}=l,o={...i.fetchOptions??{},...l.fetchOptions??{}},{headers:g,method:C,signal:m}=o;try{var w;const e=await J(async({signal:T})=>{const t={...o,body:Array.isArray(s)?x(s.map(c=>({jsonrpc:"2.0",id:c.id??j.take(),...c}))):x({jsonrpc:"2.0",id:s.id??j.take(),...s}),headers:{"Content-Type":"application/json",...g},method:C||"POST",signal:m||(d>0?T:null)},n=new Request(r,t),u=await(p==null?void 0:p(n,t))??{...t,url:r};return await fetch(u.url??r,u)},{errorInstance:new P({body:s,url:r}),timeout:d,signal:!0});y&&await y(e);let a;if(!((w=e.headers.get("Content-Type"))===null||w===void 0)&&w.startsWith("application/json"))a=await e.json();else{a=await e.text();try{a=JSON.parse(a||"{}")}catch(T){if(e.ok)throw T;a={error:a}}}if(!e.ok)throw new S({body:s,details:x(a.error)||e.statusText,headers:e.headers,status:e.status,url:r});return a}catch(e){throw e instanceof S||e instanceof P?e:new S({body:s,cause:e,url:r})}}}}function tt(r,i={}){const{batch:l,fetchOptions:s,key:p="http",methods:y,name:d="HTTP JSON-RPC",onFetchRequest:o,onFetchResponse:g,retryDelay:C,raw:m}=i;return({chain:w,retryCount:e,timeout:a})=>{const{batchSize:T=1e3,wait:t=0}=typeof l=="object"?l:{},n=i.retryCount??e,u=a??i.timeout??1e4,h=r||(w==null?void 0:w.rpcUrls.default.http[0]);if(!h)throw new I;const c=G(h,{fetchOptions:s,onRequest:o,onResponse:g,timeout:u});return U({key:p,methods:y,name:d,async request({method:b,params:f}){const R={method:b,params:f},{schedule:q}=H({id:h,wait:t,shouldSplitBatch(v){return v.length>T},fn:v=>c.request({body:v}),sort:(v,L)=>v.id-L.id}),k=async v=>l?q(v):[await c.request({body:v})],[{error:E,result:O}]=await k(R);if(m)return{error:E,result:O};if(E)throw new D({body:R,error:E,url:h});return O},retryCount:n,retryDelay:C,timeout:u,type:"http"},{fetchOptions:s,url:h})}}export{$ as fallback,G as getHttpRpcClient,tt as http,J as withTimeout};
