const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/core-BZ2u_pbs.js","assets/preload-helper-CaakwtpC.js","assets/lit-DG7NlYUS.js","assets/_u64-b_viZRi_.js","assets/chunk-DgAfPHQg.js","assets/isAddress-P2vaZgmG.js","assets/ConstantsUtil-DWdkyivO.js","assets/formatUnits-DkyMpOD7.js","assets/dist-QCpUvRkJ.js","assets/SIWXUtil-BcrNwiHE.js","assets/index.es-2xsffwdf.js","assets/events-Bnkik2bI.js","assets/basics-DA01Pp0C.js","assets/dist-ceZDlR1V.js","assets/dist-Q7olfaoJ.js","assets/esm-DSGHq0HW.js","assets/recoverAddress-oPdWABRo.js","assets/ConnectorUtil-BidIfr3U.js","assets/createTransport-WEDNYdh5.js","assets/rpc-nQR4Ijs4.js","assets/stringify-B82RFruy.js","assets/http-CIklBnX8.js","assets/node-C_BraYgX.js","assets/createBatchScheduler-BJBpfhFD.js"])))=>i.map(i=>d[i]);
import{__export as ul,__toESM as Me}from"./chunk-DgAfPHQg.js";import{__vitePreload as dl}from"./preload-helper-CaakwtpC.js";import{global as V,init_dist as gc}from"./dist-Q7olfaoJ.js";import{init_dist as Bn,process$1 as us}from"./dist-QCpUvRkJ.js";import{Buffer as Ae,init_dist as cr}from"./dist-ceZDlR1V.js";import{recoverAddress as pl}from"./recoverAddress-oPdWABRo.js";import{esm_default as gl}from"./esm-DSGHq0HW.js";import{require_events as _s}from"./events-Bnkik2bI.js";import{A as fl,C as yl,E as Te,IEvents as Fi,Po as oo,Qe as ml,Qo as wl,concat as ds,detect as $l,f as ut,f$1 as vl,formatJsonRpcError as fc,formatJsonRpcRequest as Jt,formatJsonRpcResult as hr,fromString as it,getBigIntRpcId as Oi,h as bl,i as El,import_browser as Mn,isJsonRpcError as mt,isJsonRpcRequest as zn,isJsonRpcResponse as Hn,isJsonRpcResult as Et,k as lr,o as st,payloadId as Rt,r as Gi,require_cjs as yc,require_cjs$1 as Vn,require_cjs$2 as ur,safeJsonParse as ao,safeJsonStringify as Il,sn as rn,toString as Be,y as Qe}from"./index.es-2xsffwdf.js";Bn();cr();var Lb=Me(ur()),Bb=Me(Vn()),Mb=Me(yc());const _l=":";function mc(e){const[t,i]=e.split(_l);return{namespace:t,reference:i}}function co(e,t=[]){const i=[];return Object.keys(e).forEach(s=>{if(t.length&&!t.includes(s))return;const r=e[s];i.push(...r.accounts)}),i}function _r(e=[],t=[]){return[...new Set([...e,...t])]}function Xs(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Pl(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ps(e,...t){if(!Pl(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Sl(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Xs(e.outputLen),Xs(e.blockLen)}function Ti(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function wc(e,t){Ps(e);const i=t.outputLen;if(e.length<i)throw new Error("digestInto() expects output buffer of length at least "+i)}const Us=BigInt(2**32-1),ho=BigInt(32);function Ol(e,t=!1){return t?{h:Number(e&Us),l:Number(e>>ho&Us)}:{h:Number(e>>ho&Us)|0,l:Number(e&Us)|0}}function Al(e,t=!1){let i=new Uint32Array(e.length),s=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:n,l:o}=Ol(e[r],t);[i[r],s[r]]=[n,o]}return[i,s]}const xl=(e,t,i)=>e<<i|t>>>32-i,Nl=(e,t,i)=>t<<i|e>>>32-i,Rl=(e,t,i)=>t<<i-32|e>>>64-i,Cl=(e,t,i)=>e<<i-32|t>>>64-i,hi=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Tl(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function Pr(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function dt(e,t){return e<<32-t|e>>>t}const lo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function ql(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function uo(e){for(let t=0;t<e.length;t++)e[t]=ql(e[t])}function Ul(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function dr(e){return typeof e=="string"&&(e=Ul(e)),Ps(e),e}function Dl(...e){let t=0;for(let s=0;s<e.length;s++){const r=e[s];Ps(r),t+=r.length}const i=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const n=e[s];i.set(n,r),r+=n.length}return i}var Kn=class{clone(){return this._cloneInto()}};function $c(e){const t=s=>e().update(dr(s)).digest(),i=e();return t.outputLen=i.outputLen,t.blockLen=i.blockLen,t.create=()=>e(),t}function vc(e=32){if(hi&&typeof hi.getRandomValues=="function")return hi.getRandomValues(new Uint8Array(e));if(hi&&typeof hi.randomBytes=="function")return hi.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const bc=[],Ec=[],Ic=[],kl=BigInt(0),es=BigInt(1),jl=BigInt(2),Ll=BigInt(7),Bl=BigInt(256),Ml=BigInt(113);for(let e=0,t=es,i=1,s=0;e<24;e++){[i,s]=[s,(2*i+3*s)%5],bc.push(2*(5*s+i)),Ec.push((e+1)*(e+2)/2%64);let r=kl;for(let n=0;n<7;n++)t=(t<<es^(t>>Ll)*Ml)%Bl,t&jl&&(r^=es<<(es<<BigInt(n))-es);Ic.push(r)}const[zl,Hl]=Al(Ic,!0),po=(e,t,i)=>i>32?Rl(e,t,i):xl(e,t,i),go=(e,t,i)=>i>32?Cl(e,t,i):Nl(e,t,i);function Vl(e,t=24){const i=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let o=0;o<10;o++)i[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const c=(o+8)%10,a=(o+2)%10,h=i[a],l=i[a+1],p=po(h,l,1)^i[c],u=go(h,l,1)^i[c+1];for(let f=0;f<50;f+=10)e[o+f]^=p,e[o+f+1]^=u}let r=e[2],n=e[3];for(let o=0;o<24;o++){const c=Ec[o],a=po(r,n,c),h=go(r,n,c),l=bc[o];r=e[l],n=e[l+1],e[l]=a,e[l+1]=h}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)i[c]=e[o+c];for(let c=0;c<10;c++)e[o+c]^=~i[(c+2)%10]&i[(c+4)%10]}e[0]^=zl[s],e[1]^=Hl[s]}i.fill(0)}var Kl=class _c extends Kn{constructor(t,i,s,r=!1,n=24){if(super(),this.blockLen=t,this.suffix=i,this.outputLen=s,this.enableXOF=r,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Xs(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Tl(this.state)}keccak(){lo||uo(this.state32),Vl(this.state32,this.rounds),lo||uo(this.state32),this.posOut=0,this.pos=0}update(t){Ti(this);const{blockLen:i,state:s}=this;t=dr(t);const r=t.length;for(let n=0;n<r;){const o=Math.min(i-this.pos,r-n);for(let c=0;c<o;c++)s[this.pos++]^=t[n++];this.pos===i&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:i,pos:s,blockLen:r}=this;t[s]^=i,i&128&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){Ti(this,!1),Ps(t),this.finish();const i=this.state,{blockLen:s}=this;for(let r=0,n=t.length;r<n;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,n-r);t.set(i.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Xs(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(wc(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:i,suffix:s,outputLen:r,rounds:n,enableXOF:o}=this;return t||(t=new _c(i,s,r,o,n)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=n,t.suffix=s,t.outputLen=r,t.enableXOF=o,t.destroyed=this.destroyed,t}};const Fl=(e,t,i)=>$c(()=>new Kl(t,e,i)),zb=Fl(1,136,256/8);function Sr(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Pc(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ze(e,...t){if(!Pc(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function fo(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Gl(e,t){Ze(e);const i=t.outputLen;if(e.length<i)throw new Error("digestInto() expects output buffer of length at least "+i)}function yo(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}const Lt=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Wl=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),Zl=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Zl)throw new Error("Non little-endian hardware is not supported");function Yl(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function nn(e){if(typeof e=="string")e=Yl(e);else if(Pc(e))e=on(e);else throw new Error("Uint8Array expected, got "+typeof e);return e}function Jl(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function Ql(e,t){if(e.length!==t.length)return!1;let i=0;for(let s=0;s<e.length;s++)i|=e[s]^t[s];return i===0}const Xl=(e,t)=>{function i(s,...r){if(Ze(s),e.nonceLength!==void 0){const h=r[0];if(!h)throw new Error("nonce / iv required");e.varSizeNonce?Ze(h):Ze(h,e.nonceLength)}const n=e.tagLength;n&&r[1]!==void 0&&Ze(r[1]);const o=t(s,...r),c=(h,l)=>{if(l!==void 0){if(h!==2)throw new Error("cipher output not supported");Ze(l)}};let a=!1;return{encrypt(h,l){if(a)throw new Error("cannot encrypt() twice with same key + nonce");return a=!0,Ze(h),c(o.encrypt.length,l),o.encrypt(h,l)},decrypt(h,l){if(Ze(h),n&&h.length<n)throw new Error("invalid ciphertext length: smaller than tagLength="+n);return c(o.decrypt.length,l),o.decrypt(h,l)}}}return Object.assign(i,e),i};function mo(e,t,i=!0){if(t===void 0)return new Uint8Array(e);if(t.length!==e)throw new Error("invalid output length, expected "+e+", got: "+t.length);if(i&&!eu(t))throw new Error("invalid output, must be aligned");return t}function wo(e,t,i,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,i,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(i>>r&n),c=Number(i&n),a=s?4:0,h=s?0:4;e.setUint32(t+a,o,s),e.setUint32(t+h,c,s)}function eu(e){return e.byteOffset%4===0}function on(e){return Uint8Array.from(e)}function qi(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const Sc=e=>Uint8Array.from(e.split("").map(t=>t.charCodeAt(0))),tu=Sc("expand 16-byte k"),iu=Sc("expand 32-byte k"),su=Lt(tu),ru=Lt(iu);function Y(e,t){return e<<t|e>>>32-t}function an(e){return e.byteOffset%4===0}const Ds=64,nu=16,Oc=2**32-1,$o=new Uint32Array;function ou(e,t,i,s,r,n,o,c){const a=r.length,h=new Uint8Array(Ds),l=Lt(h),p=an(r)&&an(n),u=p?Lt(r):$o,f=p?Lt(n):$o;for(let y=0;y<a;o++){if(e(t,i,s,l,o,c),o>=Oc)throw new Error("arx: counter overflow");const m=Math.min(Ds,a-y);if(p&&m===Ds){const d=y/4;if(y%4!==0)throw new Error("arx: invalid block position");for(let g=0,w;g<nu;g++)w=d+g,f[w]=u[w]^l[g];y+=Ds;continue}for(let d=0,g;d<m;d++)g=y+d,n[g]=r[g]^h[d];y+=m}}function au(e,t){const{allowShortKeys:i,extendNonceFn:s,counterLength:r,counterRight:n,rounds:o}=Jl({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return Sr(r),Sr(o),yo(n),yo(i),(c,a,h,l,p=0)=>{Ze(c),Ze(a),Ze(h);const u=h.length;if(l===void 0&&(l=new Uint8Array(u)),Ze(l),Sr(p),p<0||p>=Oc)throw new Error("arx: counter overflow");if(l.length<u)throw new Error(`arx: output (${l.length}) is shorter than data (${u})`);const f=[];let y=c.length,m,d;if(y===32)f.push(m=on(c)),d=ru;else if(y===16&&i)m=new Uint8Array(32),m.set(c),m.set(c,16),d=su,f.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${y}`);an(a)||f.push(a=on(a));const g=Lt(m);if(s){if(a.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(d,g,Lt(a.subarray(0,16)),g),a=a.subarray(16)}const w=16-r;if(w!==a.length)throw new Error(`arx: nonce must be ${w} or 16 bytes`);if(w!==12){const O=new Uint8Array(12);O.set(a,n?0:12-a.length),a=O,f.push(a)}const _=Lt(a);return ou(e,d,g,_,h,l,p,o),qi(...f),l}}const be=(e,t)=>e[t++]&255|(e[t++]&255)<<8;var cu=class{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=nn(e),Ze(e,32);const t=be(e,0),i=be(e,2),s=be(e,4),r=be(e,6),n=be(e,8),o=be(e,10),c=be(e,12),a=be(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|i<<3)&8191,this.r[2]=(i>>>10|s<<6)&7939,this.r[3]=(s>>>7|r<<9)&8191,this.r[4]=(r>>>4|n<<12)&255,this.r[5]=n>>>1&8190,this.r[6]=(n>>>14|o<<2)&8191,this.r[7]=(o>>>11|c<<5)&8065,this.r[8]=(c>>>8|a<<8)&8191,this.r[9]=a>>>5&127;for(let h=0;h<8;h++)this.pad[h]=be(e,16+2*h)}process(e,t,i=!1){const s=i?0:2048,{h:r,r:n}=this,o=n[0],c=n[1],a=n[2],h=n[3],l=n[4],p=n[5],u=n[6],f=n[7],y=n[8],m=n[9],d=be(e,t+0),g=be(e,t+2),w=be(e,t+4),_=be(e,t+6),O=be(e,t+8),T=be(e,t+10),A=be(e,t+12),S=be(e,t+14);let I=r[0]+(d&8191),P=r[1]+((d>>>13|g<<3)&8191),q=r[2]+((g>>>10|w<<6)&8191),N=r[3]+((w>>>7|_<<9)&8191),C=r[4]+((_>>>4|O<<12)&8191),D=r[5]+(O>>>1&8191),$=r[6]+((O>>>14|T<<2)&8191),b=r[7]+((T>>>11|A<<5)&8191),E=r[8]+((A>>>8|S<<8)&8191),x=r[9]+(S>>>5|s),v=0,R=v+I*o+P*(5*m)+q*(5*y)+N*(5*f)+C*(5*u);v=R>>>13,R&=8191,R+=D*(5*p)+$*(5*l)+b*(5*h)+E*(5*a)+x*(5*c),v+=R>>>13,R&=8191;let L=v+I*c+P*o+q*(5*m)+N*(5*y)+C*(5*f);v=L>>>13,L&=8191,L+=D*(5*u)+$*(5*p)+b*(5*l)+E*(5*h)+x*(5*a),v+=L>>>13,L&=8191;let B=v+I*a+P*c+q*o+N*(5*m)+C*(5*y);v=B>>>13,B&=8191,B+=D*(5*f)+$*(5*u)+b*(5*p)+E*(5*l)+x*(5*h),v+=B>>>13,B&=8191;let k=v+I*h+P*a+q*c+N*o+C*(5*m);v=k>>>13,k&=8191,k+=D*(5*y)+$*(5*f)+b*(5*u)+E*(5*p)+x*(5*l),v+=k>>>13,k&=8191;let M=v+I*l+P*h+q*a+N*c+C*o;v=M>>>13,M&=8191,M+=D*(5*m)+$*(5*y)+b*(5*f)+E*(5*u)+x*(5*p),v+=M>>>13,M&=8191;let K=v+I*p+P*l+q*h+N*a+C*c;v=K>>>13,K&=8191,K+=D*o+$*(5*m)+b*(5*y)+E*(5*f)+x*(5*u),v+=K>>>13,K&=8191;let H=v+I*u+P*p+q*l+N*h+C*a;v=H>>>13,H&=8191,H+=D*c+$*o+b*(5*m)+E*(5*y)+x*(5*f),v+=H>>>13,H&=8191;let F=v+I*f+P*u+q*p+N*l+C*h;v=F>>>13,F&=8191,F+=D*a+$*c+b*o+E*(5*m)+x*(5*y),v+=F>>>13,F&=8191;let ie=v+I*y+P*f+q*u+N*p+C*l;v=ie>>>13,ie&=8191,ie+=D*h+$*a+b*c+E*o+x*(5*m),v+=ie>>>13,ie&=8191;let G=v+I*m+P*y+q*f+N*u+C*p;v=G>>>13,G&=8191,G+=D*l+$*h+b*a+E*c+x*o,v+=G>>>13,G&=8191,v=(v<<2)+v|0,v=v+R|0,R=v&8191,v=v>>>13,L+=v,r[0]=R,r[1]=L,r[2]=B,r[3]=k,r[4]=M,r[5]=K,r[6]=H,r[7]=F,r[8]=ie,r[9]=G}finalize(){const{h:e,pad:t}=this,i=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let o=2;o<10;o++)e[o]+=s,s=e[o]>>>13,e[o]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,i[0]=e[0]+5,s=i[0]>>>13,i[0]&=8191;for(let o=1;o<10;o++)i[o]=e[o]+s,s=i[o]>>>13,i[o]&=8191;i[9]-=8192;let r=(s^1)-1;for(let o=0;o<10;o++)i[o]&=r;r=~r;for(let o=0;o<10;o++)e[o]=e[o]&r|i[o];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let n=e[0]+t[0];e[0]=n&65535;for(let o=1;o<8;o++)n=(e[o]+t[o]|0)+(n>>>16)|0,e[o]=n&65535;qi(i)}update(e){fo(this);const{buffer:t,blockLen:i}=this;e=nn(e);const s=e.length;for(let r=0;r<s;){const n=Math.min(i-this.pos,s-r);if(n===i){for(;i<=s-r;r+=i)this.process(e,r);continue}t.set(e.subarray(r,r+n),this.pos),this.pos+=n,r+=n,this.pos===i&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){qi(this.h,this.r,this.buffer,this.pad)}digestInto(e){fo(this),Gl(e,this),this.finished=!0;const{buffer:t,h:i}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let r=0;for(let n=0;n<8;n++)e[r++]=i[n]>>>0,e[r++]=i[n]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}};function hu(e){const t=(s,r)=>e(r).update(nn(s)).digest(),i=e(new Uint8Array(32));return t.outputLen=i.outputLen,t.blockLen=i.blockLen,t.create=s=>e(s),t}const lu=hu(e=>new cu(e));function uu(e,t,i,s,r,n=20){let o=e[0],c=e[1],a=e[2],h=e[3],l=t[0],p=t[1],u=t[2],f=t[3],y=t[4],m=t[5],d=t[6],g=t[7],w=r,_=i[0],O=i[1],T=i[2],A=o,S=c,I=a,P=h,q=l,N=p,C=u,D=f,$=y,b=m,E=d,x=g,v=w,R=_,L=O,B=T;for(let M=0;M<n;M+=2)A=A+q|0,v=Y(v^A,16),$=$+v|0,q=Y(q^$,12),A=A+q|0,v=Y(v^A,8),$=$+v|0,q=Y(q^$,7),S=S+N|0,R=Y(R^S,16),b=b+R|0,N=Y(N^b,12),S=S+N|0,R=Y(R^S,8),b=b+R|0,N=Y(N^b,7),I=I+C|0,L=Y(L^I,16),E=E+L|0,C=Y(C^E,12),I=I+C|0,L=Y(L^I,8),E=E+L|0,C=Y(C^E,7),P=P+D|0,B=Y(B^P,16),x=x+B|0,D=Y(D^x,12),P=P+D|0,B=Y(B^P,8),x=x+B|0,D=Y(D^x,7),A=A+N|0,B=Y(B^A,16),E=E+B|0,N=Y(N^E,12),A=A+N|0,B=Y(B^A,8),E=E+B|0,N=Y(N^E,7),S=S+C|0,v=Y(v^S,16),x=x+v|0,C=Y(C^x,12),S=S+C|0,v=Y(v^S,8),x=x+v|0,C=Y(C^x,7),I=I+D|0,R=Y(R^I,16),$=$+R|0,D=Y(D^$,12),I=I+D|0,R=Y(R^I,8),$=$+R|0,D=Y(D^$,7),P=P+q|0,L=Y(L^P,16),b=b+L|0,q=Y(q^b,12),P=P+q|0,L=Y(L^P,8),b=b+L|0,q=Y(q^b,7);let k=0;s[k++]=o+A|0,s[k++]=c+S|0,s[k++]=a+I|0,s[k++]=h+P|0,s[k++]=l+q|0,s[k++]=p+N|0,s[k++]=u+C|0,s[k++]=f+D|0,s[k++]=y+$|0,s[k++]=m+b|0,s[k++]=d+E|0,s[k++]=g+x|0,s[k++]=w+v|0,s[k++]=_+R|0,s[k++]=O+L|0,s[k++]=T+B|0}const du=au(uu,{counterRight:!1,counterLength:4,allowShortKeys:!1}),pu=new Uint8Array(16),vo=(e,t)=>{e.update(t);const i=t.length%16;i&&e.update(pu.subarray(i))},gu=new Uint8Array(32);function bo(e,t,i,s,r){const n=e(t,i,gu),o=lu.create(n);r&&vo(o,r),vo(o,s);const c=new Uint8Array(16),a=Wl(c);wo(a,0,BigInt(r?r.length:0),!0),wo(a,8,BigInt(s.length),!0),o.update(c);const h=o.digest();return qi(n,c),h}const fu=e=>(t,i,s)=>({encrypt(r,n){const o=r.length;n=mo(o+16,n,!1),n.set(r);const c=n.subarray(0,-16);e(t,i,c,c,1);const a=bo(e,t,i,c,s);return n.set(a,o),qi(a),n},decrypt(r,n){n=mo(r.length-16,n,!1);const o=r.subarray(0,-16),c=r.subarray(-16),a=bo(e,t,i,o,s);if(!Ql(c,a))throw new Error("invalid tag");return n.set(r.subarray(0,-16)),e(t,i,n,n,1),qi(a),n}}),Hb=Xl({blockSize:64,nonceLength:12,tagLength:16},fu(du));var Ac=class extends Kn{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Sl(e);const i=dr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,r=new Uint8Array(s);r.set(i.length>s?e.create().update(i).digest():i);for(let n=0;n<r.length;n++)r[n]^=54;this.iHash.update(r),this.oHash=e.create();for(let n=0;n<r.length;n++)r[n]^=106;this.oHash.update(r),r.fill(0)}update(e){return Ti(this),this.iHash.update(e),this}digestInto(e){Ti(this),Ps(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:i,finished:s,destroyed:r,blockLen:n,outputLen:o}=this;return e=e,e.finished=s,e.destroyed=r,e.blockLen=n,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=i._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const xc=(e,t,i)=>new Ac(e,t).update(i).digest();xc.create=(e,t)=>new Ac(e,t);const Vb=new Uint8Array([0]),Kb=new Uint8Array;function yu(e,t,i,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,i,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(i>>r&n),c=Number(i&n),a=s?4:0,h=s?0:4;e.setUint32(t+a,o,s),e.setUint32(t+h,c,s)}function mu(e,t,i){return e&t^~e&i}function wu(e,t,i){return e&t^e&i^t&i}var $u=class extends Kn{constructor(e,t,i,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=i,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pr(this.buffer)}update(e){Ti(this);const{view:t,buffer:i,blockLen:s}=this;e=dr(e);const r=e.length;for(let n=0;n<r;){const o=Math.min(s-this.pos,r-n);if(o===s){const c=Pr(e);for(;s<=r-n;n+=s)this.process(c,n);continue}i.set(e.subarray(n,n+o),this.pos),this.pos+=o,n+=o,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ti(this),wc(e,this),this.finished=!0;const{buffer:t,view:i,blockLen:s,isLE:r}=this;let{pos:n}=this;t[n++]=128,this.buffer.subarray(n).fill(0),this.padOffset>s-n&&(this.process(i,0),n=0);for(let l=n;l<s;l++)t[l]=0;yu(i,s-8,BigInt(this.length*8),r),this.process(i,0);const o=Pr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)o.setUint32(4*l,h[l],r)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:i,length:s,finished:r,destroyed:n,pos:o}=this;return e.length=s,e.pos=o,e.finished=r,e.destroyed=n,s%t&&e.buffer.set(i),e}};const vu=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ct=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Tt=new Uint32Array(64);var bu=class extends $u{constructor(){super(64,32,8,!1),this.A=Ct[0]|0,this.B=Ct[1]|0,this.C=Ct[2]|0,this.D=Ct[3]|0,this.E=Ct[4]|0,this.F=Ct[5]|0,this.G=Ct[6]|0,this.H=Ct[7]|0}get(){const{A:e,B:t,C:i,D:s,E:r,F:n,G:o,H:c}=this;return[e,t,i,s,r,n,o,c]}set(e,t,i,s,r,n,o,c){this.A=e|0,this.B=t|0,this.C=i|0,this.D=s|0,this.E=r|0,this.F=n|0,this.G=o|0,this.H=c|0}process(e,t){for(let l=0;l<16;l++,t+=4)Tt[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const p=Tt[l-15],u=Tt[l-2],f=dt(p,7)^dt(p,18)^p>>>3,y=dt(u,17)^dt(u,19)^u>>>10;Tt[l]=y+Tt[l-7]+f+Tt[l-16]|0}let{A:i,B:s,C:r,D:n,E:o,F:c,G:a,H:h}=this;for(let l=0;l<64;l++){const p=dt(o,6)^dt(o,11)^dt(o,25),u=h+p+mu(o,c,a)+vu[l]+Tt[l]|0,f=(dt(i,2)^dt(i,13)^dt(i,22))+wu(i,s,r)|0;h=a,a=c,c=o,o=n+u|0,n=r,r=s,s=i,i=u+f|0}i=i+this.A|0,s=s+this.B|0,r=r+this.C|0,n=n+this.D|0,o=o+this.E|0,c=c+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(i,s,r,n,o,c,a,h)}roundClean(){Tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const Eu=$c(()=>new bu);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pr=BigInt(0),gr=BigInt(1),Iu=BigInt(2);function ii(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ss(e){if(!ii(e))throw new Error("Uint8Array expected")}function Ui(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}const _u=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Di(e){Ss(e);let t="";for(let i=0;i<e.length;i++)t+=_u[e[i]];return t}function Ai(e){const t=e.toString(16);return t.length&1?"0"+t:t}function Fn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?pr:BigInt("0x"+e)}const vt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Eo(e){if(e>=vt._0&&e<=vt._9)return e-vt._0;if(e>=vt.A&&e<=vt.F)return e-(vt.A-10);if(e>=vt.a&&e<=vt.f)return e-(vt.a-10)}function ki(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length,i=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(i);for(let r=0,n=0;r<i;r++,n+=2){const o=Eo(e.charCodeAt(n)),c=Eo(e.charCodeAt(n+1));if(o===void 0||c===void 0){const a=e[n]+e[n+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+n)}s[r]=o*16+c}return s}function Xt(e){return Fn(Di(e))}function ys(e){return Ss(e),Fn(Di(Uint8Array.from(e).reverse()))}function ji(e,t){return ki(e.toString(16).padStart(t*2,"0"))}function fr(e,t){return ji(e,t).reverse()}function Pu(e){return ki(Ai(e))}function Ge(e,t,i){let s;if(typeof t=="string")try{s=ki(t)}catch(n){throw new Error(e+" must be hex string or Uint8Array, cause: "+n)}else if(ii(t))s=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");const r=s.length;if(typeof i=="number"&&r!==i)throw new Error(e+" of length "+i+" expected, got "+r);return s}function ms(...e){let t=0;for(let s=0;s<e.length;s++){const r=e[s];Ss(r),t+=r.length}const i=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const n=e[s];i.set(n,r),r+=n.length}return i}function Su(e,t){if(e.length!==t.length)return!1;let i=0;for(let s=0;s<e.length;s++)i|=e[s]^t[s];return i===0}function Ou(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const Or=e=>typeof e=="bigint"&&pr<=e;function yr(e,t,i){return Or(e)&&Or(t)&&Or(i)&&t<=e&&e<i}function At(e,t,i,s){if(!yr(t,i,s))throw new Error("expected valid "+e+": "+i+" <= n < "+s+", got "+t)}function Nc(e){let t;for(t=0;e>pr;e>>=gr,t+=1);return t}function Au(e,t){return e>>BigInt(t)&gr}function xu(e,t,i){return e|(i?gr:pr)<<BigInt(t)}const Gn=e=>(Iu<<BigInt(e-1))-gr,Ar=e=>new Uint8Array(e),Io=e=>Uint8Array.from(e);function Rc(e,t,i){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof i!="function")throw new Error("hmacFn must be a function");let s=Ar(e),r=Ar(e),n=0;const o=()=>{s.fill(1),r.fill(0),n=0},c=(...l)=>i(r,s,...l),a=(l=Ar())=>{r=c(Io([0]),l),s=c(),l.length!==0&&(r=c(Io([1]),l),s=c())},h=()=>{if(n++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const p=[];for(;l<t;){s=c();const u=s.slice();p.push(u),l+=s.length}return ms(...p)};return(l,p)=>{o(),a(l);let u;for(;!(u=p(h()));)a();return o(),u}}const Nu={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||ii(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Wi(e,t,i={}){const s=(r,n,o)=>{const c=Nu[n];if(typeof c!="function")throw new Error("invalid validator function");const a=e[r];if(!(o&&a===void 0)&&!c(a,e))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+a)};for(const[r,n]of Object.entries(t))s(r,n,!1);for(const[r,n]of Object.entries(i))s(r,n,!0);return e}const Ru=()=>{throw new Error("not implemented")};function cn(e){const t=new WeakMap;return(i,...s)=>{const r=t.get(i);if(r!==void 0)return r;const n=e(i,...s);return t.set(i,n),n}}var Cu=Object.freeze({__proto__:null,isBytes:ii,abytes:Ss,abool:Ui,bytesToHex:Di,numberToHexUnpadded:Ai,hexToNumber:Fn,hexToBytes:ki,bytesToNumberBE:Xt,bytesToNumberLE:ys,numberToBytesBE:ji,numberToBytesLE:fr,numberToVarBytesBE:Pu,ensureBytes:Ge,concatBytes:ms,equalBytes:Su,utf8ToBytes:Ou,inRange:yr,aInRange:At,bitLen:Nc,bitGet:Au,bitSet:xu,bitMask:Gn,createHmacDrbg:Rc,validateObject:Wi,notImplemented:Ru,memoized:cn});const $e=BigInt(0),ce=BigInt(1),Gt=BigInt(2),Tu=BigInt(3),hn=BigInt(4),_o=BigInt(5),Po=BigInt(8);function ke(e,t){const i=e%t;return i>=$e?i:t+i}function Cc(e,t,i){if(t<$e)throw new Error("invalid exponent, negatives unsupported");if(i<=$e)throw new Error("invalid modulus");if(i===ce)return $e;let s=ce;for(;t>$e;)t&ce&&(s=s*e%i),e=e*e%i,t>>=ce;return s}function ct(e,t,i){let s=e;for(;t-- >$e;)s*=s,s%=i;return s}function ln(e,t){if(e===$e)throw new Error("invert: expected non-zero number");if(t<=$e)throw new Error("invert: expected positive modulus, got "+t);let i=ke(e,t),s=t,r=$e,n=ce;for(;i!==$e;){const o=s/i,c=s%i,a=r-n*o;s=i,i=c,r=n,n=a}if(s!==ce)throw new Error("invert: does not exist");return ke(r,t)}function qu(e){const t=(e-ce)/Gt;let i,s,r;for(i=e-ce,s=0;i%Gt===$e;i/=Gt,s++);for(r=Gt;r<e&&Cc(r,t,e)!==e-ce;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const o=(e+ce)/hn;return function(c,a){const h=c.pow(a,o);if(!c.eql(c.sqr(h),a))throw new Error("Cannot find square root");return h}}const n=(i+ce)/Gt;return function(o,c){if(o.pow(c,t)===o.neg(o.ONE))throw new Error("Cannot find square root");let a=s,h=o.pow(o.mul(o.ONE,r),i),l=o.pow(c,n),p=o.pow(c,i);for(;!o.eql(p,o.ONE);){if(o.eql(p,o.ZERO))return o.ZERO;let u=1;for(let y=o.sqr(p);u<a&&!o.eql(y,o.ONE);u++)y=o.sqr(y);const f=o.pow(h,ce<<BigInt(a-u-1));h=o.sqr(f),l=o.mul(l,f),p=o.mul(p,h),a=u}return l}}function Uu(e){if(e%hn===Tu){const t=(e+ce)/hn;return function(i,s){const r=i.pow(s,t);if(!i.eql(i.sqr(r),s))throw new Error("Cannot find square root");return r}}if(e%Po===_o){const t=(e-_o)/Po;return function(i,s){const r=i.mul(s,Gt),n=i.pow(r,t),o=i.mul(s,n),c=i.mul(i.mul(o,Gt),n),a=i.mul(o,i.sub(c,i.ONE));if(!i.eql(i.sqr(a),s))throw new Error("Cannot find square root");return a}}return qu(e)}const Du=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ku(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},i=Du.reduce((s,r)=>(s[r]="function",s),t);return Wi(e,i)}function ju(e,t,i){if(i<$e)throw new Error("invalid exponent, negatives unsupported");if(i===$e)return e.ONE;if(i===ce)return t;let s=e.ONE,r=t;for(;i>$e;)i&ce&&(s=e.mul(s,r)),r=e.sqr(r),i>>=ce;return s}function Lu(e,t){const i=new Array(t.length),s=t.reduce((n,o,c)=>e.is0(o)?n:(i[c]=n,e.mul(n,o)),e.ONE),r=e.inv(s);return t.reduceRight((n,o,c)=>e.is0(o)?n:(i[c]=e.mul(n,i[c]),e.mul(n,o)),r),i}function Tc(e,t){const i=t!==void 0?t:e.toString(2).length,s=Math.ceil(i/8);return{nBitLength:i,nByteLength:s}}function qc(e,t,i=!1,s={}){if(e<=$e)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:r,nByteLength:n}=Tc(e,t);if(n>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const c=Object.freeze({ORDER:e,isLE:i,BITS:r,BYTES:n,MASK:Gn(r),ZERO:$e,ONE:ce,create:a=>ke(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return $e<=a&&a<e},is0:a=>a===$e,isOdd:a=>(a&ce)===ce,neg:a=>ke(-a,e),eql:(a,h)=>a===h,sqr:a=>ke(a*a,e),add:(a,h)=>ke(a+h,e),sub:(a,h)=>ke(a-h,e),mul:(a,h)=>ke(a*h,e),pow:(a,h)=>ju(c,a,h),div:(a,h)=>ke(a*ln(h,e),e),sqrN:a=>a*a,addN:(a,h)=>a+h,subN:(a,h)=>a-h,mulN:(a,h)=>a*h,inv:a=>ln(a,e),sqrt:s.sqrt||(a=>(o||(o=Uu(e)),o(c,a))),invertBatch:a=>Lu(c,a),cmov:(a,h,l)=>l?h:a,toBytes:a=>i?fr(a,n):ji(a,n),fromBytes:a=>{if(a.length!==n)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+a.length);return i?ys(a):Xt(a)}});return Object.freeze(c)}function Uc(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Dc(e){const t=Uc(e);return t+Math.ceil(t/2)}function Bu(e,t,i=!1){const s=e.length,r=Uc(t),n=Dc(t);if(s<16||s<n||s>1024)throw new Error("expected "+n+"-1024 bytes of input, got "+s);const o=i?ys(e):Xt(e),c=ke(o,t-ce)+ce;return i?fr(c,r):ji(c,r)}const So=BigInt(0),ks=BigInt(1);function xr(e,t){const i=t.negate();return e?i:t}function kc(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function Nr(e,t){kc(e,t);const i=Math.ceil(t/e)+1,s=2**(e-1);return{windows:i,windowSize:s}}function Mu(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((i,s)=>{if(!(i instanceof t))throw new Error("invalid point at index "+s)})}function zu(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((i,s)=>{if(!t.isValid(i))throw new Error("invalid scalar at index "+s)})}const Rr=new WeakMap,jc=new WeakMap;function Cr(e){return jc.get(e)||1}function Hu(e,t){return{constTimeNegate:xr,hasPrecomputes(i){return Cr(i)!==1},unsafeLadder(i,s,r=e.ZERO){let n=i;for(;s>So;)s&ks&&(r=r.add(n)),n=n.double(),s>>=ks;return r},precomputeWindow(i,s){const{windows:r,windowSize:n}=Nr(s,t),o=[];let c=i,a=c;for(let h=0;h<r;h++){a=c,o.push(a);for(let l=1;l<n;l++)a=a.add(c),o.push(a);c=a.double()}return o},wNAF(i,s,r){const{windows:n,windowSize:o}=Nr(i,t);let c=e.ZERO,a=e.BASE;const h=BigInt(2**i-1),l=2**i,p=BigInt(i);for(let u=0;u<n;u++){const f=u*o;let y=Number(r&h);r>>=p,y>o&&(y-=l,r+=ks);const m=f,d=f+Math.abs(y)-1,g=u%2!==0,w=y<0;y===0?a=a.add(xr(g,s[m])):c=c.add(xr(w,s[d]))}return{p:c,f:a}},wNAFUnsafe(i,s,r,n=e.ZERO){const{windows:o,windowSize:c}=Nr(i,t),a=BigInt(2**i-1),h=2**i,l=BigInt(i);for(let p=0;p<o;p++){const u=p*c;if(r===So)break;let f=Number(r&a);if(r>>=l,f>c&&(f-=h,r+=ks),f===0)continue;let y=s[u+Math.abs(f)-1];f<0&&(y=y.negate()),n=n.add(y)}return n},getPrecomputes(i,s,r){let n=Rr.get(s);return n||(n=this.precomputeWindow(s,i),i!==1&&Rr.set(s,r(n))),n},wNAFCached(i,s,r){const n=Cr(i);return this.wNAF(n,this.getPrecomputes(n,i,r),s)},wNAFCachedUnsafe(i,s,r,n){const o=Cr(i);return o===1?this.unsafeLadder(i,s,n):this.wNAFUnsafe(o,this.getPrecomputes(o,i,r),s,n)},setWindowSize(i,s){kc(s,t),jc.set(i,s),Rr.delete(i)}}}function Vu(e,t,i,s){if(Mu(i,e),zu(s,t),i.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=e.ZERO,n=Nc(BigInt(i.length)),o=n>12?n-3:n>4?n-2:n?2:1,c=(1<<o)-1,a=new Array(c+1).fill(r),h=Math.floor((t.BITS-1)/o)*o;let l=r;for(let p=h;p>=0;p-=o){a.fill(r);for(let f=0;f<s.length;f++){const y=s[f],m=Number(y>>BigInt(p)&BigInt(c));a[m]=a[m].add(i[f])}let u=r;for(let f=a.length-1,y=r;f>0;f--)y=y.add(a[f]),u=u.add(y);if(l=l.add(u),p!==0)for(let f=0;f<o;f++)l=l.double()}return l}function Lc(e){return ku(e.Fp),Wi(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Tc(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const li=BigInt(0),Tr=BigInt(1);function Ku(e){return Wi(e,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...e})}function Fu(e){const t=Ku(e),{P:i}=t,s=w=>ke(w,i),r=t.montgomeryBits,n=Math.ceil(r/8),o=t.nByteLength,c=t.adjustScalarBytes||(w=>w),a=t.powPminus2||(w=>Cc(w,i-BigInt(2),i));function h(w,_,O){const T=s(w*(_-O));return _=s(_-T),O=s(O+T),[_,O]}const l=(t.a-BigInt(2))/BigInt(4);function p(w,_){At("u",w,li,i),At("scalar",_,li,i);const O=_,T=w;let A=Tr,S=li,I=w,P=Tr,q=li,N;for(let D=BigInt(r-1);D>=li;D--){const $=O>>D&Tr;q^=$,N=h(q,A,I),A=N[0],I=N[1],N=h(q,S,P),S=N[0],P=N[1],q=$;const b=A+S,E=s(b*b),x=A-S,v=s(x*x),R=E-v,L=I+P,B=I-P,k=s(B*b),M=s(L*x),K=k+M,H=k-M;I=s(K*K),P=s(T*s(H*H)),A=s(E*v),S=s(R*(E+s(l*R)))}N=h(q,A,I),A=N[0],I=N[1],N=h(q,S,P),S=N[0],P=N[1];const C=a(S);return s(A*C)}function u(w){return fr(s(w),n)}function f(w){const _=Ge("u coordinate",w,n);return o===32&&(_[31]&=127),ys(_)}function y(w){const _=Ge("scalar",w),O=_.length;if(O!==n&&O!==o){let T=""+n+" or "+o;throw new Error("invalid scalar, expected "+T+" bytes, got "+O)}return ys(c(_))}function m(w,_){const O=f(_),T=y(w),A=p(O,T);if(A===li)throw new Error("invalid private or public key received");return u(A)}const d=u(t.Gu);function g(w){return m(w,d)}return{scalarMult:m,scalarMultBase:g,getSharedSecret:(w,_)=>m(w,_),getPublicKey:w=>g(w),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:d}}const un=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const Gu=BigInt(1),Oo=BigInt(2),Wu=BigInt(3),Zu=BigInt(5);BigInt(8);function Yu(e){const t=BigInt(10),i=BigInt(20),s=BigInt(40),r=BigInt(80),n=un,o=e*e%n*e%n,c=ct(o,Oo,n)*o%n,a=ct(c,Gu,n)*e%n,h=ct(a,Zu,n)*a%n,l=ct(h,t,n)*h%n,p=ct(l,i,n)*l%n,u=ct(p,s,n)*p%n,f=ct(u,r,n)*u%n,y=ct(f,r,n)*u%n,m=ct(y,t,n)*h%n;return{pow_p_5_8:ct(m,Oo,n)*e%n,b2:o}}function Ju(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Fb=Fu({P:un,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:e=>{const t=un,{pow_p_5_8:i,b2:s}=Yu(e);return ke(ct(i,Wu,t)*s,t)},adjustScalarBytes:Ju,randomBytes:vc});function Ao(e){e.lowS!==void 0&&Ui("lowS",e.lowS),e.prehash!==void 0&&Ui("prehash",e.prehash)}function Qu(e){const t=Lc(e);Wi(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:i,Fp:s,a:r}=t;if(i){if(!s.eql(r,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof i!="object"||typeof i.beta!="bigint"||typeof i.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:Xu,hexToBytes:ed}=Cu;var td=class extends Error{constructor(e=""){super(e)}};const _t={Err:td,_tlv:{encode:(e,t)=>{const{Err:i}=_t;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length&1)throw new i("tlv.encode: unpadded data");const s=t.length/2,r=Ai(s);if(r.length/2&128)throw new i("tlv.encode: long form length too big");const n=s>127?Ai(r.length/2|128):"";return Ai(e)+n+r+t},decode(e,t){const{Err:i}=_t;let s=0;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length<2||t[s++]!==e)throw new i("tlv.decode: wrong tlv");const r=t[s++],n=!!(r&128);let o=0;if(!n)o=r;else{const a=r&127;if(!a)throw new i("tlv.decode(long): indefinite length not supported");if(a>4)throw new i("tlv.decode(long): byte length is too big");const h=t.subarray(s,s+a);if(h.length!==a)throw new i("tlv.decode: length bytes not complete");if(h[0]===0)throw new i("tlv.decode(long): zero leftmost byte");for(const l of h)o=o<<8|l;if(s+=a,o<128)throw new i("tlv.decode(long): not minimal encoding")}const c=t.subarray(s,s+o);if(c.length!==o)throw new i("tlv.decode: wrong value length");return{v:c,l:t.subarray(s+o)}}},_int:{encode(e){const{Err:t}=_t;if(e<St)throw new t("integer: negative integers are not allowed");let i=Ai(e);if(Number.parseInt(i[0],16)&8&&(i="00"+i),i.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return i},decode(e){const{Err:t}=_t;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Xu(e)}},toSig(e){const{Err:t,_int:i,_tlv:s}=_t,r=typeof e=="string"?ed(e):e;Ss(r);const{v:n,l:o}=s.decode(48,r);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=s.decode(2,n),{v:h,l}=s.decode(2,a);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:i.decode(c),s:i.decode(h)}},hexFromSig(e){const{_tlv:t,_int:i}=_t,s=t.encode(2,i.encode(e.r)),r=t.encode(2,i.encode(e.s)),n=s+r;return t.encode(48,n)}},St=BigInt(0),ye=BigInt(1);BigInt(2);const xo=BigInt(3);BigInt(4);function id(e){const t=Qu(e),{Fp:i}=t,s=qc(t.n,t.nBitLength),r=t.toBytes||((m,d,g)=>{const w=d.toAffine();return ms(Uint8Array.from([4]),i.toBytes(w.x),i.toBytes(w.y))}),n=t.fromBytes||(m=>{const d=m.subarray(1),g=i.fromBytes(d.subarray(0,i.BYTES)),w=i.fromBytes(d.subarray(i.BYTES,2*i.BYTES));return{x:g,y:w}});function o(m){const{a:d,b:g}=t,w=i.sqr(m),_=i.mul(w,m);return i.add(i.add(_,i.mul(m,d)),g)}if(!i.eql(i.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return yr(m,ye,t.n)}function a(m){const{allowedPrivateKeyLengths:d,nByteLength:g,wrapPrivateKey:w,n:_}=t;if(d&&typeof m!="bigint"){if(ii(m)&&(m=Di(m)),typeof m!="string"||!d.includes(m.length))throw new Error("invalid private key");m=m.padStart(g*2,"0")}let O;try{O=typeof m=="bigint"?m:Xt(Ge("private key",m,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof m)}return w&&(O=ke(O,_)),At("private key",O,ye,_),O}function h(m){if(!(m instanceof u))throw new Error("ProjectivePoint expected")}const l=cn((m,d)=>{const{px:g,py:w,pz:_}=m;if(i.eql(_,i.ONE))return{x:g,y:w};const O=m.is0();d??(d=O?i.ONE:i.inv(_));const T=i.mul(g,d),A=i.mul(w,d),S=i.mul(_,d);if(O)return{x:i.ZERO,y:i.ZERO};if(!i.eql(S,i.ONE))throw new Error("invZ was invalid");return{x:T,y:A}}),p=cn(m=>{if(m.is0()){if(t.allowInfinityPoint&&!i.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:d,y:g}=m.toAffine();if(!i.isValid(d)||!i.isValid(g))throw new Error("bad point: x or y not FE");const w=i.sqr(g),_=o(d);if(!i.eql(w,_))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class u{constructor(d,g,w){if(this.px=d,this.py=g,this.pz=w,d==null||!i.isValid(d))throw new Error("x required");if(g==null||!i.isValid(g))throw new Error("y required");if(w==null||!i.isValid(w))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:g,y:w}=d||{};if(!d||!i.isValid(g)||!i.isValid(w))throw new Error("invalid affine point");if(d instanceof u)throw new Error("projective point not allowed");const _=O=>i.eql(O,i.ZERO);return _(g)&&_(w)?u.ZERO:new u(g,w,i.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const g=i.invertBatch(d.map(w=>w.pz));return d.map((w,_)=>w.toAffine(g[_])).map(u.fromAffine)}static fromHex(d){const g=u.fromAffine(n(Ge("pointHex",d)));return g.assertValidity(),g}static fromPrivateKey(d){return u.BASE.multiply(a(d))}static msm(d,g){return Vu(u,s,d,g)}_setWindowSize(d){y.setWindowSize(this,d)}assertValidity(){p(this)}hasEvenY(){const{y:d}=this.toAffine();if(i.isOdd)return!i.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){h(d);const{px:g,py:w,pz:_}=this,{px:O,py:T,pz:A}=d,S=i.eql(i.mul(g,A),i.mul(O,_)),I=i.eql(i.mul(w,A),i.mul(T,_));return S&&I}negate(){return new u(this.px,i.neg(this.py),this.pz)}double(){const{a:d,b:g}=t,w=i.mul(g,xo),{px:_,py:O,pz:T}=this;let A=i.ZERO,S=i.ZERO,I=i.ZERO,P=i.mul(_,_),q=i.mul(O,O),N=i.mul(T,T),C=i.mul(_,O);return C=i.add(C,C),I=i.mul(_,T),I=i.add(I,I),A=i.mul(d,I),S=i.mul(w,N),S=i.add(A,S),A=i.sub(q,S),S=i.add(q,S),S=i.mul(A,S),A=i.mul(C,A),I=i.mul(w,I),N=i.mul(d,N),C=i.sub(P,N),C=i.mul(d,C),C=i.add(C,I),I=i.add(P,P),P=i.add(I,P),P=i.add(P,N),P=i.mul(P,C),S=i.add(S,P),N=i.mul(O,T),N=i.add(N,N),P=i.mul(N,C),A=i.sub(A,P),I=i.mul(N,q),I=i.add(I,I),I=i.add(I,I),new u(A,S,I)}add(d){h(d);const{px:g,py:w,pz:_}=this,{px:O,py:T,pz:A}=d;let S=i.ZERO,I=i.ZERO,P=i.ZERO;const q=t.a,N=i.mul(t.b,xo);let C=i.mul(g,O),D=i.mul(w,T),$=i.mul(_,A),b=i.add(g,w),E=i.add(O,T);b=i.mul(b,E),E=i.add(C,D),b=i.sub(b,E),E=i.add(g,_);let x=i.add(O,A);return E=i.mul(E,x),x=i.add(C,$),E=i.sub(E,x),x=i.add(w,_),S=i.add(T,A),x=i.mul(x,S),S=i.add(D,$),x=i.sub(x,S),P=i.mul(q,E),S=i.mul(N,$),P=i.add(S,P),S=i.sub(D,P),P=i.add(D,P),I=i.mul(S,P),D=i.add(C,C),D=i.add(D,C),$=i.mul(q,$),E=i.mul(N,E),D=i.add(D,$),$=i.sub(C,$),$=i.mul(q,$),E=i.add(E,$),C=i.mul(D,E),I=i.add(I,C),C=i.mul(x,E),S=i.mul(b,S),S=i.sub(S,C),C=i.mul(b,D),P=i.mul(x,P),P=i.add(P,C),new u(S,I,P)}subtract(d){return this.add(d.negate())}is0(){return this.equals(u.ZERO)}wNAF(d){return y.wNAFCached(this,d,u.normalizeZ)}multiplyUnsafe(d){const{endo:g,n:w}=t;At("scalar",d,St,w);const _=u.ZERO;if(d===St)return _;if(this.is0()||d===ye)return this;if(!g||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,d,u.normalizeZ);let{k1neg:O,k1:T,k2neg:A,k2:S}=g.splitScalar(d),I=_,P=_,q=this;for(;T>St||S>St;)T&ye&&(I=I.add(q)),S&ye&&(P=P.add(q)),q=q.double(),T>>=ye,S>>=ye;return O&&(I=I.negate()),A&&(P=P.negate()),P=new u(i.mul(P.px,g.beta),P.py,P.pz),I.add(P)}multiply(d){const{endo:g,n:w}=t;At("scalar",d,ye,w);let _,O;if(g){const{k1neg:T,k1:A,k2neg:S,k2:I}=g.splitScalar(d);let{p:P,f:q}=this.wNAF(A),{p:N,f:C}=this.wNAF(I);P=y.constTimeNegate(T,P),N=y.constTimeNegate(S,N),N=new u(i.mul(N.px,g.beta),N.py,N.pz),_=P.add(N),O=q.add(C)}else{const{p:T,f:A}=this.wNAF(d);_=T,O=A}return u.normalizeZ([_,O])[0]}multiplyAndAddUnsafe(d,g,w){const _=u.BASE,O=(A,S)=>S===St||S===ye||!A.equals(_)?A.multiplyUnsafe(S):A.multiply(S),T=O(this,g).add(O(d,w));return T.is0()?void 0:T}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:g}=t;if(d===ye)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:g}=t;return d===ye?this:g?g(u,this):this.multiplyUnsafe(t.h)}toRawBytes(d=!0){return Ui("isCompressed",d),this.assertValidity(),r(u,this,d)}toHex(d=!0){return Ui("isCompressed",d),Di(this.toRawBytes(d))}}u.BASE=new u(t.Gx,t.Gy,i.ONE),u.ZERO=new u(i.ZERO,i.ONE,i.ZERO);const f=t.nBitLength,y=Hu(u,t.endo?Math.ceil(f/2):f);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function sd(e){const t=Lc(e);return Wi(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function rd(e){const t=sd(e),{Fp:i,n:s}=t,r=i.BYTES+1,n=2*i.BYTES+1;function o($){return ke($,s)}function c($){return ln($,s)}const{ProjectivePoint:a,normPrivateKeyToScalar:h,weierstrassEquation:l,isWithinCurveOrder:p}=id({...t,toBytes($,b,E){const x=b.toAffine(),v=i.toBytes(x.x),R=ms;return Ui("isCompressed",E),E?R(Uint8Array.from([b.hasEvenY()?2:3]),v):R(Uint8Array.from([4]),v,i.toBytes(x.y))},fromBytes($){const b=$.length,E=$[0],x=$.subarray(1);if(b===r&&(E===2||E===3)){const v=Xt(x);if(!yr(v,ye,i.ORDER))throw new Error("Point is not on curve");const R=l(v);let L;try{L=i.sqrt(R)}catch(k){const M=k instanceof Error?": "+k.message:"";throw new Error("Point is not on curve"+M)}const B=(L&ye)===ye;return(E&1)===1!==B&&(L=i.neg(L)),{x:v,y:L}}else if(b===n&&E===4){const v=i.fromBytes(x.subarray(0,i.BYTES)),R=i.fromBytes(x.subarray(i.BYTES,2*i.BYTES));return{x:v,y:R}}else{const v=r,R=n;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+R+", got "+b)}}}),u=$=>Di(ji($,t.nByteLength));function f($){const b=s>>ye;return $>b}function y($){return f($)?o(-$):$}const m=($,b,E)=>Xt($.slice(b,E));class d{constructor(b,E,x){this.r=b,this.s=E,this.recovery=x,this.assertValidity()}static fromCompact(b){const E=t.nByteLength;return b=Ge("compactSignature",b,E*2),new d(m(b,0,E),m(b,E,2*E))}static fromDER(b){const{r:E,s:x}=_t.toSig(Ge("DER",b));return new d(E,x)}assertValidity(){At("r",this.r,ye,s),At("s",this.s,ye,s)}addRecoveryBit(b){return new d(this.r,this.s,b)}recoverPublicKey(b){const{r:E,s:x,recovery:v}=this,R=A(Ge("msgHash",b));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const L=v===2||v===3?E+t.n:E;if(L>=i.ORDER)throw new Error("recovery id 2 or 3 invalid");const B=(v&1)===0?"02":"03",k=a.fromHex(B+u(L)),M=c(L),K=o(-R*M),H=o(x*M),F=a.BASE.multiplyAndAddUnsafe(k,K,H);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return ki(this.toDERHex())}toDERHex(){return _t.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ki(this.toCompactHex())}toCompactHex(){return u(this.r)+u(this.s)}}const g={isValidPrivateKey($){try{return h($),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const $=Dc(t.n);return Bu(t.randomBytes($),t.n)},precompute($=8,b=a.BASE){return b._setWindowSize($),b.multiply(BigInt(3)),b}};function w($,b=!0){return a.fromPrivateKey($).toRawBytes(b)}function _($){const b=ii($),E=typeof $=="string",x=(b||E)&&$.length;return b?x===r||x===n:E?x===2*r||x===2*n:$ instanceof a}function O($,b,E=!0){if(_($))throw new Error("first arg must be private key");if(!_(b))throw new Error("second arg must be public key");return a.fromHex(b).multiply(h($)).toRawBytes(E)}const T=t.bits2int||function($){if($.length>8192)throw new Error("input is too large");const b=Xt($),E=$.length*8-t.nBitLength;return E>0?b>>BigInt(E):b},A=t.bits2int_modN||function($){return o(T($))},S=Gn(t.nBitLength);function I($){return At("num < 2^"+t.nBitLength,$,St,S),ji($,t.nByteLength)}function P($,b,E=q){if(["recovered","canonical"].some(G=>G in E))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:v}=t;let{lowS:R,prehash:L,extraEntropy:B}=E;R??(R=!0),$=Ge("msgHash",$),Ao(E),L&&($=Ge("prehashed msgHash",x($)));const k=A($),M=h(b),K=[I(M),I(k)];if(B!=null&&B!==!1){const G=B===!0?v(i.BYTES):B;K.push(Ge("extraEntropy",G))}const H=ms(...K),F=k;function ie(G){const xe=T(G);if(!p(xe))return;const ze=c(xe),qe=a.BASE.multiply(xe).toAffine(),Ne=o(qe.x);if(Ne===St)return;const de=o(ze*o(F+Ne*M));if(de===St)return;let He=(qe.x===Ne?0:2)|Number(qe.y&ye),Xi=de;return R&&f(de)&&(Xi=y(de),He^=1),new d(Ne,Xi,He)}return{seed:H,k2sig:ie}}const q={lowS:t.lowS,prehash:!1},N={lowS:t.lowS,prehash:!1};function C($,b,E=q){const{seed:x,k2sig:v}=P($,b,E),R=t;return Rc(R.hash.outputLen,R.nByteLength,R.hmac)(x,v)}a.BASE._setWindowSize(8);function D($,b,E,x=N){var v;const R=$;b=Ge("msgHash",b),E=Ge("publicKey",E);const{lowS:L,prehash:B,format:k}=x;if(Ao(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");const M=typeof R=="string"||ii(R),K=!M&&!k&&typeof R=="object"&&R!==null&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!M&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let H,F;try{if(K&&(H=new d(R.r,R.s)),M){try{k!=="compact"&&(H=d.fromDER(R))}catch(He){if(!(He instanceof _t.Err))throw He}!H&&k!=="der"&&(H=d.fromCompact(R))}F=a.fromHex(E)}catch{return!1}if(!H||L&&H.hasHighS())return!1;B&&(b=t.hash(b));const{r:ie,s:G}=H,xe=A(b),ze=c(G),qe=o(xe*ze),Ne=o(ie*ze),de=(v=a.BASE.multiplyAndAddUnsafe(F,qe,Ne))===null||v===void 0?void 0:v.toAffine();return de?o(de.x)===ie:!1}return{CURVE:t,getPublicKey:w,getSharedSecret:O,sign:C,verify:D,ProjectivePoint:a,Signature:d,utils:g}}function nd(e){return{hash:e,hmac:(t,...i)=>xc(e,t,Dl(...i)),randomBytes:vc}}function od(e,t){const i=s=>rd({...e,...nd(s)});return{...i(t),create:i}}const Bc=qc(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),ad=Bc.create(BigInt("-3")),cd=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gb=od({a:ad,b:cd,Fp:Bc,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},Eu);function Wn(e){return e.includes(":")}function cs(e){return Wn(e)?e.split(":")[0]:e}const hd={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}};function dn(e,t){const{message:i,code:s}=hd[e];return{message:t?`${i} ${t}`:i,code:s}}function Ri(e,t){return Array.isArray(e)?typeof t<"u"&&e.length?e.every(t):!0:!1}function qr(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}var Wb=Me(_s()),ld=Object.defineProperty,ud=(e,t,i)=>t in e?ld(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,No=(e,t,i)=>ud(e,typeof t!="symbol"?t+"":t,i),dd=class extends Fi{constructor(e){super(),this.opts=e,No(this,"protocol","wc"),No(this,"version",2)}},pd=Object.defineProperty,gd=(e,t,i)=>t in e?pd(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,fd=(e,t,i)=>gd(e,typeof t!="symbol"?t+"":t,i),yd=class extends Fi{constructor(e,t){super(),this.core=e,this.logger=t,fd(this,"records",new Map)}},md=class{constructor(e,t){this.logger=e,this.core=t}},wd=class extends Fi{constructor(e,t){super(),this.relayer=e,this.logger=t}},$d=class extends Fi{constructor(e){super()}},vd=class{constructor(e,t,i,s){this.core=e,this.logger=t,this.name=i}},bd=class extends Fi{constructor(e,t){super(),this.relayer=e,this.logger=t}},Ed=class extends Fi{constructor(e,t){super(),this.core=e,this.logger=t}},Id=class{constructor(e,t,i){this.core=e,this.logger=t,this.store=i}},_d=class{constructor(e,t){this.projectId=e,this.logger=t}},Pd=class{constructor(e,t,i){this.core=e,this.logger=t,this.telemetryEnabled=i}},Sd=Object.defineProperty,Od=(e,t,i)=>t in e?Sd(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ro=(e,t,i)=>Od(e,typeof t!="symbol"?t+"":t,i),Ad=class{constructor(e){this.opts=e,Ro(this,"protocol","wc"),Ro(this,"version",2)}},xd=class{constructor(e){this.client=e}};Bn();gc();cr();var Ci=Me(ur()),Mt=Me(Vn()),Nd=Me(yc());const Rd=":";function Ws(e){const[t,i]=e.split(Rd);return{namespace:t,reference:i}}function Mc(e,t){return e.includes(":")?[e]:t.chains||[]}var Cd=Object.defineProperty,Td=Object.defineProperties,qd=Object.getOwnPropertyDescriptors,Co=Object.getOwnPropertySymbols,Ud=Object.prototype.hasOwnProperty,Dd=Object.prototype.propertyIsEnumerable,To=(e,t,i)=>t in e?Cd(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,qo=(e,t)=>{for(var i in t||(t={}))Ud.call(t,i)&&To(e,i,t[i]);if(Co)for(var i of Co(t))Dd.call(t,i)&&To(e,i,t[i]);return e},kd=(e,t)=>Td(e,qd(t));const jd="ReactNative",Le={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"};const Ld="js";function er(){return typeof us<"u"&&typeof us.versions<"u"&&typeof us.versions.node<"u"}function zt(){return!(0,Mt.getDocument)()&&!!(0,Mt.getNavigator)()&&navigator.product===jd}function Bd(){return zt()&&typeof V<"u"&&typeof(V==null?void 0:V.Platform)<"u"&&(V==null?void 0:V.Platform.OS)==="android"}function Md(){return zt()&&typeof V<"u"&&typeof(V==null?void 0:V.Platform)<"u"&&(V==null?void 0:V.Platform.OS)==="ios"}function Zi(){return!er()&&!!(0,Mt.getNavigator)()&&!!(0,Mt.getDocument)()}function Os(){return zt()?Le.reactNative:er()?Le.node:Zi()?Le.browser:Le.unknown}function Uo(){var e;try{return zt()&&typeof V<"u"&&typeof(V==null?void 0:V.Application)<"u"?(e=V.Application)==null?void 0:e.applicationId:void 0}catch{return}}function zd(e,t){const i=new URLSearchParams(e);for(const s of Object.keys(t).sort())if(t.hasOwnProperty(s)){const r=t[s];r!==void 0&&i.set(s,r)}return i.toString()}function Hd(e){var t,i;const s=zc();try{return e!=null&&e.url&&s.url&&new URL(e.url).host!==new URL(s.url).host&&(console.warn(`The configured WalletConnect 'metadata.url':${e.url} differs from the actual page url:${s.url}. This is probably unintended and can lead to issues.`),e.url=s.url),(t=e==null?void 0:e.icons)!=null&&t.length&&e.icons.length>0&&(e.icons=e.icons.filter(r=>r!=="")),kd(qo(qo({},s),e),{url:(e==null?void 0:e.url)||s.url,name:(e==null?void 0:e.name)||s.name,description:(e==null?void 0:e.description)||s.description,icons:(i=e==null?void 0:e.icons)!=null&&i.length&&e.icons.length>0?e.icons:s.icons})}catch(r){return console.warn("Error populating app metadata",r),e||s}}function zc(){return(0,Nd.getWindowMetadata)()||{name:"",description:"",url:"",icons:[""]}}function Vd(){if(Os()===Le.reactNative&&typeof V<"u"&&typeof(V==null?void 0:V.Platform)<"u"){const{OS:i,Version:s}=V.Platform;return[i,s].join("-")}const e=$l();if(e===null)return"unknown";const t=e.os?e.os.replace(" ","").toLowerCase():"unknown";return e.type==="browser"?[t,e.name,e.version].join("-"):[t,e.version].join("-")}function Kd(){var e;const t=Os();return t===Le.browser?[t,((e=(0,Mt.getLocation)())==null?void 0:e.host)||"unknown"].join(":"):t}function Hc(e,t,i){const s=Vd(),r=Kd();return[[e,t].join("-"),[Ld,i].join("-"),s,r].join("/")}function Fd({protocol:e,version:t,relayUrl:i,sdkVersion:s,auth:r,projectId:n,useOnCloseEvent:o,bundleId:c,packageName:a}){const h=i.split("?"),l=Hc(e,t,s),p={auth:r,ua:l,projectId:n,useOnCloseEvent:o||void 0,packageName:a||void 0,bundleId:c||void 0},u=zd(h[1]||"",p);return h[0]+"?"+u}function Qt(e,t){return e.filter(i=>t.includes(i)).length===e.length}function pn(e){return Object.fromEntries(e.entries())}function gn(e){return new Map(Object.entries(e))}function Kt(e=Ci.FIVE_MINUTES,t){const i=(0,Ci.toMiliseconds)(e||Ci.FIVE_MINUTES);let s,r,n,o;return{resolve:c=>{n&&s&&(clearTimeout(n),s(c),o=Promise.resolve(c))},reject:c=>{n&&r&&(clearTimeout(n),r(c))},done:()=>new Promise((c,a)=>{if(o)return c(o);n=setTimeout(()=>{const h=new Error(t);o=Promise.reject(h),a(h)},i),s=c,r=a})}}function jt(e,t,i){return new Promise(async(s,r)=>{const n=setTimeout(()=>r(new Error(i)),t);try{const o=await e;s(o)}catch(o){r(o)}clearTimeout(n)})}function Vc(e,t){if(typeof t=="string"&&t.startsWith(`${e}:`))return t;if(e.toLowerCase()==="topic"){if(typeof t!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${t}`}else if(e.toLowerCase()==="id"){if(typeof t!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${t}`}throw new Error(`Unknown expirer target type: ${e}`)}function Gd(e){return Vc("topic",e)}function Wd(e){return Vc("id",e)}function Kc(e){const[t,i]=e.split(":"),s={id:void 0,topic:void 0};if(t==="topic"&&typeof i=="string")s.topic=i;else if(t==="id"&&Number.isInteger(Number(i)))s.id=Number(i);else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${i}`);return s}function pe(e,t){return(0,Ci.fromMiliseconds)((t||Date.now())+(0,Ci.toMiliseconds)(e))}function Dt(e){return Date.now()>=(0,Ci.toMiliseconds)(e)}function te(e,t){return`${e}${t?`:${t}`:""}`}function ei(e=[],t=[]){return[...new Set([...e,...t])]}async function Zd({id:e,topic:t,wcDeepLink:i}){var s;try{if(!i)return;const r=typeof i=="string"?JSON.parse(i):i,n=r==null?void 0:r.href;if(typeof n!="string")return;const o=Yd(n,e,t),c=Os();if(c===Le.browser){if(!((s=(0,Mt.getDocument)())!=null&&s.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}Jd(o)}else c===Le.reactNative&&typeof(V==null?void 0:V.Linking)<"u"&&await V.Linking.openURL(o)}catch(r){console.error(r)}}function Yd(e,t,i){const s=`requestId=${t}&sessionTopic=${i}`;e.endsWith("/")&&(e=e.slice(0,-1));let r=`${e}`;if(e.startsWith("https://t.me")){const n=e.includes("?")?"&startapp=":"?startapp=";r=`${r}${n}${tp(s,!0)}`}else r=`${r}/wc?${s}`;return r}function Jd(e){let t="_self";ep()?t="_top":(Xd()||e.startsWith("https://")||e.startsWith("http://"))&&(t="_blank"),window.open(e,t,"noreferrer noopener")}async function Qd(e,t){let i="";try{if(Zi()&&(i=localStorage.getItem(t),i))return i;i=await e.getItem(t)}catch(s){console.error(s)}return i}function Do(e,t){if(!e.includes(t))return null;const i=e.split(/([&,?,=])/),s=i.indexOf(t);return i[s+2]}function ko(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,e=>{const t=Math.random()*16|0;return(e==="x"?t:t&3|8).toString(16)})}function Zn(){return typeof us<"u"&&{}.IS_VITEST==="true"}function Xd(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function ep(){try{return window.self!==window.top}catch{return!1}}function tp(e,t=!1){const i=Ae.from(e).toString("base64");return t?i.replace(/[=]/g,""):i}function Fc(e){return Ae.from(e,"base64").toString("utf-8")}function ip(e){return new Promise(t=>setTimeout(t,e))}function ws(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function sp(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function As(e,...t){if(!sp(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Yn(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ws(e.outputLen),ws(e.blockLen)}function Li(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Gc(e,t){As(e);const i=t.outputLen;if(e.length<i)throw new Error("digestInto() expects output buffer of length at least "+i)}const js=BigInt(2**32-1),jo=BigInt(32);function rp(e,t=!1){return t?{h:Number(e&js),l:Number(e>>jo&js)}:{h:Number(e>>jo&js)|0,l:Number(e&js)|0}}function np(e,t=!1){let i=new Uint32Array(e.length),s=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:n,l:o}=rp(e[r],t);[i[r],s[r]]=[n,o]}return[i,s]}const op=(e,t,i)=>e<<i|t>>>32-i,ap=(e,t,i)=>t<<i|e>>>32-i,cp=(e,t,i)=>t<<i-32|e>>>64-i,hp=(e,t,i)=>e<<i-32|t>>>64-i,ui=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function lp(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function Ur(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function pt(e,t){return e<<32-t|e>>>t}const Lo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function up(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Bo(e){for(let t=0;t<e.length;t++)e[t]=up(e[t])}function dp(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function Bi(e){return typeof e=="string"&&(e=dp(e)),As(e),e}function pp(...e){let t=0;for(let s=0;s<e.length;s++){const r=e[s];As(r),t+=r.length}const i=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const n=e[s];i.set(n,r),r+=n.length}return i}var Jn=class{clone(){return this._cloneInto()}};function Wc(e){const t=s=>e().update(Bi(s)).digest(),i=e();return t.outputLen=i.outputLen,t.blockLen=i.blockLen,t.create=()=>e(),t}function Yi(e=32){if(ui&&typeof ui.getRandomValues=="function")return ui.getRandomValues(new Uint8Array(e));if(ui&&typeof ui.randomBytes=="function")return ui.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const Zc=[],Yc=[],Jc=[],gp=BigInt(0),ts=BigInt(1),fp=BigInt(2),yp=BigInt(7),mp=BigInt(256),wp=BigInt(113);for(let e=0,t=ts,i=1,s=0;e<24;e++){[i,s]=[s,(2*i+3*s)%5],Zc.push(2*(5*s+i)),Yc.push((e+1)*(e+2)/2%64);let r=gp;for(let n=0;n<7;n++)t=(t<<ts^(t>>yp)*wp)%mp,t&fp&&(r^=ts<<(ts<<BigInt(n))-ts);Jc.push(r)}const[$p,vp]=np(Jc,!0),Mo=(e,t,i)=>i>32?cp(e,t,i):op(e,t,i),zo=(e,t,i)=>i>32?hp(e,t,i):ap(e,t,i);function bp(e,t=24){const i=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let o=0;o<10;o++)i[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const c=(o+8)%10,a=(o+2)%10,h=i[a],l=i[a+1],p=Mo(h,l,1)^i[c],u=zo(h,l,1)^i[c+1];for(let f=0;f<50;f+=10)e[o+f]^=p,e[o+f+1]^=u}let r=e[2],n=e[3];for(let o=0;o<24;o++){const c=Yc[o],a=Mo(r,n,c),h=zo(r,n,c),l=Zc[o];r=e[l],n=e[l+1],e[l]=a,e[l+1]=h}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)i[c]=e[o+c];for(let c=0;c<10;c++)e[o+c]^=~i[(c+2)%10]&i[(c+4)%10]}e[0]^=$p[s],e[1]^=vp[s]}i.fill(0)}var Ep=class Qc extends Jn{constructor(t,i,s,r=!1,n=24){if(super(),this.blockLen=t,this.suffix=i,this.outputLen=s,this.enableXOF=r,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,ws(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=lp(this.state)}keccak(){Lo||Bo(this.state32),bp(this.state32,this.rounds),Lo||Bo(this.state32),this.posOut=0,this.pos=0}update(t){Li(this);const{blockLen:i,state:s}=this;t=Bi(t);const r=t.length;for(let n=0;n<r;){const o=Math.min(i-this.pos,r-n);for(let c=0;c<o;c++)s[this.pos++]^=t[n++];this.pos===i&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:i,pos:s,blockLen:r}=this;t[s]^=i,i&128&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){Li(this,!1),As(t),this.finish();const i=this.state,{blockLen:s}=this;for(let r=0,n=t.length;r<n;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,n-r);t.set(i.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return ws(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Gc(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:i,suffix:s,outputLen:r,rounds:n,enableXOF:o}=this;return t||(t=new Qc(i,s,r,o,n)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=n,t.suffix=s,t.outputLen=r,t.enableXOF=o,t.destroyed=this.destroyed,t}};const Ip=(e,t,i)=>Wc(()=>new Ep(t,e,i)),_p=Ip(1,136,256/8),Pp="https://rpc.walletconnect.org/v1";function Xc(e){const t=`Ethereum Signed Message:
${e.length}`,i=new TextEncoder().encode(t+e);return"0x"+Ae.from(_p(i)).toString("hex")}async function Sp(e,t,i,s,r,n){switch(i.t){case"eip191":return await Op(e,t,i.s);case"eip1271":return await Ap(e,t,i.s,s,r,n);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${i.t}`)}}async function Op(e,t,i){return(await pl({hash:Xc(t),signature:i})).toLowerCase()===e.toLowerCase()}async function Ap(e,t,i,s,r,n){const o=Ws(s);if(!o.namespace||!o.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${s}`);try{const c="0x1626ba7e",a="0000000000000000000000000000000000000000000000000000000000000040",h="0000000000000000000000000000000000000000000000000000000000000041",l=i.substring(2),p=Xc(t).substring(2),u=c+p+a+h+l,f=await fetch(`${n||Pp}/?chainId=${s}&projectId=${r}`,{method:"POST",body:JSON.stringify({id:xp(),jsonrpc:"2.0",method:"eth_call",params:[{to:e,data:u},"latest"]})}),{result:y}=await f.json();return y?y.slice(0,c.length).toLowerCase()===c.toLowerCase():!1}catch(c){return console.error("isValidEip1271Signature: ",c),!1}}function xp(){return Date.now()+Math.floor(Math.random()*1e3)}function Np(e){const t=atob(e),i=new Uint8Array(t.length);for(let o=0;o<t.length;o++)i[o]=t.charCodeAt(o);const s=i[0];if(s===0)throw new Error("No signatures found");const r=1+s*64;if(i.length<r)throw new Error("Transaction data too short for claimed signature count");if(i.length<100)throw new Error("Transaction too short");const n=Ae.from(e,"base64").slice(1,65);return gl.encode(n)}var Rp=Object.defineProperty,Cp=Object.defineProperties,Tp=Object.getOwnPropertyDescriptors,Ho=Object.getOwnPropertySymbols,qp=Object.prototype.hasOwnProperty,Up=Object.prototype.propertyIsEnumerable,Vo=(e,t,i)=>t in e?Rp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Dp=(e,t)=>{for(var i in t||(t={}))qp.call(t,i)&&Vo(e,i,t[i]);if(Ho)for(var i of Ho(t))Up.call(t,i)&&Vo(e,i,t[i]);return e},kp=(e,t)=>Cp(e,Tp(t));const jp="did:pkh:",Qn=e=>e==null?void 0:e.split(":"),Lp=e=>{const t=e&&Qn(e);if(t)return e.includes(jp)?t[3]:t[1]},fn=e=>{const t=e&&Qn(e);if(t)return t[2]+":"+t[3]},tr=e=>{const t=e&&Qn(e);if(t)return t.pop()};async function Ko(e){const{cacao:t,projectId:i}=e,{s,p:r}=t,n=eh(r,r.iss),o=tr(r.iss);return await Sp(o,n,s,fn(r.iss),i)}const eh=(e,t)=>{const i=`${e.domain} wants you to sign in with your Ethereum account:`,s=tr(t);if(!e.aud&&!e.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let r=e.statement||void 0;const n=`URI: ${e.aud||e.uri}`,o=`Version: ${e.version}`,c=`Chain ID: ${Lp(t)}`,a=`Nonce: ${e.nonce}`,h=`Issued At: ${e.iat}`,l=e.exp?`Expiration Time: ${e.exp}`:void 0,p=e.nbf?`Not Before: ${e.nbf}`:void 0,u=e.requestId?`Request ID: ${e.requestId}`:void 0,f=e.resources?`Resources:${e.resources.map(m=>`
- ${m}`).join("")}`:void 0,y=Zs(e.resources);if(y){const m=$s(y);r=Wp(r,m)}return[i,s,"",r,"",n,o,c,a,h,l,p,u,f].filter(m=>m!=null).join(`
`)};function Bp(e){return Ae.from(JSON.stringify(e)).toString("base64")}function Mp(e){return JSON.parse(Ae.from(e,"base64").toString("utf-8"))}function si(e){if(!e)throw new Error("No recap provided, value is undefined");if(!e.att)throw new Error("No `att` property found");const t=Object.keys(e.att);if(!(t!=null&&t.length))throw new Error("No resources found in `att` property");t.forEach(i=>{const s=e.att[i];if(Array.isArray(s))throw new Error(`Resource must be an object: ${i}`);if(typeof s!="object")throw new Error(`Resource must be an object: ${i}`);if(!Object.keys(s).length)throw new Error(`Resource object is empty: ${i}`);Object.keys(s).forEach(r=>{const n=s[r];if(!Array.isArray(n))throw new Error(`Ability limits ${r} must be an array of objects, found: ${n}`);if(!n.length)throw new Error(`Value of ${r} is empty array, must be an array with objects`);n.forEach(o=>{if(typeof o!="object")throw new Error(`Ability limits (${r}) must be an array of objects, found: ${o}`)})})})}function zp(e,t,i,s={}){return i==null||i.sort((r,n)=>r.localeCompare(n)),{att:{[e]:Hp(t,i,s)}}}function Hp(e,t,i={}){t=t==null?void 0:t.sort((r,n)=>r.localeCompare(n));const s=t.map(r=>({[`${e}/${r}`]:[i]}));return Object.assign({},...s)}function th(e){return si(e),`urn:recap:${Bp(e).replace(/=/g,"")}`}function $s(e){const t=Mp(e.replace("urn:recap:",""));return si(t),t}function Vp(e,t,i){const s=zp(e,t,i);return th(s)}function Kp(e){return e&&e.includes("urn:recap:")}function Fp(e,t){const i=$s(e),s=$s(t),r=Gp(i,s);return th(r)}function Gp(e,t){si(e),si(t);const i=Object.keys(e.att).concat(Object.keys(t.att)).sort((r,n)=>r.localeCompare(n)),s={att:{}};return i.forEach(r=>{var n,o;Object.keys(((n=e.att)==null?void 0:n[r])||{}).concat(Object.keys(((o=t.att)==null?void 0:o[r])||{})).sort((c,a)=>c.localeCompare(a)).forEach(c=>{var a,h;s.att[r]=kp(Dp({},s.att[r]),{[c]:((a=e.att[r])==null?void 0:a[c])||((h=t.att[r])==null?void 0:h[c])})})}),s}function Wp(e="",t){si(t);const i="I further authorize the stated URI to perform the following actions on my behalf: ";if(e.includes(i))return e;const s=[];let r=0;Object.keys(t.att).forEach(c=>{const a=Object.keys(t.att[c]).map(p=>({ability:p.split("/")[0],action:p.split("/")[1]}));a.sort((p,u)=>p.action.localeCompare(u.action));const h={};a.forEach(p=>{h[p.ability]||(h[p.ability]=[]),h[p.ability].push(p.action)});const l=Object.keys(h).map(p=>(r++,`(${r}) '${p}': '${h[p].join("', '")}' for '${c}'.`));s.push(l.join(", ").replace(".,","."))});const n=s.join(" "),o=`${i}${n}`;return`${e?e+" ":""}${o}`}function Fo(e){var t;const i=$s(e);si(i);const s=(t=i.att)==null?void 0:t.eip155;return s?Object.keys(s).map(r=>r.split("/")[1]):[]}function Go(e){const t=$s(e);si(t);const i=[];return Object.values(t.att).forEach(s=>{Object.values(s).forEach(r=>{var n;(n=r==null?void 0:r[0])!=null&&n.chains&&i.push(r[0].chains)})}),[...new Set(i.flat())]}function Zs(e){if(!e)return;const t=e==null?void 0:e[e.length-1];return Kp(t)?t:void 0}function Dr(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function ih(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ye(e,...t){if(!ih(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Wo(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Zp(e,t){Ye(e);const i=t.outputLen;if(e.length<i)throw new Error("digestInto() expects output buffer of length at least "+i)}function Zo(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}const Bt=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Yp=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),Jp=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Jp)throw new Error("Non little-endian hardware is not supported");function Qp(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function yn(e){if(typeof e=="string")e=Qp(e);else if(ih(e))e=mn(e);else throw new Error("Uint8Array expected, got "+typeof e);return e}function Xp(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function eg(e,t){if(e.length!==t.length)return!1;let i=0;for(let s=0;s<e.length;s++)i|=e[s]^t[s];return i===0}const tg=(e,t)=>{function i(s,...r){if(Ye(s),e.nonceLength!==void 0){const h=r[0];if(!h)throw new Error("nonce / iv required");e.varSizeNonce?Ye(h):Ye(h,e.nonceLength)}const n=e.tagLength;n&&r[1]!==void 0&&Ye(r[1]);const o=t(s,...r),c=(h,l)=>{if(l!==void 0){if(h!==2)throw new Error("cipher output not supported");Ye(l)}};let a=!1;return{encrypt(h,l){if(a)throw new Error("cannot encrypt() twice with same key + nonce");return a=!0,Ye(h),c(o.encrypt.length,l),o.encrypt(h,l)},decrypt(h,l){if(Ye(h),n&&h.length<n)throw new Error("invalid ciphertext length: smaller than tagLength="+n);return c(o.decrypt.length,l),o.decrypt(h,l)}}}return Object.assign(i,e),i};function Yo(e,t,i=!0){if(t===void 0)return new Uint8Array(e);if(t.length!==e)throw new Error("invalid output length, expected "+e+", got: "+t.length);if(i&&!ig(t))throw new Error("invalid output, must be aligned");return t}function Jo(e,t,i,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,i,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(i>>r&n),c=Number(i&n),a=s?4:0,h=s?0:4;e.setUint32(t+a,o,s),e.setUint32(t+h,c,s)}function ig(e){return e.byteOffset%4===0}function mn(e){return Uint8Array.from(e)}function Mi(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const sh=e=>Uint8Array.from(e.split("").map(t=>t.charCodeAt(0))),sg=sh("expand 16-byte k"),rg=sh("expand 32-byte k"),ng=Bt(sg),og=Bt(rg);function J(e,t){return e<<t|e>>>32-t}function wn(e){return e.byteOffset%4===0}const Ls=64,ag=16,rh=2**32-1,Qo=new Uint32Array;function cg(e,t,i,s,r,n,o,c){const a=r.length,h=new Uint8Array(Ls),l=Bt(h),p=wn(r)&&wn(n),u=p?Bt(r):Qo,f=p?Bt(n):Qo;for(let y=0;y<a;o++){if(e(t,i,s,l,o,c),o>=rh)throw new Error("arx: counter overflow");const m=Math.min(Ls,a-y);if(p&&m===Ls){const d=y/4;if(y%4!==0)throw new Error("arx: invalid block position");for(let g=0,w;g<ag;g++)w=d+g,f[w]=u[w]^l[g];y+=Ls;continue}for(let d=0,g;d<m;d++)g=y+d,n[g]=r[g]^h[d];y+=m}}function hg(e,t){const{allowShortKeys:i,extendNonceFn:s,counterLength:r,counterRight:n,rounds:o}=Xp({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return Dr(r),Dr(o),Zo(n),Zo(i),(c,a,h,l,p=0)=>{Ye(c),Ye(a),Ye(h);const u=h.length;if(l===void 0&&(l=new Uint8Array(u)),Ye(l),Dr(p),p<0||p>=rh)throw new Error("arx: counter overflow");if(l.length<u)throw new Error(`arx: output (${l.length}) is shorter than data (${u})`);const f=[];let y=c.length,m,d;if(y===32)f.push(m=mn(c)),d=og;else if(y===16&&i)m=new Uint8Array(32),m.set(c),m.set(c,16),d=ng,f.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${y}`);wn(a)||f.push(a=mn(a));const g=Bt(m);if(s){if(a.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(d,g,Bt(a.subarray(0,16)),g),a=a.subarray(16)}const w=16-r;if(w!==a.length)throw new Error(`arx: nonce must be ${w} or 16 bytes`);if(w!==12){const O=new Uint8Array(12);O.set(a,n?0:12-a.length),a=O,f.push(a)}const _=Bt(a);return cg(e,d,g,_,h,l,p,o),Mi(...f),l}}const Ee=(e,t)=>e[t++]&255|(e[t++]&255)<<8;var lg=class{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=yn(e),Ye(e,32);const t=Ee(e,0),i=Ee(e,2),s=Ee(e,4),r=Ee(e,6),n=Ee(e,8),o=Ee(e,10),c=Ee(e,12),a=Ee(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|i<<3)&8191,this.r[2]=(i>>>10|s<<6)&7939,this.r[3]=(s>>>7|r<<9)&8191,this.r[4]=(r>>>4|n<<12)&255,this.r[5]=n>>>1&8190,this.r[6]=(n>>>14|o<<2)&8191,this.r[7]=(o>>>11|c<<5)&8065,this.r[8]=(c>>>8|a<<8)&8191,this.r[9]=a>>>5&127;for(let h=0;h<8;h++)this.pad[h]=Ee(e,16+2*h)}process(e,t,i=!1){const s=i?0:2048,{h:r,r:n}=this,o=n[0],c=n[1],a=n[2],h=n[3],l=n[4],p=n[5],u=n[6],f=n[7],y=n[8],m=n[9],d=Ee(e,t+0),g=Ee(e,t+2),w=Ee(e,t+4),_=Ee(e,t+6),O=Ee(e,t+8),T=Ee(e,t+10),A=Ee(e,t+12),S=Ee(e,t+14);let I=r[0]+(d&8191),P=r[1]+((d>>>13|g<<3)&8191),q=r[2]+((g>>>10|w<<6)&8191),N=r[3]+((w>>>7|_<<9)&8191),C=r[4]+((_>>>4|O<<12)&8191),D=r[5]+(O>>>1&8191),$=r[6]+((O>>>14|T<<2)&8191),b=r[7]+((T>>>11|A<<5)&8191),E=r[8]+((A>>>8|S<<8)&8191),x=r[9]+(S>>>5|s),v=0,R=v+I*o+P*(5*m)+q*(5*y)+N*(5*f)+C*(5*u);v=R>>>13,R&=8191,R+=D*(5*p)+$*(5*l)+b*(5*h)+E*(5*a)+x*(5*c),v+=R>>>13,R&=8191;let L=v+I*c+P*o+q*(5*m)+N*(5*y)+C*(5*f);v=L>>>13,L&=8191,L+=D*(5*u)+$*(5*p)+b*(5*l)+E*(5*h)+x*(5*a),v+=L>>>13,L&=8191;let B=v+I*a+P*c+q*o+N*(5*m)+C*(5*y);v=B>>>13,B&=8191,B+=D*(5*f)+$*(5*u)+b*(5*p)+E*(5*l)+x*(5*h),v+=B>>>13,B&=8191;let k=v+I*h+P*a+q*c+N*o+C*(5*m);v=k>>>13,k&=8191,k+=D*(5*y)+$*(5*f)+b*(5*u)+E*(5*p)+x*(5*l),v+=k>>>13,k&=8191;let M=v+I*l+P*h+q*a+N*c+C*o;v=M>>>13,M&=8191,M+=D*(5*m)+$*(5*y)+b*(5*f)+E*(5*u)+x*(5*p),v+=M>>>13,M&=8191;let K=v+I*p+P*l+q*h+N*a+C*c;v=K>>>13,K&=8191,K+=D*o+$*(5*m)+b*(5*y)+E*(5*f)+x*(5*u),v+=K>>>13,K&=8191;let H=v+I*u+P*p+q*l+N*h+C*a;v=H>>>13,H&=8191,H+=D*c+$*o+b*(5*m)+E*(5*y)+x*(5*f),v+=H>>>13,H&=8191;let F=v+I*f+P*u+q*p+N*l+C*h;v=F>>>13,F&=8191,F+=D*a+$*c+b*o+E*(5*m)+x*(5*y),v+=F>>>13,F&=8191;let ie=v+I*y+P*f+q*u+N*p+C*l;v=ie>>>13,ie&=8191,ie+=D*h+$*a+b*c+E*o+x*(5*m),v+=ie>>>13,ie&=8191;let G=v+I*m+P*y+q*f+N*u+C*p;v=G>>>13,G&=8191,G+=D*l+$*h+b*a+E*c+x*o,v+=G>>>13,G&=8191,v=(v<<2)+v|0,v=v+R|0,R=v&8191,v=v>>>13,L+=v,r[0]=R,r[1]=L,r[2]=B,r[3]=k,r[4]=M,r[5]=K,r[6]=H,r[7]=F,r[8]=ie,r[9]=G}finalize(){const{h:e,pad:t}=this,i=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let o=2;o<10;o++)e[o]+=s,s=e[o]>>>13,e[o]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,i[0]=e[0]+5,s=i[0]>>>13,i[0]&=8191;for(let o=1;o<10;o++)i[o]=e[o]+s,s=i[o]>>>13,i[o]&=8191;i[9]-=8192;let r=(s^1)-1;for(let o=0;o<10;o++)i[o]&=r;r=~r;for(let o=0;o<10;o++)e[o]=e[o]&r|i[o];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let n=e[0]+t[0];e[0]=n&65535;for(let o=1;o<8;o++)n=(e[o]+t[o]|0)+(n>>>16)|0,e[o]=n&65535;Mi(i)}update(e){Wo(this);const{buffer:t,blockLen:i}=this;e=yn(e);const s=e.length;for(let r=0;r<s;){const n=Math.min(i-this.pos,s-r);if(n===i){for(;i<=s-r;r+=i)this.process(e,r);continue}t.set(e.subarray(r,r+n),this.pos),this.pos+=n,r+=n,this.pos===i&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Mi(this.h,this.r,this.buffer,this.pad)}digestInto(e){Wo(this),Zp(e,this),this.finished=!0;const{buffer:t,h:i}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let r=0;for(let n=0;n<8;n++)e[r++]=i[n]>>>0,e[r++]=i[n]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}};function ug(e){const t=(s,r)=>e(r).update(yn(s)).digest(),i=e(new Uint8Array(32));return t.outputLen=i.outputLen,t.blockLen=i.blockLen,t.create=s=>e(s),t}const dg=ug(e=>new lg(e));function pg(e,t,i,s,r,n=20){let o=e[0],c=e[1],a=e[2],h=e[3],l=t[0],p=t[1],u=t[2],f=t[3],y=t[4],m=t[5],d=t[6],g=t[7],w=r,_=i[0],O=i[1],T=i[2],A=o,S=c,I=a,P=h,q=l,N=p,C=u,D=f,$=y,b=m,E=d,x=g,v=w,R=_,L=O,B=T;for(let M=0;M<n;M+=2)A=A+q|0,v=J(v^A,16),$=$+v|0,q=J(q^$,12),A=A+q|0,v=J(v^A,8),$=$+v|0,q=J(q^$,7),S=S+N|0,R=J(R^S,16),b=b+R|0,N=J(N^b,12),S=S+N|0,R=J(R^S,8),b=b+R|0,N=J(N^b,7),I=I+C|0,L=J(L^I,16),E=E+L|0,C=J(C^E,12),I=I+C|0,L=J(L^I,8),E=E+L|0,C=J(C^E,7),P=P+D|0,B=J(B^P,16),x=x+B|0,D=J(D^x,12),P=P+D|0,B=J(B^P,8),x=x+B|0,D=J(D^x,7),A=A+N|0,B=J(B^A,16),E=E+B|0,N=J(N^E,12),A=A+N|0,B=J(B^A,8),E=E+B|0,N=J(N^E,7),S=S+C|0,v=J(v^S,16),x=x+v|0,C=J(C^x,12),S=S+C|0,v=J(v^S,8),x=x+v|0,C=J(C^x,7),I=I+D|0,R=J(R^I,16),$=$+R|0,D=J(D^$,12),I=I+D|0,R=J(R^I,8),$=$+R|0,D=J(D^$,7),P=P+q|0,L=J(L^P,16),b=b+L|0,q=J(q^b,12),P=P+q|0,L=J(L^P,8),b=b+L|0,q=J(q^b,7);let k=0;s[k++]=o+A|0,s[k++]=c+S|0,s[k++]=a+I|0,s[k++]=h+P|0,s[k++]=l+q|0,s[k++]=p+N|0,s[k++]=u+C|0,s[k++]=f+D|0,s[k++]=y+$|0,s[k++]=m+b|0,s[k++]=d+E|0,s[k++]=g+x|0,s[k++]=w+v|0,s[k++]=_+R|0,s[k++]=O+L|0,s[k++]=T+B|0}const gg=hg(pg,{counterRight:!1,counterLength:4,allowShortKeys:!1}),fg=new Uint8Array(16),Xo=(e,t)=>{e.update(t);const i=t.length%16;i&&e.update(fg.subarray(i))},yg=new Uint8Array(32);function ea(e,t,i,s,r){const n=e(t,i,yg),o=dg.create(n);r&&Xo(o,r),Xo(o,s);const c=new Uint8Array(16),a=Yp(c);Jo(a,0,BigInt(r?r.length:0),!0),Jo(a,8,BigInt(s.length),!0),o.update(c);const h=o.digest();return Mi(n,c),h}const mg=e=>(t,i,s)=>({encrypt(r,n){const o=r.length;n=Yo(o+16,n,!1),n.set(r);const c=n.subarray(0,-16);e(t,i,c,c,1);const a=ea(e,t,i,c,s);return n.set(a,o),Mi(a),n},decrypt(r,n){n=Yo(r.length-16,n,!1);const o=r.subarray(0,-16),c=r.subarray(-16),a=ea(e,t,i,o,s);if(!eg(c,a))throw new Error("invalid tag");return n.set(r.subarray(0,-16)),e(t,i,n,n,1),Mi(a),n}}),nh=tg({blockSize:64,nonceLength:12,tagLength:16},mg(gg));var oh=class extends Jn{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Yn(e);const i=Bi(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,r=new Uint8Array(s);r.set(i.length>s?e.create().update(i).digest():i);for(let n=0;n<r.length;n++)r[n]^=54;this.iHash.update(r),this.oHash=e.create();for(let n=0;n<r.length;n++)r[n]^=106;this.oHash.update(r),r.fill(0)}update(e){return Li(this),this.iHash.update(e),this}digestInto(e){Li(this),As(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:i,finished:s,destroyed:r,blockLen:n,outputLen:o}=this;return e=e,e.finished=s,e.destroyed=r,e.blockLen=n,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=i._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const mr=(e,t,i)=>new oh(e,t).update(i).digest();mr.create=(e,t)=>new oh(e,t);function wg(e,t,i){return Yn(e),i===void 0&&(i=new Uint8Array(e.outputLen)),mr(e,Bi(i),Bi(t))}const kr=new Uint8Array([0]),ta=new Uint8Array;function $g(e,t,i,s=32){if(Yn(e),ws(s),s>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const r=Math.ceil(s/e.outputLen);i===void 0&&(i=ta);const n=new Uint8Array(r*e.outputLen),o=mr.create(e,t),c=o._cloneInto(),a=new Uint8Array(o.outputLen);for(let h=0;h<r;h++)kr[0]=h+1,c.update(h===0?ta:a).update(i).update(kr).digestInto(a),n.set(a,e.outputLen*h),o._cloneInto(c);return o.destroy(),c.destroy(),a.fill(0),kr.fill(0),n.slice(0,s)}const vg=(e,t,i,s,r)=>$g(e,wg(e,t,i),s,r);function bg(e,t,i,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,i,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(i>>r&n),c=Number(i&n),a=s?4:0,h=s?0:4;e.setUint32(t+a,o,s),e.setUint32(t+h,c,s)}function Eg(e,t,i){return e&t^~e&i}function Ig(e,t,i){return e&t^e&i^t&i}var _g=class extends Jn{constructor(e,t,i,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=i,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Ur(this.buffer)}update(e){Li(this);const{view:t,buffer:i,blockLen:s}=this;e=Bi(e);const r=e.length;for(let n=0;n<r;){const o=Math.min(s-this.pos,r-n);if(o===s){const c=Ur(e);for(;s<=r-n;n+=s)this.process(c,n);continue}i.set(e.subarray(n,n+o),this.pos),this.pos+=o,n+=o,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Li(this),Gc(e,this),this.finished=!0;const{buffer:t,view:i,blockLen:s,isLE:r}=this;let{pos:n}=this;t[n++]=128,this.buffer.subarray(n).fill(0),this.padOffset>s-n&&(this.process(i,0),n=0);for(let l=n;l<s;l++)t[l]=0;bg(i,s-8,BigInt(this.length*8),r),this.process(i,0);const o=Ur(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)o.setUint32(4*l,h[l],r)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:i,length:s,finished:r,destroyed:n,pos:o}=this;return e.length=s,e.pos=o,e.finished=r,e.destroyed=n,s%t&&e.buffer.set(i),e}};const Pg=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),qt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ut=new Uint32Array(64);var Sg=class extends _g{constructor(){super(64,32,8,!1),this.A=qt[0]|0,this.B=qt[1]|0,this.C=qt[2]|0,this.D=qt[3]|0,this.E=qt[4]|0,this.F=qt[5]|0,this.G=qt[6]|0,this.H=qt[7]|0}get(){const{A:e,B:t,C:i,D:s,E:r,F:n,G:o,H:c}=this;return[e,t,i,s,r,n,o,c]}set(e,t,i,s,r,n,o,c){this.A=e|0,this.B=t|0,this.C=i|0,this.D=s|0,this.E=r|0,this.F=n|0,this.G=o|0,this.H=c|0}process(e,t){for(let l=0;l<16;l++,t+=4)Ut[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const p=Ut[l-15],u=Ut[l-2],f=pt(p,7)^pt(p,18)^p>>>3,y=pt(u,17)^pt(u,19)^u>>>10;Ut[l]=y+Ut[l-7]+f+Ut[l-16]|0}let{A:i,B:s,C:r,D:n,E:o,F:c,G:a,H:h}=this;for(let l=0;l<64;l++){const p=pt(o,6)^pt(o,11)^pt(o,25),u=h+p+Eg(o,c,a)+Pg[l]+Ut[l]|0,f=(pt(i,2)^pt(i,13)^pt(i,22))+Ig(i,s,r)|0;h=a,a=c,c=o,o=n+u|0,n=r,r=s,s=i,i=u+f|0}i=i+this.A|0,s=s+this.B|0,r=r+this.C|0,n=n+this.D|0,o=o+this.E|0,c=c+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(i,s,r,n,o,c,a,h)}roundClean(){Ut.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const xs=Wc(()=>new Sg);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wr=BigInt(0),$r=BigInt(1),Og=BigInt(2);function ri(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ns(e){if(!ri(e))throw new Error("Uint8Array expected")}function zi(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}const Ag=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Hi(e){Ns(e);let t="";for(let i=0;i<e.length;i++)t+=Ag[e[i]];return t}function xi(e){const t=e.toString(16);return t.length&1?"0"+t:t}function Xn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?wr:BigInt("0x"+e)}const bt={_0:48,_9:57,A:65,F:70,a:97,f:102};function ia(e){if(e>=bt._0&&e<=bt._9)return e-bt._0;if(e>=bt.A&&e<=bt.F)return e-(bt.A-10);if(e>=bt.a&&e<=bt.f)return e-(bt.a-10)}function Vi(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length,i=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(i);for(let r=0,n=0;r<i;r++,n+=2){const o=ia(e.charCodeAt(n)),c=ia(e.charCodeAt(n+1));if(o===void 0||c===void 0){const a=e[n]+e[n+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+n)}s[r]=o*16+c}return s}function ti(e){return Xn(Hi(e))}function vs(e){return Ns(e),Xn(Hi(Uint8Array.from(e).reverse()))}function Ki(e,t){return Vi(e.toString(16).padStart(t*2,"0"))}function vr(e,t){return Ki(e,t).reverse()}function xg(e){return Vi(xi(e))}function We(e,t,i){let s;if(typeof t=="string")try{s=Vi(t)}catch(n){throw new Error(e+" must be hex string or Uint8Array, cause: "+n)}else if(ri(t))s=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");const r=s.length;if(typeof i=="number"&&r!==i)throw new Error(e+" of length "+i+" expected, got "+r);return s}function bs(...e){let t=0;for(let s=0;s<e.length;s++){const r=e[s];Ns(r),t+=r.length}const i=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const n=e[s];i.set(n,r),r+=n.length}return i}function Ng(e,t){if(e.length!==t.length)return!1;let i=0;for(let s=0;s<e.length;s++)i|=e[s]^t[s];return i===0}function Rg(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const jr=e=>typeof e=="bigint"&&wr<=e;function br(e,t,i){return jr(e)&&jr(t)&&jr(i)&&t<=e&&e<i}function xt(e,t,i,s){if(!br(t,i,s))throw new Error("expected valid "+e+": "+i+" <= n < "+s+", got "+t)}function ah(e){let t;for(t=0;e>wr;e>>=$r,t+=1);return t}function Cg(e,t){return e>>BigInt(t)&$r}function Tg(e,t,i){return e|(i?$r:wr)<<BigInt(t)}const eo=e=>(Og<<BigInt(e-1))-$r,Lr=e=>new Uint8Array(e),sa=e=>Uint8Array.from(e);function ch(e,t,i){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof i!="function")throw new Error("hmacFn must be a function");let s=Lr(e),r=Lr(e),n=0;const o=()=>{s.fill(1),r.fill(0),n=0},c=(...l)=>i(r,s,...l),a=(l=Lr())=>{r=c(sa([0]),l),s=c(),l.length!==0&&(r=c(sa([1]),l),s=c())},h=()=>{if(n++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const p=[];for(;l<t;){s=c();const u=s.slice();p.push(u),l+=s.length}return bs(...p)};return(l,p)=>{o(),a(l);let u;for(;!(u=p(h()));)a();return o(),u}}const qg={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||ri(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Ji(e,t,i={}){const s=(r,n,o)=>{const c=qg[n];if(typeof c!="function")throw new Error("invalid validator function");const a=e[r];if(!(o&&a===void 0)&&!c(a,e))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+a)};for(const[r,n]of Object.entries(t))s(r,n,!1);for(const[r,n]of Object.entries(i))s(r,n,!0);return e}const Ug=()=>{throw new Error("not implemented")};function $n(e){const t=new WeakMap;return(i,...s)=>{const r=t.get(i);if(r!==void 0)return r;const n=e(i,...s);return t.set(i,n),n}}var Dg=Object.freeze({__proto__:null,isBytes:ri,abytes:Ns,abool:zi,bytesToHex:Hi,numberToHexUnpadded:xi,hexToNumber:Xn,hexToBytes:Vi,bytesToNumberBE:ti,bytesToNumberLE:vs,numberToBytesBE:Ki,numberToBytesLE:vr,numberToVarBytesBE:xg,ensureBytes:We,concatBytes:bs,equalBytes:Ng,utf8ToBytes:Rg,inRange:br,aInRange:xt,bitLen:ah,bitGet:Cg,bitSet:Tg,bitMask:eo,createHmacDrbg:ch,validateObject:Ji,notImplemented:Ug,memoized:$n});const ve=BigInt(0),he=BigInt(1),Wt=BigInt(2),kg=BigInt(3),vn=BigInt(4),ra=BigInt(5),na=BigInt(8);function je(e,t){const i=e%t;return i>=ve?i:t+i}function hh(e,t,i){if(t<ve)throw new Error("invalid exponent, negatives unsupported");if(i<=ve)throw new Error("invalid modulus");if(i===he)return ve;let s=he;for(;t>ve;)t&he&&(s=s*e%i),e=e*e%i,t>>=he;return s}function ht(e,t,i){let s=e;for(;t-- >ve;)s*=s,s%=i;return s}function bn(e,t){if(e===ve)throw new Error("invert: expected non-zero number");if(t<=ve)throw new Error("invert: expected positive modulus, got "+t);let i=je(e,t),s=t,r=ve,n=he;for(;i!==ve;){const o=s/i,c=s%i,a=r-n*o;s=i,i=c,r=n,n=a}if(s!==he)throw new Error("invert: does not exist");return je(r,t)}function jg(e){const t=(e-he)/Wt;let i,s,r;for(i=e-he,s=0;i%Wt===ve;i/=Wt,s++);for(r=Wt;r<e&&hh(r,t,e)!==e-he;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const o=(e+he)/vn;return function(c,a){const h=c.pow(a,o);if(!c.eql(c.sqr(h),a))throw new Error("Cannot find square root");return h}}const n=(i+he)/Wt;return function(o,c){if(o.pow(c,t)===o.neg(o.ONE))throw new Error("Cannot find square root");let a=s,h=o.pow(o.mul(o.ONE,r),i),l=o.pow(c,n),p=o.pow(c,i);for(;!o.eql(p,o.ONE);){if(o.eql(p,o.ZERO))return o.ZERO;let u=1;for(let y=o.sqr(p);u<a&&!o.eql(y,o.ONE);u++)y=o.sqr(y);const f=o.pow(h,he<<BigInt(a-u-1));h=o.sqr(f),l=o.mul(l,f),p=o.mul(p,h),a=u}return l}}function Lg(e){if(e%vn===kg){const t=(e+he)/vn;return function(i,s){const r=i.pow(s,t);if(!i.eql(i.sqr(r),s))throw new Error("Cannot find square root");return r}}if(e%na===ra){const t=(e-ra)/na;return function(i,s){const r=i.mul(s,Wt),n=i.pow(r,t),o=i.mul(s,n),c=i.mul(i.mul(o,Wt),n),a=i.mul(o,i.sub(c,i.ONE));if(!i.eql(i.sqr(a),s))throw new Error("Cannot find square root");return a}}return jg(e)}const Bg=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Mg(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},i=Bg.reduce((s,r)=>(s[r]="function",s),t);return Ji(e,i)}function zg(e,t,i){if(i<ve)throw new Error("invalid exponent, negatives unsupported");if(i===ve)return e.ONE;if(i===he)return t;let s=e.ONE,r=t;for(;i>ve;)i&he&&(s=e.mul(s,r)),r=e.sqr(r),i>>=he;return s}function Hg(e,t){const i=new Array(t.length),s=t.reduce((n,o,c)=>e.is0(o)?n:(i[c]=n,e.mul(n,o)),e.ONE),r=e.inv(s);return t.reduceRight((n,o,c)=>e.is0(o)?n:(i[c]=e.mul(n,i[c]),e.mul(n,o)),r),i}function lh(e,t){const i=t!==void 0?t:e.toString(2).length,s=Math.ceil(i/8);return{nBitLength:i,nByteLength:s}}function uh(e,t,i=!1,s={}){if(e<=ve)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:r,nByteLength:n}=lh(e,t);if(n>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const c=Object.freeze({ORDER:e,isLE:i,BITS:r,BYTES:n,MASK:eo(r),ZERO:ve,ONE:he,create:a=>je(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return ve<=a&&a<e},is0:a=>a===ve,isOdd:a=>(a&he)===he,neg:a=>je(-a,e),eql:(a,h)=>a===h,sqr:a=>je(a*a,e),add:(a,h)=>je(a+h,e),sub:(a,h)=>je(a-h,e),mul:(a,h)=>je(a*h,e),pow:(a,h)=>zg(c,a,h),div:(a,h)=>je(a*bn(h,e),e),sqrN:a=>a*a,addN:(a,h)=>a+h,subN:(a,h)=>a-h,mulN:(a,h)=>a*h,inv:a=>bn(a,e),sqrt:s.sqrt||(a=>(o||(o=Lg(e)),o(c,a))),invertBatch:a=>Hg(c,a),cmov:(a,h,l)=>l?h:a,toBytes:a=>i?vr(a,n):Ki(a,n),fromBytes:a=>{if(a.length!==n)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+a.length);return i?vs(a):ti(a)}});return Object.freeze(c)}function dh(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function ph(e){const t=dh(e);return t+Math.ceil(t/2)}function Vg(e,t,i=!1){const s=e.length,r=dh(t),n=ph(t);if(s<16||s<n||s>1024)throw new Error("expected "+n+"-1024 bytes of input, got "+s);const o=i?vs(e):ti(e),c=je(o,t-he)+he;return i?vr(c,r):Ki(c,r)}const oa=BigInt(0),Bs=BigInt(1);function Br(e,t){const i=t.negate();return e?i:t}function gh(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function Mr(e,t){gh(e,t);const i=Math.ceil(t/e)+1,s=2**(e-1);return{windows:i,windowSize:s}}function Kg(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((i,s)=>{if(!(i instanceof t))throw new Error("invalid point at index "+s)})}function Fg(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((i,s)=>{if(!t.isValid(i))throw new Error("invalid scalar at index "+s)})}const zr=new WeakMap,fh=new WeakMap;function Hr(e){return fh.get(e)||1}function Gg(e,t){return{constTimeNegate:Br,hasPrecomputes(i){return Hr(i)!==1},unsafeLadder(i,s,r=e.ZERO){let n=i;for(;s>oa;)s&Bs&&(r=r.add(n)),n=n.double(),s>>=Bs;return r},precomputeWindow(i,s){const{windows:r,windowSize:n}=Mr(s,t),o=[];let c=i,a=c;for(let h=0;h<r;h++){a=c,o.push(a);for(let l=1;l<n;l++)a=a.add(c),o.push(a);c=a.double()}return o},wNAF(i,s,r){const{windows:n,windowSize:o}=Mr(i,t);let c=e.ZERO,a=e.BASE;const h=BigInt(2**i-1),l=2**i,p=BigInt(i);for(let u=0;u<n;u++){const f=u*o;let y=Number(r&h);r>>=p,y>o&&(y-=l,r+=Bs);const m=f,d=f+Math.abs(y)-1,g=u%2!==0,w=y<0;y===0?a=a.add(Br(g,s[m])):c=c.add(Br(w,s[d]))}return{p:c,f:a}},wNAFUnsafe(i,s,r,n=e.ZERO){const{windows:o,windowSize:c}=Mr(i,t),a=BigInt(2**i-1),h=2**i,l=BigInt(i);for(let p=0;p<o;p++){const u=p*c;if(r===oa)break;let f=Number(r&a);if(r>>=l,f>c&&(f-=h,r+=Bs),f===0)continue;let y=s[u+Math.abs(f)-1];f<0&&(y=y.negate()),n=n.add(y)}return n},getPrecomputes(i,s,r){let n=zr.get(s);return n||(n=this.precomputeWindow(s,i),i!==1&&zr.set(s,r(n))),n},wNAFCached(i,s,r){const n=Hr(i);return this.wNAF(n,this.getPrecomputes(n,i,r),s)},wNAFCachedUnsafe(i,s,r,n){const o=Hr(i);return o===1?this.unsafeLadder(i,s,n):this.wNAFUnsafe(o,this.getPrecomputes(o,i,r),s,n)},setWindowSize(i,s){gh(s,t),fh.set(i,s),zr.delete(i)}}}function Wg(e,t,i,s){if(Kg(i,e),Fg(s,t),i.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=e.ZERO,n=ah(BigInt(i.length)),o=n>12?n-3:n>4?n-2:n?2:1,c=(1<<o)-1,a=new Array(c+1).fill(r),h=Math.floor((t.BITS-1)/o)*o;let l=r;for(let p=h;p>=0;p-=o){a.fill(r);for(let f=0;f<s.length;f++){const y=s[f],m=Number(y>>BigInt(p)&BigInt(c));a[m]=a[m].add(i[f])}let u=r;for(let f=a.length-1,y=r;f>0;f--)y=y.add(a[f]),u=u.add(y);if(l=l.add(u),p!==0)for(let f=0;f<o;f++)l=l.double()}return l}function yh(e){return Mg(e.Fp),Ji(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...lh(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const di=BigInt(0),Vr=BigInt(1);function Zg(e){return Ji(e,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...e})}function Yg(e){const t=Zg(e),{P:i}=t,s=w=>je(w,i),r=t.montgomeryBits,n=Math.ceil(r/8),o=t.nByteLength,c=t.adjustScalarBytes||(w=>w),a=t.powPminus2||(w=>hh(w,i-BigInt(2),i));function h(w,_,O){const T=s(w*(_-O));return _=s(_-T),O=s(O+T),[_,O]}const l=(t.a-BigInt(2))/BigInt(4);function p(w,_){xt("u",w,di,i),xt("scalar",_,di,i);const O=_,T=w;let A=Vr,S=di,I=w,P=Vr,q=di,N;for(let D=BigInt(r-1);D>=di;D--){const $=O>>D&Vr;q^=$,N=h(q,A,I),A=N[0],I=N[1],N=h(q,S,P),S=N[0],P=N[1],q=$;const b=A+S,E=s(b*b),x=A-S,v=s(x*x),R=E-v,L=I+P,B=I-P,k=s(B*b),M=s(L*x),K=k+M,H=k-M;I=s(K*K),P=s(T*s(H*H)),A=s(E*v),S=s(R*(E+s(l*R)))}N=h(q,A,I),A=N[0],I=N[1],N=h(q,S,P),S=N[0],P=N[1];const C=a(S);return s(A*C)}function u(w){return vr(s(w),n)}function f(w){const _=We("u coordinate",w,n);return o===32&&(_[31]&=127),vs(_)}function y(w){const _=We("scalar",w),O=_.length;if(O!==n&&O!==o){let T=""+n+" or "+o;throw new Error("invalid scalar, expected "+T+" bytes, got "+O)}return vs(c(_))}function m(w,_){const O=f(_),T=y(w),A=p(O,T);if(A===di)throw new Error("invalid private or public key received");return u(A)}const d=u(t.Gu);function g(w){return m(w,d)}return{scalarMult:m,scalarMultBase:g,getSharedSecret:(w,_)=>m(w,_),getPublicKey:w=>g(w),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:d}}const En=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const Jg=BigInt(1),aa=BigInt(2),Qg=BigInt(3),Xg=BigInt(5);BigInt(8);function ef(e){const t=BigInt(10),i=BigInt(20),s=BigInt(40),r=BigInt(80),n=En,o=e*e%n*e%n,c=ht(o,aa,n)*o%n,a=ht(c,Jg,n)*e%n,h=ht(a,Xg,n)*a%n,l=ht(h,t,n)*h%n,p=ht(l,i,n)*l%n,u=ht(p,s,n)*p%n,f=ht(u,r,n)*u%n,y=ht(f,r,n)*u%n,m=ht(y,t,n)*h%n;return{pow_p_5_8:ht(m,aa,n)*e%n,b2:o}}function tf(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const In=Yg({P:En,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:e=>{const t=En,{pow_p_5_8:i,b2:s}=ef(e);return je(ht(i,Qg,t)*s,t)},adjustScalarBytes:tf,randomBytes:Yi});function ca(e){e.lowS!==void 0&&zi("lowS",e.lowS),e.prehash!==void 0&&zi("prehash",e.prehash)}function sf(e){const t=yh(e);Ji(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:i,Fp:s,a:r}=t;if(i){if(!s.eql(r,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof i!="object"||typeof i.beta!="bigint"||typeof i.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:rf,hexToBytes:nf}=Dg;var of=class extends Error{constructor(e=""){super(e)}};const Pt={Err:of,_tlv:{encode:(e,t)=>{const{Err:i}=Pt;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length&1)throw new i("tlv.encode: unpadded data");const s=t.length/2,r=xi(s);if(r.length/2&128)throw new i("tlv.encode: long form length too big");const n=s>127?xi(r.length/2|128):"";return xi(e)+n+r+t},decode(e,t){const{Err:i}=Pt;let s=0;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length<2||t[s++]!==e)throw new i("tlv.decode: wrong tlv");const r=t[s++],n=!!(r&128);let o=0;if(!n)o=r;else{const a=r&127;if(!a)throw new i("tlv.decode(long): indefinite length not supported");if(a>4)throw new i("tlv.decode(long): byte length is too big");const h=t.subarray(s,s+a);if(h.length!==a)throw new i("tlv.decode: length bytes not complete");if(h[0]===0)throw new i("tlv.decode(long): zero leftmost byte");for(const l of h)o=o<<8|l;if(s+=a,o<128)throw new i("tlv.decode(long): not minimal encoding")}const c=t.subarray(s,s+o);if(c.length!==o)throw new i("tlv.decode: wrong value length");return{v:c,l:t.subarray(s+o)}}},_int:{encode(e){const{Err:t}=Pt;if(e<Ot)throw new t("integer: negative integers are not allowed");let i=xi(e);if(Number.parseInt(i[0],16)&8&&(i="00"+i),i.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return i},decode(e){const{Err:t}=Pt;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return rf(e)}},toSig(e){const{Err:t,_int:i,_tlv:s}=Pt,r=typeof e=="string"?nf(e):e;Ns(r);const{v:n,l:o}=s.decode(48,r);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=s.decode(2,n),{v:h,l}=s.decode(2,a);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:i.decode(c),s:i.decode(h)}},hexFromSig(e){const{_tlv:t,_int:i}=Pt,s=t.encode(2,i.encode(e.r)),r=t.encode(2,i.encode(e.s)),n=s+r;return t.encode(48,n)}},Ot=BigInt(0),me=BigInt(1);BigInt(2);const ha=BigInt(3);BigInt(4);function af(e){const t=sf(e),{Fp:i}=t,s=uh(t.n,t.nBitLength),r=t.toBytes||((m,d,g)=>{const w=d.toAffine();return bs(Uint8Array.from([4]),i.toBytes(w.x),i.toBytes(w.y))}),n=t.fromBytes||(m=>{const d=m.subarray(1),g=i.fromBytes(d.subarray(0,i.BYTES)),w=i.fromBytes(d.subarray(i.BYTES,2*i.BYTES));return{x:g,y:w}});function o(m){const{a:d,b:g}=t,w=i.sqr(m),_=i.mul(w,m);return i.add(i.add(_,i.mul(m,d)),g)}if(!i.eql(i.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return br(m,me,t.n)}function a(m){const{allowedPrivateKeyLengths:d,nByteLength:g,wrapPrivateKey:w,n:_}=t;if(d&&typeof m!="bigint"){if(ri(m)&&(m=Hi(m)),typeof m!="string"||!d.includes(m.length))throw new Error("invalid private key");m=m.padStart(g*2,"0")}let O;try{O=typeof m=="bigint"?m:ti(We("private key",m,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof m)}return w&&(O=je(O,_)),xt("private key",O,me,_),O}function h(m){if(!(m instanceof u))throw new Error("ProjectivePoint expected")}const l=$n((m,d)=>{const{px:g,py:w,pz:_}=m;if(i.eql(_,i.ONE))return{x:g,y:w};const O=m.is0();d??(d=O?i.ONE:i.inv(_));const T=i.mul(g,d),A=i.mul(w,d),S=i.mul(_,d);if(O)return{x:i.ZERO,y:i.ZERO};if(!i.eql(S,i.ONE))throw new Error("invZ was invalid");return{x:T,y:A}}),p=$n(m=>{if(m.is0()){if(t.allowInfinityPoint&&!i.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:d,y:g}=m.toAffine();if(!i.isValid(d)||!i.isValid(g))throw new Error("bad point: x or y not FE");const w=i.sqr(g),_=o(d);if(!i.eql(w,_))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class u{constructor(d,g,w){if(this.px=d,this.py=g,this.pz=w,d==null||!i.isValid(d))throw new Error("x required");if(g==null||!i.isValid(g))throw new Error("y required");if(w==null||!i.isValid(w))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:g,y:w}=d||{};if(!d||!i.isValid(g)||!i.isValid(w))throw new Error("invalid affine point");if(d instanceof u)throw new Error("projective point not allowed");const _=O=>i.eql(O,i.ZERO);return _(g)&&_(w)?u.ZERO:new u(g,w,i.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const g=i.invertBatch(d.map(w=>w.pz));return d.map((w,_)=>w.toAffine(g[_])).map(u.fromAffine)}static fromHex(d){const g=u.fromAffine(n(We("pointHex",d)));return g.assertValidity(),g}static fromPrivateKey(d){return u.BASE.multiply(a(d))}static msm(d,g){return Wg(u,s,d,g)}_setWindowSize(d){y.setWindowSize(this,d)}assertValidity(){p(this)}hasEvenY(){const{y:d}=this.toAffine();if(i.isOdd)return!i.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){h(d);const{px:g,py:w,pz:_}=this,{px:O,py:T,pz:A}=d,S=i.eql(i.mul(g,A),i.mul(O,_)),I=i.eql(i.mul(w,A),i.mul(T,_));return S&&I}negate(){return new u(this.px,i.neg(this.py),this.pz)}double(){const{a:d,b:g}=t,w=i.mul(g,ha),{px:_,py:O,pz:T}=this;let A=i.ZERO,S=i.ZERO,I=i.ZERO,P=i.mul(_,_),q=i.mul(O,O),N=i.mul(T,T),C=i.mul(_,O);return C=i.add(C,C),I=i.mul(_,T),I=i.add(I,I),A=i.mul(d,I),S=i.mul(w,N),S=i.add(A,S),A=i.sub(q,S),S=i.add(q,S),S=i.mul(A,S),A=i.mul(C,A),I=i.mul(w,I),N=i.mul(d,N),C=i.sub(P,N),C=i.mul(d,C),C=i.add(C,I),I=i.add(P,P),P=i.add(I,P),P=i.add(P,N),P=i.mul(P,C),S=i.add(S,P),N=i.mul(O,T),N=i.add(N,N),P=i.mul(N,C),A=i.sub(A,P),I=i.mul(N,q),I=i.add(I,I),I=i.add(I,I),new u(A,S,I)}add(d){h(d);const{px:g,py:w,pz:_}=this,{px:O,py:T,pz:A}=d;let S=i.ZERO,I=i.ZERO,P=i.ZERO;const q=t.a,N=i.mul(t.b,ha);let C=i.mul(g,O),D=i.mul(w,T),$=i.mul(_,A),b=i.add(g,w),E=i.add(O,T);b=i.mul(b,E),E=i.add(C,D),b=i.sub(b,E),E=i.add(g,_);let x=i.add(O,A);return E=i.mul(E,x),x=i.add(C,$),E=i.sub(E,x),x=i.add(w,_),S=i.add(T,A),x=i.mul(x,S),S=i.add(D,$),x=i.sub(x,S),P=i.mul(q,E),S=i.mul(N,$),P=i.add(S,P),S=i.sub(D,P),P=i.add(D,P),I=i.mul(S,P),D=i.add(C,C),D=i.add(D,C),$=i.mul(q,$),E=i.mul(N,E),D=i.add(D,$),$=i.sub(C,$),$=i.mul(q,$),E=i.add(E,$),C=i.mul(D,E),I=i.add(I,C),C=i.mul(x,E),S=i.mul(b,S),S=i.sub(S,C),C=i.mul(b,D),P=i.mul(x,P),P=i.add(P,C),new u(S,I,P)}subtract(d){return this.add(d.negate())}is0(){return this.equals(u.ZERO)}wNAF(d){return y.wNAFCached(this,d,u.normalizeZ)}multiplyUnsafe(d){const{endo:g,n:w}=t;xt("scalar",d,Ot,w);const _=u.ZERO;if(d===Ot)return _;if(this.is0()||d===me)return this;if(!g||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,d,u.normalizeZ);let{k1neg:O,k1:T,k2neg:A,k2:S}=g.splitScalar(d),I=_,P=_,q=this;for(;T>Ot||S>Ot;)T&me&&(I=I.add(q)),S&me&&(P=P.add(q)),q=q.double(),T>>=me,S>>=me;return O&&(I=I.negate()),A&&(P=P.negate()),P=new u(i.mul(P.px,g.beta),P.py,P.pz),I.add(P)}multiply(d){const{endo:g,n:w}=t;xt("scalar",d,me,w);let _,O;if(g){const{k1neg:T,k1:A,k2neg:S,k2:I}=g.splitScalar(d);let{p:P,f:q}=this.wNAF(A),{p:N,f:C}=this.wNAF(I);P=y.constTimeNegate(T,P),N=y.constTimeNegate(S,N),N=new u(i.mul(N.px,g.beta),N.py,N.pz),_=P.add(N),O=q.add(C)}else{const{p:T,f:A}=this.wNAF(d);_=T,O=A}return u.normalizeZ([_,O])[0]}multiplyAndAddUnsafe(d,g,w){const _=u.BASE,O=(A,S)=>S===Ot||S===me||!A.equals(_)?A.multiplyUnsafe(S):A.multiply(S),T=O(this,g).add(O(d,w));return T.is0()?void 0:T}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:g}=t;if(d===me)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:g}=t;return d===me?this:g?g(u,this):this.multiplyUnsafe(t.h)}toRawBytes(d=!0){return zi("isCompressed",d),this.assertValidity(),r(u,this,d)}toHex(d=!0){return zi("isCompressed",d),Hi(this.toRawBytes(d))}}u.BASE=new u(t.Gx,t.Gy,i.ONE),u.ZERO=new u(i.ZERO,i.ONE,i.ZERO);const f=t.nBitLength,y=Gg(u,t.endo?Math.ceil(f/2):f);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function cf(e){const t=yh(e);return Ji(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function hf(e){const t=cf(e),{Fp:i,n:s}=t,r=i.BYTES+1,n=2*i.BYTES+1;function o($){return je($,s)}function c($){return bn($,s)}const{ProjectivePoint:a,normPrivateKeyToScalar:h,weierstrassEquation:l,isWithinCurveOrder:p}=af({...t,toBytes($,b,E){const x=b.toAffine(),v=i.toBytes(x.x),R=bs;return zi("isCompressed",E),E?R(Uint8Array.from([b.hasEvenY()?2:3]),v):R(Uint8Array.from([4]),v,i.toBytes(x.y))},fromBytes($){const b=$.length,E=$[0],x=$.subarray(1);if(b===r&&(E===2||E===3)){const v=ti(x);if(!br(v,me,i.ORDER))throw new Error("Point is not on curve");const R=l(v);let L;try{L=i.sqrt(R)}catch(k){const M=k instanceof Error?": "+k.message:"";throw new Error("Point is not on curve"+M)}const B=(L&me)===me;return(E&1)===1!==B&&(L=i.neg(L)),{x:v,y:L}}else if(b===n&&E===4){const v=i.fromBytes(x.subarray(0,i.BYTES)),R=i.fromBytes(x.subarray(i.BYTES,2*i.BYTES));return{x:v,y:R}}else{const v=r,R=n;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+R+", got "+b)}}}),u=$=>Hi(Ki($,t.nByteLength));function f($){const b=s>>me;return $>b}function y($){return f($)?o(-$):$}const m=($,b,E)=>ti($.slice(b,E));class d{constructor(b,E,x){this.r=b,this.s=E,this.recovery=x,this.assertValidity()}static fromCompact(b){const E=t.nByteLength;return b=We("compactSignature",b,E*2),new d(m(b,0,E),m(b,E,2*E))}static fromDER(b){const{r:E,s:x}=Pt.toSig(We("DER",b));return new d(E,x)}assertValidity(){xt("r",this.r,me,s),xt("s",this.s,me,s)}addRecoveryBit(b){return new d(this.r,this.s,b)}recoverPublicKey(b){const{r:E,s:x,recovery:v}=this,R=A(We("msgHash",b));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const L=v===2||v===3?E+t.n:E;if(L>=i.ORDER)throw new Error("recovery id 2 or 3 invalid");const B=(v&1)===0?"02":"03",k=a.fromHex(B+u(L)),M=c(L),K=o(-R*M),H=o(x*M),F=a.BASE.multiplyAndAddUnsafe(k,K,H);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Vi(this.toDERHex())}toDERHex(){return Pt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Vi(this.toCompactHex())}toCompactHex(){return u(this.r)+u(this.s)}}const g={isValidPrivateKey($){try{return h($),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const $=ph(t.n);return Vg(t.randomBytes($),t.n)},precompute($=8,b=a.BASE){return b._setWindowSize($),b.multiply(BigInt(3)),b}};function w($,b=!0){return a.fromPrivateKey($).toRawBytes(b)}function _($){const b=ri($),E=typeof $=="string",x=(b||E)&&$.length;return b?x===r||x===n:E?x===2*r||x===2*n:$ instanceof a}function O($,b,E=!0){if(_($))throw new Error("first arg must be private key");if(!_(b))throw new Error("second arg must be public key");return a.fromHex(b).multiply(h($)).toRawBytes(E)}const T=t.bits2int||function($){if($.length>8192)throw new Error("input is too large");const b=ti($),E=$.length*8-t.nBitLength;return E>0?b>>BigInt(E):b},A=t.bits2int_modN||function($){return o(T($))},S=eo(t.nBitLength);function I($){return xt("num < 2^"+t.nBitLength,$,Ot,S),Ki($,t.nByteLength)}function P($,b,E=q){if(["recovered","canonical"].some(G=>G in E))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:v}=t;let{lowS:R,prehash:L,extraEntropy:B}=E;R??(R=!0),$=We("msgHash",$),ca(E),L&&($=We("prehashed msgHash",x($)));const k=A($),M=h(b),K=[I(M),I(k)];if(B!=null&&B!==!1){const G=B===!0?v(i.BYTES):B;K.push(We("extraEntropy",G))}const H=bs(...K),F=k;function ie(G){const xe=T(G);if(!p(xe))return;const ze=c(xe),qe=a.BASE.multiply(xe).toAffine(),Ne=o(qe.x);if(Ne===Ot)return;const de=o(ze*o(F+Ne*M));if(de===Ot)return;let He=(qe.x===Ne?0:2)|Number(qe.y&me),Xi=de;return R&&f(de)&&(Xi=y(de),He^=1),new d(Ne,Xi,He)}return{seed:H,k2sig:ie}}const q={lowS:t.lowS,prehash:!1},N={lowS:t.lowS,prehash:!1};function C($,b,E=q){const{seed:x,k2sig:v}=P($,b,E),R=t;return ch(R.hash.outputLen,R.nByteLength,R.hmac)(x,v)}a.BASE._setWindowSize(8);function D($,b,E,x=N){var v;const R=$;b=We("msgHash",b),E=We("publicKey",E);const{lowS:L,prehash:B,format:k}=x;if(ca(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");const M=typeof R=="string"||ri(R),K=!M&&!k&&typeof R=="object"&&R!==null&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!M&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let H,F;try{if(K&&(H=new d(R.r,R.s)),M){try{k!=="compact"&&(H=d.fromDER(R))}catch(He){if(!(He instanceof Pt.Err))throw He}!H&&k!=="der"&&(H=d.fromCompact(R))}F=a.fromHex(E)}catch{return!1}if(!H||L&&H.hasHighS())return!1;B&&(b=t.hash(b));const{r:ie,s:G}=H,xe=A(b),ze=c(G),qe=o(xe*ze),Ne=o(ie*ze),de=(v=a.BASE.multiplyAndAddUnsafe(F,qe,Ne))===null||v===void 0?void 0:v.toAffine();return de?o(de.x)===ie:!1}return{CURVE:t,getPublicKey:w,getSharedSecret:O,sign:C,verify:D,ProjectivePoint:a,Signature:d,utils:g}}function lf(e){return{hash:e,hmac:(t,...i)=>mr(e,t,pp(...i)),randomBytes:Yi}}function uf(e,t){const i=s=>hf({...e,...lf(s)});return{...i(t),create:i}}const mh=uh(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),df=mh.create(BigInt("-3")),pf=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),gf=uf({a:df,b:pf,Fp:mh,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},xs),wh="base10",Ce="base16",lt="base64pad",kt="base64url",Rs="utf8",$h=0,Nt=1,Cs=2,ff=0,la=1,ps=12,to=32;function yf(){const e=In.utils.randomPrivateKey(),t=In.getPublicKey(e);return{privateKey:Be(e,Ce),publicKey:Be(t,Ce)}}function _n(){const e=Yi(to);return Be(e,Ce)}function mf(e,t){const i=In.getSharedSecret(it(e,Ce),it(t,Ce)),s=vg(xs,i,void 0,void 0,to);return Be(s,Ce)}function Ys(e){const t=xs(it(e,Ce));return Be(t,Ce)}function wt(e){const t=xs(it(e,Rs));return Be(t,Ce)}function vh(e){return it(`${e}`,wh)}function ni(e){return Number(Be(e,wh))}function bh(e){return e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function Eh(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),i=(4-t.length%4)%4;return t+"=".repeat(i)}function wf(e){const t=vh(typeof e.type<"u"?e.type:$h);if(ni(t)===Nt&&typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const i=typeof e.senderPublicKey<"u"?it(e.senderPublicKey,Ce):void 0,s=typeof e.iv<"u"?it(e.iv,Ce):Yi(ps),r=it(e.symKey,Ce),n=nh(r,s).encrypt(it(e.message,Rs)),o=Ih({type:t,sealed:n,iv:s,senderPublicKey:i});return e.encoding===kt?bh(o):o}function $f(e){const t=it(e.symKey,Ce),{sealed:i,iv:s}=Es({encoded:e.encoded,encoding:e.encoding}),r=nh(t,s).decrypt(i);if(r===null)throw new Error("Failed to decrypt");return Be(r,Rs)}function vf(e,t){const i=vh(Cs),s=Yi(ps),r=it(e,Rs),n=Ih({type:i,sealed:r,iv:s});return t===kt?bh(n):n}function bf(e,t){const{sealed:i}=Es({encoded:e,encoding:t});return Be(i,Rs)}function Ih(e){if(ni(e.type)===Cs)return Be(ds([e.type,e.sealed]),lt);if(ni(e.type)===Nt){if(typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return Be(ds([e.type,e.senderPublicKey,e.iv,e.sealed]),lt)}return Be(ds([e.type,e.iv,e.sealed]),lt)}function Es(e){const t=(e.encoding||lt)===kt?Eh(e.encoded):e.encoded,i=it(t,lt),s=i.slice(ff,la),r=la;if(ni(s)===Nt){const a=r+to,h=a+ps,l=i.slice(r,a),p=i.slice(a,h),u=i.slice(h);return{type:s,sealed:u,iv:p,senderPublicKey:l}}if(ni(s)===Cs){const a=i.slice(r),h=Yi(ps);return{type:s,sealed:a,iv:h}}const n=r+ps,o=i.slice(r,n),c=i.slice(n);return{type:s,sealed:c,iv:o}}function Ef(e,t){const i=Es({encoded:e,encoding:t==null?void 0:t.encoding});return _h({type:ni(i.type),senderPublicKey:typeof i.senderPublicKey<"u"?Be(i.senderPublicKey,Ce):void 0,receiverPublicKey:t==null?void 0:t.receiverPublicKey})}function _h(e){const t=(e==null?void 0:e.type)||$h;if(t===Nt){if(typeof(e==null?void 0:e.senderPublicKey)>"u")throw new Error("missing sender public key");if(typeof(e==null?void 0:e.receiverPublicKey)>"u")throw new Error("missing receiver public key")}return{type:t,senderPublicKey:e==null?void 0:e.senderPublicKey,receiverPublicKey:e==null?void 0:e.receiverPublicKey}}function ua(e){return e.type===Nt&&typeof e.senderPublicKey=="string"&&typeof e.receiverPublicKey=="string"}function da(e){return e.type===Cs}function If(e){const t=Ae.from(e.x,"base64"),i=Ae.from(e.y,"base64");return ds([new Uint8Array([4]),t,i])}function _f(e,t){const[i,s,r]=e.split("."),n=Ae.from(Eh(r),"base64");if(n.length!==64)throw new Error("Invalid signature length");const o=n.slice(0,32),c=n.slice(32,64),a=`${i}.${s}`,h=xs(a),l=If(t);if(!gf.verify(ds([o,c]),h,l))throw new Error("Invalid signature");return rn(e).payload}const Pf="irn";function ir(e){return(e==null?void 0:e.relay)||{protocol:Pf}}function hs(e){const t=yl[e];if(typeof t>"u")throw new Error(`Relay Protocol not supported: ${e}`);return t}function Sf(e,t="-"){const i={},s="relay"+t;return Object.keys(e).forEach(r=>{if(r.startsWith(s)){const n=r.replace(s,""),o=e[r];i[n]=o}}),i}function pa(e){if(!e.includes("wc:")){const h=Fc(e);h!=null&&h.includes("wc:")&&(e=h)}e=e.includes("wc://")?e.replace("wc://",""):e,e=e.includes("wc:")?e.replace("wc:",""):e;const t=e.indexOf(":"),i=e.indexOf("?")!==-1?e.indexOf("?"):void 0,s=e.substring(0,t),r=e.substring(t+1,i).split("@"),n=typeof i<"u"?e.substring(i):"",o=new URLSearchParams(n),c={};o.forEach((h,l)=>{c[l]=h});const a=typeof c.methods=="string"?c.methods.split(","):void 0;return{protocol:s,topic:Of(r[0]),version:parseInt(r[1],10),symKey:c.symKey,relay:Sf(c),methods:a,expiryTimestamp:c.expiryTimestamp?parseInt(c.expiryTimestamp,10):void 0}}function Of(e){return e.startsWith("//")?e.substring(2):e}function Af(e,t="-"){const i="relay",s={};return Object.keys(e).forEach(r=>{const n=r,o=i+t+n;e[n]&&(s[o]=e[n])}),s}function ga(e){const t=new URLSearchParams,i=Af(e.relay);Object.keys(i).sort().forEach(r=>{t.set(r,i[r])}),t.set("symKey",e.symKey),e.expiryTimestamp&&t.set("expiryTimestamp",e.expiryTimestamp.toString()),e.methods&&t.set("methods",e.methods.join(","));const s=t.toString();return`${e.protocol}:${e.topic}@${e.version}?${s}`}function Ms(e,t,i){return`${e}?wc_ev=${i}&topic=${t}`}var xf=Object.defineProperty,Nf=Object.defineProperties,Rf=Object.getOwnPropertyDescriptors,fa=Object.getOwnPropertySymbols,Cf=Object.prototype.hasOwnProperty,Tf=Object.prototype.propertyIsEnumerable,ya=(e,t,i)=>t in e?xf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,qf=(e,t)=>{for(var i in t||(t={}))Cf.call(t,i)&&ya(e,i,t[i]);if(fa)for(var i of fa(t))Tf.call(t,i)&&ya(e,i,t[i]);return e},Uf=(e,t)=>Nf(e,Rf(t));function Qi(e){const t=[];return e.forEach(i=>{const[s,r]=i.split(":");t.push(`${s}:${r}`)}),t}function Df(e){const t=[];return Object.values(e).forEach(i=>{t.push(...Qi(i.accounts))}),t}function kf(e,t){const i=[];return Object.values(e).forEach(s=>{Qi(s.accounts).includes(t)&&i.push(...s.methods)}),i}function jf(e,t){const i=[];return Object.values(e).forEach(s=>{Qi(s.accounts).includes(t)&&i.push(...s.events)}),i}function Ph(e){return e.includes(":")}function Lf(e){return Ph(e)?e.split(":")[0]:e}function ma(e){var t,i,s;const r={};if(!Is(e))return r;for(const[n,o]of Object.entries(e)){const c=Ph(n)?[n]:o.chains,a=o.methods||[],h=o.events||[],l=Lf(n);r[l]=Uf(qf({},r[l]),{chains:ei(c,(t=r[l])==null?void 0:t.chains),methods:ei(a,(i=r[l])==null?void 0:i.methods),events:ei(h,(s=r[l])==null?void 0:s.events)})}return r}function Bf(e){const t={};return e==null||e.forEach(i=>{var s;const[r,n]=i.split(":");t[r]||(t[r]={accounts:[],chains:[],events:[],methods:[]}),t[r].accounts.push(i),(s=t[r].chains)==null||s.push(`${r}:${n}`)}),t}function wa(e,t){t=t.map(s=>s.replace("did:pkh:",""));const i=Bf(t);for(const[s,r]of Object.entries(i))r.methods?r.methods=ei(r.methods,e):r.methods=e,r.events=["chainChanged","accountsChanged"];return i}function Mf(e,t){var i,s,r,n,o,c;const a=ma(e),h=ma(t),l={},p=Object.keys(a).concat(Object.keys(h));for(const u of p)l[u]={chains:ei((i=a[u])==null?void 0:i.chains,(s=h[u])==null?void 0:s.chains),methods:ei((r=a[u])==null?void 0:r.methods,(n=h[u])==null?void 0:n.methods),events:ei((o=a[u])==null?void 0:o.events,(c=h[u])==null?void 0:c.events)};return l}const zf={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},Hf={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function j(e,t){const{message:i,code:s}=Hf[e];return{message:t?`${i} ${t}`:i,code:s}}function oe(e,t){const{message:i,code:s}=zf[e];return{message:t?`${i} ${t}`:i,code:s}}function Ts(e,t){return Array.isArray(e)?typeof t<"u"&&e.length?e.every(t):!0:!1}function Is(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function Pe(e){return typeof e>"u"}function ue(e,t){return t&&Pe(e)?!0:typeof e=="string"&&!!e.trim().length}function io(e,t){return t&&Pe(e)?!0:typeof e=="number"&&!isNaN(e)}function Vf(e,t){const{requiredNamespaces:i}=t,s=Object.keys(e.namespaces),r=Object.keys(i);let n=!0;return Qt(r,s)?(s.forEach(o=>{const{accounts:c,methods:a,events:h}=e.namespaces[o],l=Qi(c),p=i[o];(!Qt(Mc(o,p),l)||!Qt(p.methods,a)||!Qt(p.events,h))&&(n=!1)}),n):!1}function sr(e){return ue(e,!1)&&e.includes(":")?e.split(":").length===2:!1}function Kf(e){if(ue(e,!1)&&e.includes(":")){const t=e.split(":");if(t.length===3){const i=t[0]+":"+t[1];return!!t[2]&&sr(i)}}return!1}function Ff(e){function t(i){try{return typeof new URL(i)<"u"}catch{return!1}}try{if(ue(e,!1)){if(t(e))return!0;const i=Fc(e);return t(i)}}catch{}return!1}function Gf(e){var t;return(t=e==null?void 0:e.proposer)==null?void 0:t.publicKey}function Wf(e){return e==null?void 0:e.topic}function Zf(e,t){let i=null;return ue(e==null?void 0:e.publicKey,!1)||(i=j("MISSING_OR_INVALID",`${t} controller public key should be a string`)),i}function $a(e){let t=!0;return Ts(e)?e.length&&(t=e.every(i=>ue(i,!1))):t=!1,t}function Yf(e,t,i){let s=null;return Ts(t)&&t.length?t.forEach(r=>{s||sr(r)||(s=oe("UNSUPPORTED_CHAINS",`${i}, chain ${r} should be a string and conform to "namespace:chainId" format`))}):sr(e)||(s=oe("UNSUPPORTED_CHAINS",`${i}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),s}function Jf(e,t,i){let s=null;return Object.entries(e).forEach(([r,n])=>{if(s)return;const o=Yf(r,Mc(r,n),`${t} ${i}`);o&&(s=o)}),s}function Qf(e,t){let i=null;return Ts(e)?e.forEach(s=>{i||Kf(s)||(i=oe("UNSUPPORTED_ACCOUNTS",`${t}, account ${s} should be a string and conform to "namespace:chainId:address" format`))}):i=oe("UNSUPPORTED_ACCOUNTS",`${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),i}function Xf(e,t){let i=null;return Object.values(e).forEach(s=>{if(i)return;const r=Qf(s==null?void 0:s.accounts,`${t} namespace`);r&&(i=r)}),i}function ey(e,t){let i=null;return $a(e==null?void 0:e.methods)?$a(e==null?void 0:e.events)||(i=oe("UNSUPPORTED_EVENTS",`${t}, events should be an array of strings or empty array for no events`)):i=oe("UNSUPPORTED_METHODS",`${t}, methods should be an array of strings or empty array for no methods`),i}function Sh(e,t){let i=null;return Object.values(e).forEach(s=>{if(i)return;const r=ey(s,`${t}, namespace`);r&&(i=r)}),i}function ty(e,t,i){let s=null;if(e&&Is(e)){const r=Sh(e,t);r&&(s=r);const n=Jf(e,t,i);n&&(s=n)}else s=j("MISSING_OR_INVALID",`${t}, ${i} should be an object with data`);return s}function Kr(e,t){let i=null;if(e&&Is(e)){const s=Sh(e,t);s&&(i=s);const r=Xf(e,t);r&&(i=r)}else i=j("MISSING_OR_INVALID",`${t}, namespaces should be an object with data`);return i}function Oh(e){return ue(e.protocol,!0)}function iy(e,t){let i=!1;return t&&!e?i=!0:e&&Ts(e)&&e.length&&e.forEach(s=>{i=Oh(s)}),i}function sy(e){return typeof e=="number"}function De(e){return typeof e<"u"&&!0}function ry(e){return!(!e||typeof e!="object"||!e.code||!io(e.code,!1)||!e.message||!ue(e.message,!1))}function ny(e){return!(Pe(e)||!ue(e.method,!1))}function oy(e){return!(Pe(e)||Pe(e.result)&&Pe(e.error)||!io(e.id,!1)||!ue(e.jsonrpc,!1))}function ay(e){return!(Pe(e)||!ue(e.name,!1))}function va(e,t){return!(!sr(t)||!Df(e).includes(t))}function cy(e,t,i){return ue(i,!1)?kf(e,t).includes(i):!1}function hy(e,t,i){return ue(i,!1)?jf(e,t).includes(i):!1}function ba(e,t,i){let s=null;const r=ly(e),n=uy(t),o=Object.keys(r),c=Object.keys(n),a=Ea(Object.keys(e)),h=Ea(Object.keys(t)),l=a.filter(p=>!h.includes(p));return l.length&&(s=j("NON_CONFORMING_NAMESPACES",`${i} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(t).toString()}`)),Qt(o,c)||(s=j("NON_CONFORMING_NAMESPACES",`${i} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${c.toString()}`)),Object.keys(t).forEach(p=>{if(!p.includes(":")||s)return;const u=Qi(t[p].accounts);u.includes(p)||(s=j("NON_CONFORMING_NAMESPACES",`${i} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${u.toString()}`))}),o.forEach(p=>{s||(Qt(r[p].methods,n[p].methods)?Qt(r[p].events,n[p].events)||(s=j("NON_CONFORMING_NAMESPACES",`${i} namespaces events don't satisfy namespace events for ${p}`)):s=j("NON_CONFORMING_NAMESPACES",`${i} namespaces methods don't satisfy namespace methods for ${p}`))}),s}function ly(e){const t={};return Object.keys(e).forEach(i=>{var s;i.includes(":")?t[i]=e[i]:(s=e[i].chains)==null||s.forEach(r=>{t[r]={methods:e[i].methods,events:e[i].events}})}),t}function Ea(e){return[...new Set(e.map(t=>t.includes(":")?t.split(":")[0]:t))]}function uy(e){const t={};return Object.keys(e).forEach(i=>{if(i.includes(":"))t[i]=e[i];else{const s=Qi(e[i].accounts);s==null||s.forEach(r=>{t[r]={accounts:e[i].accounts.filter(n=>n.includes(`${r}:`)),methods:e[i].methods,events:e[i].events}})}}),t}function dy(e,t){return io(e,!1)&&e<=t.max&&e>=t.min}function Ia(){const e=Os();return new Promise(t=>{switch(e){case Le.browser:t(py());break;case Le.reactNative:t(gy());break;case Le.node:t(fy());break;default:t(!0)}})}function py(){var e;return Zi()&&((e=navigator)===null||e===void 0?void 0:e.onLine)}async function gy(){if(zt()&&typeof V<"u"&&V!=null&&V.NetInfo){const e=await(V==null?void 0:V.NetInfo.fetch());return e==null?void 0:e.isConnected}return!0}function fy(){return!0}function yy(e){switch(Os()){case Le.browser:my(e);break;case Le.reactNative:wy(e);break;case Le.node:break}}function my(e){!zt()&&Zi()&&(window.addEventListener("online",()=>e(!0)),window.addEventListener("offline",()=>e(!1)))}function wy(e){zt()&&typeof V<"u"&&V!=null&&V.NetInfo&&(V===null||V===void 0||V.NetInfo.addEventListener(t=>e(t==null?void 0:t.isConnected)))}function $y(){var e;return Zi()&&(0,Mt.getDocument)()?((e=(0,Mt.getDocument)())==null?void 0:e.visibilityState)==="visible":!0}const Fr={};var is=class{static get(e){return Fr[e]}static set(e,t){Fr[e]=t}static delete(e){delete Fr[e]}};cr();Bn();var oi=Me(_s()),z=Me(ur()),vy=Me(Vn());const Ah="wc",xh=2,rr="core",$t=`${Ah}@2:${rr}:`,by={name:rr,logger:"error"},Ey={database:":memory:"},Iy="crypto",_a="client_ed25519_seed",_y=z.ONE_DAY,Py="keychain",Sy="0.3",Oy="messages",Ay="0.3",Pa=z.SIX_HOURS,xy="publisher",Nh="irn",Ny="error",Rh="wss://relay.walletconnect.org",Ry="relayer",we={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},Cy="_subscription",Xe={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},Ty=.1;const Pn="2.21.1";const ae={link_mode:"link_mode",relay:"relay"},Js={inbound:"inbound",outbound:"outbound"},qy="0.3",Uy="WALLETCONNECT_CLIENT_ID",Sa="WALLETCONNECT_LINK_MODE_APPS",Fe={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},Zb=z.THIRTY_DAYS,Dy="subscription",ky="0.3",Yb=z.FIVE_SECONDS*1e3,jy="pairing",Ly="0.3",Jb=z.THIRTY_DAYS,ss={wc_pairingDelete:{req:{ttl:z.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:z.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:z.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:z.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:z.ONE_DAY,prompt:!1,tag:0},res:{ttl:z.ONE_DAY,prompt:!1,tag:0}}},Zt={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},nt={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},By="history",My="0.3",zy="expirer",tt={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},Hy="0.3",Qb=z.ONE_DAY,Vy="verify-api",Ky="https://verify.walletconnect.com",Ch="https://verify.walletconnect.org",gs=Ch,Fy=`${gs}/v3`,Gy=[Ky,Ch],Wy="echo",Zy="https://echo.walletconnect.com";const yt={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},It={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},ot={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},Ht={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},Vt={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},rs={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},Yy=.1,Jy="event-client",Qy=86400,Xy="https://pulse.walletconnect.org/batch";function em(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var i=new Uint8Array(256),s=0;s<i.length;s++)i[s]=255;for(var r=0;r<e.length;r++){var n=e.charAt(r),o=n.charCodeAt(0);if(i[o]!==255)throw new TypeError(n+" is ambiguous");i[o]=r}var c=e.length,a=e.charAt(0),h=Math.log(c)/Math.log(256),l=Math.log(256)/Math.log(c);function p(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var m=0,d=0,g=0,w=y.length;g!==w&&y[g]===0;)g++,m++;for(var _=(w-g)*l+1>>>0,O=new Uint8Array(_);g!==w;){for(var T=y[g],A=0,S=_-1;(T!==0||A<d)&&S!==-1;S--,A++)T+=256*O[S]>>>0,O[S]=T%c>>>0,T=T/c>>>0;if(T!==0)throw new Error("Non-zero carry");d=A,g++}for(var I=_-d;I!==_&&O[I]===0;)I++;for(var P=a.repeat(m);I<_;++I)P+=e.charAt(O[I]);return P}function u(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;var m=0;if(y[m]!==" "){for(var d=0,g=0;y[m]===a;)d++,m++;for(var w=(y.length-m)*h+1>>>0,_=new Uint8Array(w);y[m];){var O=i[y.charCodeAt(m)];if(O===255)return;for(var T=0,A=w-1;(O!==0||T<g)&&A!==-1;A--,T++)O+=c*_[A]>>>0,_[A]=O%256>>>0,O=O/256>>>0;if(O!==0)throw new Error("Non-zero carry");g=T,m++}if(y[m]!==" "){for(var S=w-g;S!==w&&_[S]===0;)S++;for(var I=new Uint8Array(d+(w-S)),P=d;S!==w;)I[P++]=_[S++];return I}}}function f(y){var m=u(y);if(m)return m;throw new Error(`Non-${t} character`)}return{encode:p,decodeUnsafe:u,decode:f}}var tm=em,im=tm;const Th=e=>{if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")},sm=e=>new TextEncoder().encode(e),rm=e=>new TextDecoder().decode(e);var nm=class{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},om=class{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return qh(this,e)}},am=class{constructor(e){this.decoders=e}or(e){return qh(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const qh=(e,t)=>new am({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});var cm=class{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new nm(e,t,i),this.decoder=new om(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const Er=({name:e,prefix:t,encode:i,decode:s})=>new cm(e,t,i,s),qs=({prefix:e,name:t,alphabet:i})=>{const{encode:s,decode:r}=im(i,t);return Er({prefix:e,name:t,encode:s,decode:n=>Th(r(n))})},hm=(e,t,i,s)=>{const r={};for(let l=0;l<t.length;++l)r[t[l]]=l;let n=e.length;for(;e[n-1]==="=";)--n;const o=new Uint8Array(n*i/8|0);let c=0,a=0,h=0;for(let l=0;l<n;++l){const p=r[e[l]];if(p===void 0)throw new SyntaxError(`Non-${s} character`);a=a<<i|p,c+=i,c>=8&&(c-=8,o[h++]=255&a>>c)}if(c>=i||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return o},lm=(e,t,i)=>{const s=t[t.length-1]==="=",r=(1<<i)-1;let n="",o=0,c=0;for(let a=0;a<e.length;++a)for(c=c<<8|e[a],o+=8;o>i;)o-=i,n+=t[r&c>>o];if(o&&(n+=t[r&c<<i-o]),s)for(;n.length*i&7;)n+="=";return n},Se=({name:e,prefix:t,bitsPerChar:i,alphabet:s})=>Er({prefix:t,name:e,encode(r){return lm(r,s,i)},decode(r){return hm(r,s,i,e)}}),um=Er({prefix:"\0",name:"identity",encode:e=>rm(e),decode:e=>sm(e)});var dm=Object.freeze({__proto__:null,identity:um});const pm=Se({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var gm=Object.freeze({__proto__:null,base2:pm});const fm=Se({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ym=Object.freeze({__proto__:null,base8:fm});const mm=qs({prefix:"9",name:"base10",alphabet:"0123456789"});var wm=Object.freeze({__proto__:null,base10:mm});const $m=Se({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),vm=Se({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var bm=Object.freeze({__proto__:null,base16:$m,base16upper:vm});const Em=Se({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Im=Se({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),_m=Se({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Pm=Se({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Sm=Se({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Om=Se({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Am=Se({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),xm=Se({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Nm=Se({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Rm=Object.freeze({__proto__:null,base32:Em,base32upper:Im,base32pad:_m,base32padupper:Pm,base32hex:Sm,base32hexupper:Om,base32hexpad:Am,base32hexpadupper:xm,base32z:Nm});const Cm=qs({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Tm=qs({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var qm=Object.freeze({__proto__:null,base36:Cm,base36upper:Tm});const Um=qs({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Dm=qs({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var km=Object.freeze({__proto__:null,base58btc:Um,base58flickr:Dm});const jm=Se({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Lm=Se({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Bm=Se({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Mm=Se({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var zm=Object.freeze({__proto__:null,base64:jm,base64pad:Lm,base64url:Bm,base64urlpad:Mm});const Uh=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Hm=Uh.reduce((e,t,i)=>(e[i]=t,e),[]),Vm=Uh.reduce((e,t,i)=>(e[t.codePointAt(0)]=i,e),[]);function Km(e){return e.reduce((t,i)=>(t+=Hm[i],t),"")}function Fm(e){const t=[];for(const i of e){const s=Vm[i.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${i}`);t.push(s)}return new Uint8Array(t)}const Gm=Er({prefix:"🚀",name:"base256emoji",encode:Km,decode:Fm});var Wm=Object.freeze({__proto__:null,base256emoji:Gm}),Zm=Dh,Oa=128,Ym=127,Jm=~Ym,Qm=Math.pow(2,31);function Dh(e,t,i){t=t||[],i=i||0;for(var s=i;e>=Qm;)t[i++]=e&255|Oa,e/=128;for(;e&Jm;)t[i++]=e&255|Oa,e>>>=7;return t[i]=e|0,Dh.bytes=i-s+1,t}var Xm=Sn,ew=128,Aa=127;function Sn(e,s){var i=0,s=s||0,r=0,n=s,o,c=e.length;do{if(n>=c)throw Sn.bytes=0,new RangeError("Could not decode varint");o=e[n++],i+=r<28?(o&Aa)<<r:(o&Aa)*Math.pow(2,r),r+=7}while(o>=ew);return Sn.bytes=n-s,i}var tw=Math.pow(2,7),iw=Math.pow(2,14),sw=Math.pow(2,21),rw=Math.pow(2,28),nw=Math.pow(2,35),ow=Math.pow(2,42),aw=Math.pow(2,49),cw=Math.pow(2,56),hw=Math.pow(2,63),lw=function(e){return e<tw?1:e<iw?2:e<sw?3:e<rw?4:e<nw?5:e<ow?6:e<aw?7:e<cw?8:e<hw?9:10},uw={encode:Zm,decode:Xm,encodingLength:lw},kh=uw;const xa=(e,t,i=0)=>(kh.encode(e,t,i),t),Na=e=>kh.encodingLength(e),On=(e,t)=>{const i=t.byteLength,s=Na(e),r=s+Na(i),n=new Uint8Array(r+i);return xa(e,n,0),xa(i,n,s),n.set(t,r),new dw(e,i,t,n)};var dw=class{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}};const jh=({name:e,code:t,encode:i})=>new pw(e,t,i);var pw=class{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?On(this.code,t):t.then(i=>On(this.code,i))}else throw Error("Unknown type, must be binary type")}};const Lh=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),gw=jh({name:"sha2-256",code:18,encode:Lh("SHA-256")}),fw=jh({name:"sha2-512",code:19,encode:Lh("SHA-512")});var yw=Object.freeze({__proto__:null,sha256:gw,sha512:fw});const Bh=0,mw="identity",Mh=Th,ww=e=>On(Bh,Mh(e)),$w={code:Bh,name:mw,encode:Mh,digest:ww};var vw=Object.freeze({__proto__:null,identity:$w});new TextEncoder,new TextDecoder;const Ra={...dm,...gm,...ym,...wm,...bm,...Rm,...qm,...km,...zm,...Wm};({...yw,...vw});function bw(e=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(e):new Uint8Array(e)}function zh(e,t,i,s){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:i},decoder:{decode:s}}}const Ca=zh("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),Gr=zh("ascii","a",e=>{let t="a";for(let i=0;i<e.length;i++)t+=String.fromCharCode(e[i]);return t},e=>{e=e.substring(1);const t=bw(e.length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t}),Ew={utf8:Ca,"utf-8":Ca,hex:Ra.base16,latin1:Gr,ascii:Gr,binary:Gr,...Ra};function Iw(e,t="utf8"){const i=Ew[t];if(!i)throw new Error(`Unsupported encoding "${t}"`);return(t==="utf8"||t==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(e,"utf8"):i.decoder.decode(`${i.prefix}${e}`)}var _w=Object.defineProperty,Pw=(e,t,i)=>t in e?_w(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,gt=(e,t,i)=>Pw(e,typeof t!="symbol"?t+"":t,i),Sw=class{constructor(e,t){this.core=e,this.logger=t,gt(this,"keychain",new Map),gt(this,"name",Py),gt(this,"version",Sy),gt(this,"initialized",!1),gt(this,"storagePrefix",$t),gt(this,"init",async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}}),gt(this,"has",i=>(this.isInitialized(),this.keychain.has(i))),gt(this,"set",async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()}),gt(this,"get",i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:r}=j("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(r)}return s}),gt(this,"del",async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()}),this.core=e,this.logger=Te(t,this.name)}get context(){return Qe(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,pn(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?gn(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}},Ow=Object.defineProperty,Aw=(e,t,i)=>t in e?Ow(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ie=(e,t,i)=>Aw(e,typeof t!="symbol"?t+"":t,i),xw=class{constructor(e,t,i){this.core=e,this.logger=t,Ie(this,"name",Iy),Ie(this,"keychain"),Ie(this,"randomSessionIdentifier",_n()),Ie(this,"initialized",!1),Ie(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),Ie(this,"hasKeys",s=>(this.isInitialized(),this.keychain.has(s))),Ie(this,"getClientId",async()=>{this.isInitialized();const s=await this.getClientSeed(),r=oo(s);return ml(r.publicKey)}),Ie(this,"generateKeyPair",()=>{this.isInitialized();const s=yf();return this.setPrivateKey(s.publicKey,s.privateKey)}),Ie(this,"signJWT",async s=>{this.isInitialized();const r=await this.getClientSeed(),n=oo(r),o=this.randomSessionIdentifier;return await wl(o,s,_y,n)}),Ie(this,"generateSharedKey",(s,r,n)=>{this.isInitialized();const o=this.getPrivateKey(s),c=mf(o,r);return this.setSymKey(c,n)}),Ie(this,"setSymKey",async(s,r)=>{this.isInitialized();const n=r||Ys(s);return await this.keychain.set(n,s),n}),Ie(this,"deleteKeyPair",async s=>{this.isInitialized(),await this.keychain.del(s)}),Ie(this,"deleteSymKey",async s=>{this.isInitialized(),await this.keychain.del(s)}),Ie(this,"encode",async(s,r,n)=>{this.isInitialized();const o=_h(n),c=Il(r);if(da(o))return vf(c,n==null?void 0:n.encoding);if(ua(o)){const p=o.senderPublicKey,u=o.receiverPublicKey;s=await this.generateSharedKey(p,u)}const a=this.getSymKey(s),{type:h,senderPublicKey:l}=o;return wf({type:h,symKey:a,message:c,senderPublicKey:l,encoding:n==null?void 0:n.encoding})}),Ie(this,"decode",async(s,r,n)=>{this.isInitialized();const o=Ef(r,n);if(da(o)){const c=bf(r,n==null?void 0:n.encoding);return ao(c)}if(ua(o)){const c=o.receiverPublicKey,a=o.senderPublicKey;s=await this.generateSharedKey(c,a)}try{const c=this.getSymKey(s),a=$f({symKey:c,encoded:r,encoding:n==null?void 0:n.encoding});return ao(a)}catch(c){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(c)}}),Ie(this,"getPayloadType",(s,r=lt)=>{const n=Es({encoded:s,encoding:r});return ni(n.type)}),Ie(this,"getPayloadSenderPublicKey",(s,r=lt)=>{const n=Es({encoded:s,encoding:r});return n.senderPublicKey?Be(n.senderPublicKey,Ce):void 0}),this.core=e,this.logger=Te(t,this.name),this.keychain=i||new Sw(this.core,this.logger)}get context(){return Qe(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(_a)}catch{e=_n(),await this.keychain.set(_a,e)}return Iw(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}},Nw=Object.defineProperty,Rw=Object.defineProperties,Cw=Object.getOwnPropertyDescriptors,Ta=Object.getOwnPropertySymbols,Tw=Object.prototype.hasOwnProperty,qw=Object.prototype.propertyIsEnumerable,An=(e,t,i)=>t in e?Nw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Uw=(e,t)=>{for(var i in t||(t={}))Tw.call(t,i)&&An(e,i,t[i]);if(Ta)for(var i of Ta(t))qw.call(t,i)&&An(e,i,t[i]);return e},Dw=(e,t)=>Rw(e,Cw(t)),Ve=(e,t,i)=>An(e,typeof t!="symbol"?t+"":t,i),kw=class extends md{constructor(e,t){super(e,t),this.logger=e,this.core=t,Ve(this,"messages",new Map),Ve(this,"messagesWithoutClientAck",new Map),Ve(this,"name",Oy),Ve(this,"version",Ay),Ve(this,"initialized",!1),Ve(this,"storagePrefix",$t),Ve(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i);const s=await this.getRelayerMessagesWithoutClientAck();typeof s<"u"&&(this.messagesWithoutClientAck=s),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}}),Ve(this,"set",async(i,s,r)=>{this.isInitialized();const n=wt(s);let o=this.messages.get(i);if(typeof o>"u"&&(o={}),typeof o[n]<"u")return n;if(o[n]=s,this.messages.set(i,o),r===Js.inbound){const c=this.messagesWithoutClientAck.get(i)||{};this.messagesWithoutClientAck.set(i,Dw(Uw({},c),{[n]:s}))}return await this.persist(),n}),Ve(this,"get",i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s}),Ve(this,"getWithoutAck",i=>{this.isInitialized();const s={};for(const r of i){const n=this.messagesWithoutClientAck.get(r)||{};s[r]=Object.values(n)}return s}),Ve(this,"has",(i,s)=>{this.isInitialized();const r=this.get(i),n=wt(s);return typeof r[n]<"u"}),Ve(this,"ack",async(i,s)=>{this.isInitialized();const r=this.messagesWithoutClientAck.get(i);if(typeof r>"u")return;const n=wt(s);delete r[n],Object.keys(r).length===0?this.messagesWithoutClientAck.delete(i):this.messagesWithoutClientAck.set(i,r),await this.persist()}),Ve(this,"del",async i=>{this.isInitialized(),this.messages.delete(i),this.messagesWithoutClientAck.delete(i),await this.persist()}),this.logger=Te(e,this.name),this.core=t}get context(){return Qe(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,pn(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,pn(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?gn(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?gn(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}},jw=Object.defineProperty,Lw=Object.defineProperties,Bw=Object.getOwnPropertyDescriptors,qa=Object.getOwnPropertySymbols,Mw=Object.prototype.hasOwnProperty,zw=Object.prototype.propertyIsEnumerable,xn=(e,t,i)=>t in e?jw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,zs=(e,t)=>{for(var i in t||(t={}))Mw.call(t,i)&&xn(e,i,t[i]);if(qa)for(var i of qa(t))zw.call(t,i)&&xn(e,i,t[i]);return e},Wr=(e,t)=>Lw(e,Bw(t)),at=(e,t,i)=>xn(e,typeof t!="symbol"?t+"":t,i),Hw=class extends wd{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,at(this,"events",new oi.EventEmitter),at(this,"name",xy),at(this,"queue",new Map),at(this,"publishTimeout",(0,z.toMiliseconds)(z.ONE_MINUTE)),at(this,"initialPublishTimeout",(0,z.toMiliseconds)(z.ONE_SECOND*15)),at(this,"needsTransportRestart",!1),at(this,"publish",async(i,s,r)=>{var n;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:r}});const o=(r==null?void 0:r.ttl)||Pa,c=ir(r),a=(r==null?void 0:r.prompt)||!1,h=(r==null?void 0:r.tag)||0,l=(r==null?void 0:r.id)||Oi().toString(),p={topic:i,message:s,opts:{ttl:o,relay:c,prompt:a,tag:h,id:l,attestation:r==null?void 0:r.attestation,tvf:r==null?void 0:r.tvf}},u=`Failed to publish payload, please try again. id:${l} tag:${h}`;try{const f=new Promise(async y=>{const m=({id:g})=>{p.opts.id===g&&(this.removeRequestFromQueue(g),this.relayer.events.removeListener(we.publish,m),y(p))};this.relayer.events.on(we.publish,m);const d=jt(new Promise((g,w)=>{this.rpcPublish({topic:i,message:s,ttl:o,prompt:a,tag:h,id:l,attestation:r==null?void 0:r.attestation,tvf:r==null?void 0:r.tvf}).then(g).catch(_=>{this.logger.warn(_,_==null?void 0:_.message),w(_)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${l} tag:${h}`);try{await d,this.events.removeListener(we.publish,m)}catch(g){this.queue.set(l,Wr(zs({},p),{attempt:1})),this.logger.warn(g,g==null?void 0:g.message)}});this.logger.trace({type:"method",method:"publish",params:{id:l,topic:i,message:s,opts:r}}),await jt(f,this.publishTimeout,u)}catch(f){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(f),(n=r==null?void 0:r.internal)!=null&&n.throwOnFailedPublish)throw f}finally{this.queue.delete(l)}}),at(this,"on",(i,s)=>{this.events.on(i,s)}),at(this,"once",(i,s)=>{this.events.once(i,s)}),at(this,"off",(i,s)=>{this.events.off(i,s)}),at(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.relayer=e,this.logger=Te(t,this.name),this.registerEventListeners()}get context(){return Qe(this.logger)}async rpcPublish(e){var t,i,s,r;const{topic:n,message:o,ttl:c=Pa,prompt:a,tag:h,id:l,attestation:p,tvf:u}=e,f={method:hs(ir().protocol).publish,params:zs({topic:n,message:o,ttl:c,prompt:a,tag:h,attestation:p},u),id:l};Pe((t=f.params)==null?void 0:t.prompt)&&((i=f.params)==null||delete i.prompt),Pe((s=f.params)==null?void 0:s.tag)&&((r=f.params)==null||delete r.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:f});const y=await this.relayer.request(f);return this.relayer.events.emit(we.publish,e),this.logger.debug("Successfully Published Payload"),y}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{const i=e.attempt+1;this.queue.set(t,Wr(zs({},e),{attempt:i}));const{topic:s,message:r,opts:n,attestation:o}=e;this.logger.warn({},`Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i}`),await this.rpcPublish(Wr(zs({},e),{topic:s,message:r,ttl:n.ttl,prompt:n.prompt,tag:n.tag,id:n.id,attestation:o,tvf:n.tvf})),this.logger.warn({},`Publisher: queue->published: ${e.opts.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(Gi.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(we.connection_stalled);return}this.checkQueue()}),this.relayer.on(we.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}},Vw=Object.defineProperty,Kw=(e,t,i)=>t in e?Vw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,pi=(e,t,i)=>Kw(e,typeof t!="symbol"?t+"":t,i),Fw=class{constructor(){pi(this,"map",new Map),pi(this,"set",(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])}),pi(this,"get",e=>this.map.get(e)||[]),pi(this,"exists",(e,t)=>this.get(e).includes(t)),pi(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(r=>r!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)}),pi(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}},Gw=Object.defineProperty,Ww=Object.defineProperties,Zw=Object.getOwnPropertyDescriptors,Ua=Object.getOwnPropertySymbols,Yw=Object.prototype.hasOwnProperty,Jw=Object.prototype.propertyIsEnumerable,Nn=(e,t,i)=>t in e?Gw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ns=(e,t)=>{for(var i in t||(t={}))Yw.call(t,i)&&Nn(e,i,t[i]);if(Ua)for(var i of Ua(t))Jw.call(t,i)&&Nn(e,i,t[i]);return e},Zr=(e,t)=>Ww(e,Zw(t)),se=(e,t,i)=>Nn(e,typeof t!="symbol"?t+"":t,i),Qw=class extends bd{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,se(this,"subscriptions",new Map),se(this,"topicMap",new Fw),se(this,"events",new oi.EventEmitter),se(this,"name",Dy),se(this,"version",ky),se(this,"pending",new Map),se(this,"cached",[]),se(this,"initialized",!1),se(this,"storagePrefix",$t),se(this,"subscribeTimeout",(0,z.toMiliseconds)(z.ONE_MINUTE)),se(this,"initialSubscribeTimeout",(0,z.toMiliseconds)(z.ONE_SECOND*15)),se(this,"clientId"),se(this,"batchSubscribeTopicsLimit",500),se(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),se(this,"subscribe",async(i,s)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const r=ir(s),n={topic:i,relay:r,transportType:s==null?void 0:s.transportType};this.pending.set(i,n);const o=await this.rpcSubscribe(i,r,s);return typeof o=="string"&&(this.onSubscribe(o,n),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}})),o}catch(r){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(r),r}}),se(this,"unsubscribe",async(i,s)=>{this.isInitialized(),typeof(s==null?void 0:s.id)<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)}),se(this,"isSubscribed",i=>new Promise(s=>{s(this.topicMap.topics.includes(i))})),se(this,"isKnownTopic",i=>new Promise(s=>{s(this.topicMap.topics.includes(i)||this.pending.has(i)||this.cached.some(r=>r.topic===i))})),se(this,"on",(i,s)=>{this.events.on(i,s)}),se(this,"once",(i,s)=>{this.events.once(i,s)}),se(this,"off",(i,s)=>{this.events.off(i,s)}),se(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),se(this,"start",async()=>{await this.onConnect()}),se(this,"stop",async()=>{await this.onDisconnect()}),se(this,"restart",async()=>{await this.restore(),await this.onRestart()}),se(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const i=[];this.pending.forEach(s=>{i.push(s)}),await this.batchSubscribe(i)}),se(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(Gi.pulse,async()=>{await this.checkPending()}),this.events.on(Fe.created,async i=>{const s=Fe.created;this.logger.info(`Emitting ${s}`),this.logger.debug({type:"event",event:s,data:i}),await this.persist()}),this.events.on(Fe.deleted,async i=>{const s=Fe.deleted;this.logger.info(`Emitting ${s}`),this.logger.debug({type:"event",event:s,data:i}),await this.persist()})}),this.relayer=e,this.logger=Te(t,this.name),this.clientId=""}get context(){return Qe(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}reset(){this.cached=[],this.initialized=!0}onDisable(){this.values.length>0&&(this.cached=this.values),this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=ir(i);await this.restartToComplete({topic:e,id:t,relay:s}),await this.rpcUnsubscribe(e,t,s);const r=oe("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t,i){var s;(!i||(i==null?void 0:i.transportType)===ae.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const r={method:hs(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:r});const n=(s=i==null?void 0:i.internal)==null?void 0:s.throwOnFailedPublish;try{const o=await this.getSubscriptionId(e);if((i==null?void 0:i.transportType)===ae.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(r).catch(h=>this.logger.warn(h))},(0,z.toMiliseconds)(z.ONE_SECOND)),o;const c=new Promise(async h=>{const l=p=>{p.topic===e&&(this.events.removeListener(Fe.created,l),h(p.id))};this.events.on(Fe.created,l);try{const p=await jt(new Promise((u,f)=>{this.relayer.request(r).catch(y=>{this.logger.warn(y,y==null?void 0:y.message),f(y)}).then(u)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(Fe.created,l),h(p)}catch{}}),a=await jt(c,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!a&&n)throw new Error(`Subscribing to ${e} failed, please try again`);return a?o:null}catch(o){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(we.connection_stalled),n)throw o}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:hs(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await jt(new Promise(s=>{this.relayer.request(i).catch(r=>this.logger.warn(r)).then(s)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(we.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,i={method:hs(t.protocol).batchFetchMessages,params:{topics:e.map(r=>r.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});let s;try{s=await await jt(new Promise((r,n)=>{this.relayer.request(i).catch(o=>{this.logger.warn(o),n(o)}).then(r)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(we.connection_stalled)}return s}rpcUnsubscribe(e,t,i){const s={method:hs(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,Zr(ns({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,ns({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,ns({},t)),this.topicMap.set(t.topic,e),this.events.emit(Fe.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=j("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(Fe.deleted,Zr(ns({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(Fe.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let i=0;i<t;i++){const s=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(s)}}this.events.emit(Fe.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=j("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>Zr(ns({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await ip((0,z.toMiliseconds)(z.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return wt(e+await this.getClientId())}},Xw=Object.defineProperty,Da=Object.getOwnPropertySymbols,e$=Object.prototype.hasOwnProperty,t$=Object.prototype.propertyIsEnumerable,Rn=(e,t,i)=>t in e?Xw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ka=(e,t)=>{for(var i in t||(t={}))e$.call(t,i)&&Rn(e,i,t[i]);if(Da)for(var i of Da(t))t$.call(t,i)&&Rn(e,i,t[i]);return e},Q=(e,t,i)=>Rn(e,typeof t!="symbol"?t+"":t,i),i$=class extends $d{constructor(e){super(e),Q(this,"protocol","wc"),Q(this,"version",2),Q(this,"core"),Q(this,"logger"),Q(this,"events",new oi.EventEmitter),Q(this,"provider"),Q(this,"messages"),Q(this,"subscriber"),Q(this,"publisher"),Q(this,"name",Ry),Q(this,"transportExplicitlyClosed",!1),Q(this,"initialized",!1),Q(this,"connectionAttemptInProgress",!1),Q(this,"relayUrl"),Q(this,"projectId"),Q(this,"packageName"),Q(this,"bundleId"),Q(this,"hasExperiencedNetworkDisruption",!1),Q(this,"pingTimeout"),Q(this,"heartBeatTimeout",(0,z.toMiliseconds)(z.THIRTY_SECONDS+z.FIVE_SECONDS)),Q(this,"reconnectTimeout"),Q(this,"connectPromise"),Q(this,"reconnectInProgress",!1),Q(this,"requestsInFlight",[]),Q(this,"connectTimeout",(0,z.toMiliseconds)(z.ONE_SECOND*15)),Q(this,"request",async t=>{var i,s;this.logger.debug("Publishing Request Payload");const r=t.id||Oi().toString();await this.toEstablishConnection();try{this.logger.trace({id:r,method:t.method,topic:(i=t.params)==null?void 0:i.topic},"relayer.request - publishing...");const n=`${r}:${((s=t.params)==null?void 0:s.tag)||""}`;this.requestsInFlight.push(n);const o=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(c=>c!==n),o}catch(n){throw this.logger.debug(`Failed to Publish Request: ${r}`),n}}),Q(this,"resetPingTimeout",()=>{er()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,i,s,r;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(r=(s=(i=(t=this.provider)==null?void 0:t.connection)==null?void 0:i.socket)==null?void 0:s.terminate)==null||r.call(s)}catch(n){this.logger.warn(n,n==null?void 0:n.message)}},this.heartBeatTimeout))}),Q(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),Q(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected 🛜"),this.startPingTimeout(),this.events.emit(we.connect)}),Q(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected 🛑"),this.requestsInFlight=[],this.onProviderDisconnect()}),Q(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(we.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),Q(this,"registerProviderListeners",()=>{this.provider.on(Xe.payload,this.onPayloadHandler),this.provider.on(Xe.connect,this.onConnectHandler),this.provider.on(Xe.disconnect,this.onDisconnectHandler),this.provider.on(Xe.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?Te(e.logger,this.name):(0,Mn.default)(lr({level:e.logger||Ny})),this.messages=new kw(this.logger,e.core),this.subscriber=new Qw(this,this.logger),this.publisher=new Hw(this,this.logger),this.relayUrl=(e==null?void 0:e.relayUrl)||Rh,this.projectId=e.projectId,Bd()?this.packageName=Uo():Md()&&(this.bundleId=Uo()),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.hasAnyTopics)try{await this.transportOpen()}catch(e){this.logger.warn(e,e==null?void 0:e.message)}}get context(){return Qe(this.logger)}get connected(){var e,t,i;return((i=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:i.readyState)===1||!1}get connecting(){var e,t,i;return((i=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:i.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:ae.relay},Js.outbound)}async subscribe(e,t){var i,s,r;this.isInitialized(),(!(t!=null&&t.transportType)||(t==null?void 0:t.transportType)==="relay")&&await this.toEstablishConnection();const n=typeof((i=t==null?void 0:t.internal)==null?void 0:i.throwOnFailedPublish)>"u"?!0:(s=t==null?void 0:t.internal)==null?void 0:s.throwOnFailedPublish;let o=((r=this.subscriber.topicMap.get(e))==null?void 0:r[0])||"",c;const a=h=>{h.topic===e&&(this.subscriber.off(Fe.created,a),c())};return await Promise.all([new Promise(h=>{c=h,this.subscriber.on(Fe.created,a)}),new Promise(async(h,l)=>{o=await this.subscriber.subscribe(e,ka({internal:{throwOnFailedPublish:n}},t)).catch(p=>{n&&l(p)})||o,h()})]),o}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await jt(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,i)=>{await this.connect(e).then(t).catch(i).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await Ia())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if((e==null?void 0:e.length)===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((i,s)=>i.publishedAt-s.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const i of t)try{await this.onMessageEvent(i)}catch(s){this.logger.warn(s,"Error while processing batch message event: "+(s==null?void 0:s.message))}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:i}=e;if(!t.sessionExists){const s=pe(z.FIVE_MINUTES),r={topic:i,expiry:s,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(i,r)}this.events.emit(we.message,e),await this.recordMessageEvent(e,Js.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(i,s)=>{const r=()=>{s(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(Xe.disconnect,r),await jt(new Promise((n,o)=>{this.provider.connect().then(n).catch(o)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(n=>{s(n)}).finally(()=>{this.provider.off(Xe.disconnect,r),clearTimeout(this.reconnectTimeout)}),await new Promise(async(n,o)=>{const c=()=>{o(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(Xe.disconnect,c),await this.subscriber.start().then(n).catch(o).finally(()=>{this.provider.off(Xe.disconnect,c)})}),this.hasExperiencedNetworkDisruption=!1,i()})}catch(i){await this.subscriber.stop();const s=i;this.logger.warn({},s.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(i=>setTimeout(i,(0,z.toMiliseconds)(t*1))),t++}}startPingTimeout(){var e,t,i,s,r;if(er())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((r=(s=(i=this.provider)==null?void 0:i.connection)==null?void 0:s.socket)==null||r.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(n){this.logger.warn(n,n==null?void 0:n.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new st(new vl(Fd({sdkVersion:Pn,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:i,message:s}=e;await this.messages.set(i,s,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||i.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.warn(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),zn(e)){if(!e.method.endsWith(Cy))return;const t=e.params,{topic:i,message:s,publishedAt:r,attestation:n}=t.data,o={topic:i,message:s,publishedAt:r,transportType:ae.relay,attestation:n};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(ka({type:"event",event:t.id},o)),this.events.emit(t.id,o),await this.acknowledgePayload(e),await this.onMessageEvent(o)}else Hn(e)&&this.events.emit(we.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,Js.inbound),this.events.emit(we.message,e))}async acknowledgePayload(e){const t=hr(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(Xe.payload,this.onPayloadHandler),this.provider.off(Xe.connect,this.onConnectHandler),this.provider.off(Xe.disconnect,this.onDisconnectHandler),this.provider.off(Xe.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await Ia();yy(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(i=>this.logger.error(i,i==null?void 0:i.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}),this.core.heartbeat.on(Gi.pulse,async()=>{if(!this.transportExplicitlyClosed&&!this.connected&&$y())try{await this.confirmOnlineStateOrThrow(),await this.transportOpen()}catch(t){this.logger.warn(t,t==null?void 0:t.message)}})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(we.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e==null?void 0:e.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},(0,z.toMiliseconds)(Ty)))))}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectPromise){await this.connectPromise;return}await this.connect()}}};function s$(){}function ja(e){if(!e||typeof e!="object")return!1;const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype||Object.getPrototypeOf(t)===null?Object.prototype.toString.call(e)==="[object Object]":!1}function La(e){return Object.getOwnPropertySymbols(e).filter(t=>Object.prototype.propertyIsEnumerable.call(e,t))}function Ba(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const r$="[object RegExp]",n$="[object String]",o$="[object Number]",a$="[object Boolean]",Ma="[object Arguments]",c$="[object Symbol]",h$="[object Date]",l$="[object Map]",u$="[object Set]",d$="[object Array]",p$="[object Function]",g$="[object ArrayBuffer]",Yr="[object Object]",f$="[object Error]",y$="[object DataView]",m$="[object Uint8Array]",w$="[object Uint8ClampedArray]",$$="[object Uint16Array]",v$="[object Uint32Array]",b$="[object BigUint64Array]",E$="[object Int8Array]",I$="[object Int16Array]",_$="[object Int32Array]",P$="[object BigInt64Array]",S$="[object Float32Array]",O$="[object Float64Array]";function A$(e,t){return e===t||Number.isNaN(e)&&Number.isNaN(t)}function x$(e,t,i){return ls(e,t,void 0,void 0,void 0,void 0,i)}function ls(e,t,i,s,r,n,o){const c=o(e,t,i,s,r,n);if(c!==void 0)return c;if(typeof e==typeof t)switch(typeof e){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return e===t;case"number":return e===t||Object.is(e,t);case"function":return e===t;case"object":return fs(e,t,n,o)}return fs(e,t,n,o)}function fs(e,t,i,s){if(Object.is(e,t))return!0;let r=Ba(e),n=Ba(t);if(r===Ma&&(r=Yr),n===Ma&&(n=Yr),r!==n)return!1;switch(r){case n$:return e.toString()===t.toString();case o$:{const a=e.valueOf(),h=t.valueOf();return A$(a,h)}case a$:case h$:case c$:return Object.is(e.valueOf(),t.valueOf());case r$:return e.source===t.source&&e.flags===t.flags;case p$:return e===t}i=i??new Map;const o=i.get(e),c=i.get(t);if(o!=null&&c!=null)return o===t;i.set(e,t),i.set(t,e);try{switch(r){case l$:{if(e.size!==t.size)return!1;for(const[a,h]of e.entries())if(!t.has(a)||!ls(h,t.get(a),a,e,t,i,s))return!1;return!0}case u$:{if(e.size!==t.size)return!1;const a=Array.from(e.values()),h=Array.from(t.values());for(let l=0;l<a.length;l++){const p=a[l],u=h.findIndex(f=>ls(p,f,void 0,e,t,i,s));if(u===-1)return!1;h.splice(u,1)}return!0}case d$:case m$:case w$:case $$:case v$:case b$:case E$:case I$:case _$:case P$:case S$:case O$:{if(typeof Ae<"u"&&Ae.isBuffer(e)!==Ae.isBuffer(t)||e.length!==t.length)return!1;for(let a=0;a<e.length;a++)if(!ls(e[a],t[a],a,e,t,i,s))return!1;return!0}case g$:return e.byteLength!==t.byteLength?!1:fs(new Uint8Array(e),new Uint8Array(t),i,s);case y$:return e.byteLength!==t.byteLength||e.byteOffset!==t.byteOffset?!1:fs(new Uint8Array(e),new Uint8Array(t),i,s);case f$:return e.name===t.name&&e.message===t.message;case Yr:{if(!(fs(e.constructor,t.constructor,i,s)||ja(e)&&ja(t)))return!1;const a=[...Object.keys(e),...La(e)],h=[...Object.keys(t),...La(t)];if(a.length!==h.length)return!1;for(let l=0;l<a.length;l++){const p=a[l],u=e[p];if(!Object.hasOwn(t,p))return!1;const f=t[p];if(!ls(u,f,p,e,t,i,s))return!1}return!0}default:return!1}}finally{i.delete(e),i.delete(t)}}function N$(e,t){return x$(e,t,s$)}var R$=Object.defineProperty,za=Object.getOwnPropertySymbols,C$=Object.prototype.hasOwnProperty,T$=Object.prototype.propertyIsEnumerable,Cn=(e,t,i)=>t in e?R$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ha=(e,t)=>{for(var i in t||(t={}))C$.call(t,i)&&Cn(e,i,t[i]);if(za)for(var i of za(t))T$.call(t,i)&&Cn(e,i,t[i]);return e},Ue=(e,t,i)=>Cn(e,typeof t!="symbol"?t+"":t,i),ai=class extends vd{constructor(e,t,i,s=$t,r=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,Ue(this,"map",new Map),Ue(this,"version",qy),Ue(this,"cached",[]),Ue(this,"initialized",!1),Ue(this,"getKey"),Ue(this,"storagePrefix",$t),Ue(this,"recentlyDeleted",[]),Ue(this,"recentlyDeletedLimit",200),Ue(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(n=>{this.getKey&&n!==null&&!Pe(n)?this.map.set(this.getKey(n),n):Gf(n)?this.map.set(n.id,n):Wf(n)&&this.map.set(n.topic,n)}),this.cached=[],this.initialized=!0)}),Ue(this,"set",async(n,o)=>{this.isInitialized(),this.map.has(n)?await this.update(n,o):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:n,value:o}),this.map.set(n,o),await this.persist())}),Ue(this,"get",n=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:n}),this.getData(n))),Ue(this,"getAll",n=>(this.isInitialized(),n?this.values.filter(o=>Object.keys(n).every(c=>N$(o[c],n[c]))):this.values)),Ue(this,"update",async(n,o)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:n,update:o});const c=Ha(Ha({},this.getData(n)),o);this.map.set(n,c),await this.persist()}),Ue(this,"delete",async(n,o)=>{this.isInitialized(),this.map.has(n)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:n,reason:o}),this.map.delete(n),this.addToRecentlyDeleted(n),await this.persist())}),this.logger=Te(t,this.name),this.storagePrefix=s,this.getKey=r}get context(){return Qe(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:s}=j("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}const{message:i}=j("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=j("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}},q$=Object.defineProperty,U$=(e,t,i)=>t in e?q$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,W=(e,t,i)=>U$(e,typeof t!="symbol"?t+"":t,i),D$=class{constructor(e,t){this.core=e,this.logger=t,W(this,"name",jy),W(this,"version",Ly),W(this,"events",new oi.default),W(this,"pairings"),W(this,"initialized",!1),W(this,"storagePrefix",$t),W(this,"ignoredPayloadTypes",[Nt]),W(this,"registeredMethods",[]),W(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),W(this,"register",({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]}),W(this,"create",async i=>{this.isInitialized();const s=_n(),r=await this.core.crypto.setSymKey(s),n=pe(z.FIVE_MINUTES),o={protocol:Nh},c={topic:r,expiry:n,relay:o,active:!1,methods:i==null?void 0:i.methods},a=ga({protocol:this.core.protocol,version:this.core.version,topic:r,symKey:s,relay:o,expiryTimestamp:n,methods:i==null?void 0:i.methods});return this.events.emit(Zt.create,c),this.core.expirer.set(r,n),await this.pairings.set(r,c),await this.core.relayer.subscribe(r,{transportType:i==null?void 0:i.transportType}),{topic:r,uri:a}}),W(this,"pair",async i=>{this.isInitialized();const s=this.core.eventClient.createEvent({properties:{topic:i==null?void 0:i.uri,trace:[yt.pairing_started]}});this.isValidPair(i,s);const{topic:r,symKey:n,relay:o,expiryTimestamp:c,methods:a}=pa(i.uri);s.props.properties.topic=r,s.addTrace(yt.pairing_uri_validation_success),s.addTrace(yt.pairing_uri_not_expired);let h;if(this.pairings.keys.includes(r)){if(h=this.pairings.get(r),s.addTrace(yt.existing_pairing),h.active)throw s.setError(It.active_pairing_already_exists),new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);s.addTrace(yt.pairing_not_expired)}const l=c||pe(z.FIVE_MINUTES),p={topic:r,relay:o,expiry:l,active:!1,methods:a};this.core.expirer.set(r,l),await this.pairings.set(r,p),s.addTrace(yt.store_new_pairing),i.activatePairing&&await this.activate({topic:r}),this.events.emit(Zt.create,p),s.addTrace(yt.emit_inactive_pairing),this.core.crypto.keychain.has(r)||await this.core.crypto.setSymKey(n,r),s.addTrace(yt.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{s.setError(It.no_internet_connection)}try{await this.core.relayer.subscribe(r,{relay:o})}catch(u){throw s.setError(It.subscribe_pairing_topic_failure),u}return s.addTrace(yt.subscribe_pairing_topic_success),p}),W(this,"activate",async({topic:i})=>{this.isInitialized();const s=pe(z.FIVE_MINUTES);this.core.expirer.set(i,s),await this.pairings.update(i,{active:!0,expiry:s})}),W(this,"ping",async i=>{this.isInitialized(),await this.isValidPing(i),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:s}=i;if(this.pairings.keys.includes(s)){const r=await this.sendRequest(s,"wc_pairingPing",{}),{done:n,resolve:o,reject:c}=Kt();this.events.once(te("pairing_ping",r),({error:a})=>{a?c(a):o()}),await n()}}),W(this,"updateExpiry",async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})}),W(this,"updateMetadata",async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})}),W(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),W(this,"disconnect",async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",oe("USER_DISCONNECTED")),await this.deletePairing(s))}),W(this,"formatUriFromPairing",i=>{this.isInitialized();const{topic:s,relay:r,expiry:n,methods:o}=i,c=this.core.crypto.keychain.get(s);return ga({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:c,relay:r,expiryTimestamp:n,methods:o})}),W(this,"sendRequest",async(i,s,r)=>{const n=Jt(s,r),o=await this.core.crypto.encode(i,n),c=ss[s].req;return this.core.history.set(i,n),this.core.relayer.publish(i,o,c),n.id}),W(this,"sendResult",async(i,s,r)=>{const n=hr(i,r),o=await this.core.crypto.encode(s,n),c=(await this.core.history.get(s,i)).request.method,a=ss[c].res;await this.core.relayer.publish(s,o,a),await this.core.history.resolve(n)}),W(this,"sendError",async(i,s,r)=>{const n=fc(i,r),o=await this.core.crypto.encode(s,n),c=(await this.core.history.get(s,i)).request.method,a=ss[c]?ss[c].res:ss.unregistered_method.res;await this.core.relayer.publish(s,o,a),await this.core.history.resolve(n)}),W(this,"deletePairing",async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,oe("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])}),W(this,"cleanup",async()=>{const i=this.pairings.getAll().filter(s=>Dt(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))}),W(this,"onRelayEventRequest",async i=>{const{topic:s,payload:r}=i;switch(r.method){case"wc_pairingPing":return await this.onPairingPingRequest(s,r);case"wc_pairingDelete":return await this.onPairingDeleteRequest(s,r);default:return await this.onUnknownRpcMethodRequest(s,r)}}),W(this,"onRelayEventResponse",async i=>{const{topic:s,payload:r}=i,n=(await this.core.history.get(s,r.id)).request.method;switch(n){case"wc_pairingPing":return this.onPairingPingResponse(s,r);default:return this.onUnknownRpcMethodResponse(n)}}),W(this,"onPairingPingRequest",async(i,s)=>{const{id:r}=s;try{this.isValidPing({topic:i}),await this.sendResult(r,i,!0),this.events.emit(Zt.ping,{id:r,topic:i})}catch(n){await this.sendError(r,i,n),this.logger.error(n)}}),W(this,"onPairingPingResponse",(i,s)=>{const{id:r}=s;setTimeout(()=>{Et(s)?this.events.emit(te("pairing_ping",r),{}):mt(s)&&this.events.emit(te("pairing_ping",r),{error:s.error})},500)}),W(this,"onPairingDeleteRequest",async(i,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit(Zt.delete,{id:r,topic:i})}catch(n){await this.sendError(r,i,n),this.logger.error(n)}}),W(this,"onUnknownRpcMethodRequest",async(i,s)=>{const{id:r,method:n}=s;try{if(this.registeredMethods.includes(n))return;const o=oe("WC_METHOD_UNSUPPORTED",n);await this.sendError(r,i,o),this.logger.error(o)}catch(o){await this.sendError(r,i,o),this.logger.error(o)}}),W(this,"onUnknownRpcMethodResponse",i=>{this.registeredMethods.includes(i)||this.logger.error(oe("WC_METHOD_UNSUPPORTED",i))}),W(this,"isValidPair",(i,s)=>{var r;if(!De(i)){const{message:o}=j("MISSING_OR_INVALID",`pair() params: ${i}`);throw s.setError(It.malformed_pairing_uri),new Error(o)}if(!Ff(i.uri)){const{message:o}=j("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw s.setError(It.malformed_pairing_uri),new Error(o)}const n=pa(i==null?void 0:i.uri);if(!((r=n==null?void 0:n.relay)!=null&&r.protocol)){const{message:o}=j("MISSING_OR_INVALID","pair() uri#relay-protocol");throw s.setError(It.malformed_pairing_uri),new Error(o)}if(!(n!=null&&n.symKey)){const{message:o}=j("MISSING_OR_INVALID","pair() uri#symKey");throw s.setError(It.malformed_pairing_uri),new Error(o)}if(n!=null&&n.expiryTimestamp&&(0,z.toMiliseconds)(n==null?void 0:n.expiryTimestamp)<Date.now()){s.setError(It.pairing_expired);const{message:o}=j("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(o)}}),W(this,"isValidPing",async i=>{if(!De(i)){const{message:r}=j("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s)}),W(this,"isValidDisconnect",async i=>{if(!De(i)){const{message:r}=j("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s)}),W(this,"isValidPairingTopic",async i=>{if(!ue(i,!1)){const{message:s}=j("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=j("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(Dt(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=j("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}}),this.core=e,this.logger=Te(t,this.name),this.pairings=new ai(this.core,this.logger,this.name,this.storagePrefix)}get context(){return Qe(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(we.message,async e=>{const{topic:t,message:i,transportType:s}=e;if(this.pairings.keys.includes(t)&&s!==ae.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))try{const r=await this.core.crypto.decode(t,i);zn(r)?(this.core.history.set(t,r),await this.onRelayEventRequest({topic:t,payload:r})):Hn(r)&&(await this.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.core.history.delete(t,r.id)),await this.core.relayer.messages.ack(t,i)}catch(r){this.logger.error(r)}})}registerExpirerEvents(){this.core.expirer.on(tt.expired,async e=>{const{topic:t}=Kc(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(Zt.expire,{topic:t}))})}},k$=Object.defineProperty,j$=(e,t,i)=>t in e?k$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,_e=(e,t,i)=>j$(e,typeof t!="symbol"?t+"":t,i),L$=class extends yd{constructor(e,t){super(e,t),this.core=e,this.logger=t,_e(this,"records",new Map),_e(this,"events",new oi.EventEmitter),_e(this,"name",By),_e(this,"version",My),_e(this,"cached",[]),_e(this,"initialized",!1),_e(this,"storagePrefix",$t),_e(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),_e(this,"set",(i,s,r)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:r}),this.records.has(s.id))return;const n={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:r,expiry:pe(z.THIRTY_DAYS)};this.records.set(n.id,n),this.persist(),this.events.emit(nt.created,n)}),_e(this,"resolve",async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=mt(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.persist(),this.events.emit(nt.updated,s))}),_e(this,"get",async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s))),_e(this,"delete",(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(r=>{if(r.topic===i){if(typeof s<"u"&&r.id!==s)return;this.records.delete(r.id),this.events.emit(nt.deleted,r)}}),this.persist()}),_e(this,"exists",async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1)),_e(this,"on",(i,s)=>{this.events.on(i,s)}),_e(this,"once",(i,s)=>{this.events.once(i,s)}),_e(this,"off",(i,s)=>{this.events.off(i,s)}),_e(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.logger=Te(t,this.name)}get context(){return Qe(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:Jt(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=j("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(nt.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=j("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(nt.created,e=>{const t=nt.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(nt.updated,e=>{const t=nt.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(nt.deleted,e=>{const t=nt.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(Gi.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{(0,z.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(nt.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}},B$=Object.defineProperty,M$=(e,t,i)=>t in e?B$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Oe=(e,t,i)=>M$(e,typeof t!="symbol"?t+"":t,i),z$=class extends Ed{constructor(e,t){super(e,t),this.core=e,this.logger=t,Oe(this,"expirations",new Map),Oe(this,"events",new oi.EventEmitter),Oe(this,"name",zy),Oe(this,"version",Hy),Oe(this,"cached",[]),Oe(this,"initialized",!1),Oe(this,"storagePrefix",$t),Oe(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),Oe(this,"has",i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}}),Oe(this,"set",(i,s)=>{this.isInitialized();const r=this.formatTarget(i),n={target:r,expiry:s};this.expirations.set(r,n),this.checkExpiry(r,n),this.events.emit(tt.created,{target:r,expiration:n})}),Oe(this,"get",i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)}),Oe(this,"del",i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),r=this.getExpiration(s);this.expirations.delete(s),this.events.emit(tt.deleted,{target:s,expiration:r})}}),Oe(this,"on",(i,s)=>{this.events.on(i,s)}),Oe(this,"once",(i,s)=>{this.events.once(i,s)}),Oe(this,"off",(i,s)=>{this.events.off(i,s)}),Oe(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.logger=Te(t,this.name)}get context(){return Qe(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return Gd(e);if(typeof e=="number")return Wd(e);const{message:t}=j("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(tt.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=j("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=j("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;(0,z.toMiliseconds)(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(tt.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(Gi.pulse,()=>this.checkExpirations()),this.events.on(tt.created,e=>{const t=tt.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(tt.expired,e=>{const t=tt.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(tt.deleted,e=>{const t=tt.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}},H$=Object.defineProperty,V$=(e,t,i)=>t in e?H$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,le=(e,t,i)=>V$(e,typeof t!="symbol"?t+"":t,i),K$=class extends Id{constructor(e,t,i){super(e,t,i),this.core=e,this.logger=t,this.store=i,le(this,"name",Vy),le(this,"abortController"),le(this,"isDevEnv"),le(this,"verifyUrlV3",Fy),le(this,"storagePrefix",$t),le(this,"version",xh),le(this,"publicKey"),le(this,"fetchPromise"),le(this,"init",async()=>{var s;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,z.toMiliseconds)((s=this.publicKey)==null?void 0:s.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),le(this,"register",async s=>{if(!Zi()||this.isDevEnv)return;const r=window.location.origin,{id:n,decryptedId:o}=s,c=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r}&id=${n}&decryptedId=${o}`;try{const a=(0,vy.getDocument)(),h=this.startAbortTimer(z.ONE_SECOND*5),l=await new Promise((p,u)=>{const f=()=>{window.removeEventListener("message",m),a.body.removeChild(y),u("attestation aborted")};this.abortController.signal.addEventListener("abort",f);const y=a.createElement("iframe");y.src=c,y.style.display="none",y.addEventListener("error",f,{signal:this.abortController.signal});const m=d=>{if(d.data&&typeof d.data=="string")try{const g=JSON.parse(d.data);if(g.type==="verify_attestation"){if(rn(g.attestation).payload.id!==n)return;clearInterval(h),a.body.removeChild(y),this.abortController.signal.removeEventListener("abort",f),window.removeEventListener("message",m),p(g.attestation===null?"":g.attestation)}}catch(g){this.logger.warn(g)}};a.body.appendChild(y),window.addEventListener("message",m,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",l),l}catch(a){this.logger.warn(a)}return""}),le(this,"resolve",async s=>{if(this.isDevEnv)return"";const{attestationId:r,hash:n,encryptedId:o}=s;if(r===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(r){if(rn(r).payload.id!==o)return;const a=await this.isValidJwtAttestation(r);if(a){if(!a.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return a}}if(!n)return;const c=this.getVerifyUrl(s==null?void 0:s.verifyUrl);return this.fetchAttestation(n,c)}),le(this,"fetchAttestation",async(s,r)=>{this.logger.debug(`resolving attestation: ${s} from url: ${r}`);const n=this.startAbortTimer(z.ONE_SECOND*5),o=await fetch(`${r}/attestation/${s}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(n),o.status===200?await o.json():void 0}),le(this,"getVerifyUrl",s=>{let r=s||gs;return Gy.includes(r)||(this.logger.info(`verify url: ${r}, not included in trusted list, assigning default: ${gs}`),r=gs),r}),le(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const s=this.startAbortTimer(z.FIVE_SECONDS),r=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(s),await r.json()}catch(s){this.logger.warn(s)}}),le(this,"persistPublicKey",async s=>{this.logger.debug("persisting public key to local storage",s),await this.store.setItem(this.storeKey,s),this.publicKey=s}),le(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),le(this,"isValidJwtAttestation",async s=>{const r=await this.getPublicKey();try{if(r)return this.validateAttestation(s,r)}catch(o){this.logger.error(o),this.logger.warn("error validating attestation")}const n=await this.fetchAndPersistPublicKey();try{if(n)return this.validateAttestation(s,n)}catch(o){this.logger.error(o),this.logger.warn("error validating attestation")}}),le(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),le(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async r=>{const n=await this.fetchPublicKey();n&&(await this.persistPublicKey(n),r(n))});const s=await this.fetchPromise;return this.fetchPromise=void 0,s}),le(this,"validateAttestation",(s,r)=>{const n=_f(s,r.publicKey),o={hasExpired:(0,z.toMiliseconds)(n.exp)<Date.now(),payload:n};if(o.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:o.payload.origin,isScam:o.payload.isScam,isVerified:o.payload.isVerified}}),this.logger=Te(t,this.name),this.abortController=new AbortController,this.isDevEnv=Zn(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return Qe(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),(0,z.toMiliseconds)(e))}},F$=Object.defineProperty,G$=(e,t,i)=>t in e?F$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Va=(e,t,i)=>G$(e,typeof t!="symbol"?t+"":t,i),W$=class extends _d{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,Va(this,"context",Wy),Va(this,"registerDeviceToken",async i=>{const{clientId:s,token:r,notificationType:n,enableEncrypted:o=!1}=i,c=`${Zy}/${this.projectId}/clients`;await fetch(c,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:s,type:n,token:r,always_raw:o})})}),this.logger=Te(t,this.context)}},Z$=Object.defineProperty,Ka=Object.getOwnPropertySymbols,Y$=Object.prototype.hasOwnProperty,J$=Object.prototype.propertyIsEnumerable,Tn=(e,t,i)=>t in e?Z$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,os=(e,t)=>{for(var i in t||(t={}))Y$.call(t,i)&&Tn(e,i,t[i]);if(Ka)for(var i of Ka(t))J$.call(t,i)&&Tn(e,i,t[i]);return e},ge=(e,t,i)=>Tn(e,typeof t!="symbol"?t+"":t,i),Q$=class extends Pd{constructor(e,t,i=!0){super(e,t,i),this.core=e,this.logger=t,ge(this,"context",Jy),ge(this,"storagePrefix",$t),ge(this,"storageVersion",Yy),ge(this,"events",new Map),ge(this,"shouldPersist",!1),ge(this,"init",async()=>{if(!Zn())try{const s={eventId:ko(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:Hc(this.core.relayer.protocol,this.core.relayer.version,Pn)}}};await this.sendEvent([s])}catch(s){this.logger.warn(s)}}),ge(this,"createEvent",s=>{const{event:r="ERROR",type:n="",properties:{topic:o,trace:c}}=s,a=ko(),h=this.core.projectId||"",l=Date.now(),p=os({eventId:a,timestamp:l,props:{event:r,type:n,properties:{topic:o,trace:c}},bundleId:h,domain:this.getAppDomain()},this.setMethods(a));return this.telemetryEnabled&&(this.events.set(a,p),this.shouldPersist=!0),p}),ge(this,"getEvent",s=>{const{eventId:r,topic:n}=s;if(r)return this.events.get(r);const o=Array.from(this.events.values()).find(c=>c.props.properties.topic===n);if(o)return os(os({},o),this.setMethods(o.eventId))}),ge(this,"deleteEvent",s=>{const{eventId:r}=s;this.events.delete(r),this.shouldPersist=!0}),ge(this,"setEventListeners",()=>{this.core.heartbeat.on(Gi.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(s=>{(0,z.fromMiliseconds)(Date.now())-(0,z.fromMiliseconds)(s.timestamp)>Qy&&(this.events.delete(s.eventId),this.shouldPersist=!0)})})}),ge(this,"setMethods",s=>({addTrace:r=>this.addTrace(s,r),setError:r=>this.setError(s,r)})),ge(this,"addTrace",(s,r)=>{const n=this.events.get(s);n&&(n.props.properties.trace.push(r),this.events.set(s,n),this.shouldPersist=!0)}),ge(this,"setError",(s,r)=>{const n=this.events.get(s);n&&(n.props.type=r,n.timestamp=Date.now(),this.events.set(s,n),this.shouldPersist=!0)}),ge(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),ge(this,"restore",async()=>{try{const s=await this.core.storage.getItem(this.storageKey)||[];if(!s.length)return;s.forEach(r=>{this.events.set(r.eventId,os(os({},r),this.setMethods(r.eventId)))})}catch(s){this.logger.warn(s)}}),ge(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const s=[];for(const[r,n]of this.events)n.props.type&&s.push(n);if(s.length!==0)try{if((await this.sendEvent(s)).ok)for(const r of s)this.events.delete(r.eventId),this.shouldPersist=!0}catch(r){this.logger.warn(r)}}),ge(this,"sendEvent",async s=>{const r=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${Xy}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Pn}${r}`,{method:"POST",body:JSON.stringify(s)})}),ge(this,"getAppDomain",()=>zc().url),this.logger=Te(t,this.context),this.telemetryEnabled=i,i?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}},X$=Object.defineProperty,Fa=Object.getOwnPropertySymbols,ev=Object.prototype.hasOwnProperty,tv=Object.prototype.propertyIsEnumerable,qn=(e,t,i)=>t in e?X$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ga=(e,t)=>{for(var i in t||(t={}))ev.call(t,i)&&qn(e,i,t[i]);if(Fa)for(var i of Fa(t))tv.call(t,i)&&qn(e,i,t[i]);return e},ne=(e,t,i)=>qn(e,typeof t!="symbol"?t+"":t,i),iv=class Hh extends dd{constructor(t){var i;super(t),ne(this,"protocol",Ah),ne(this,"version",xh),ne(this,"name",rr),ne(this,"relayUrl"),ne(this,"projectId"),ne(this,"customStoragePrefix"),ne(this,"events",new oi.EventEmitter),ne(this,"logger"),ne(this,"heartbeat"),ne(this,"relayer"),ne(this,"crypto"),ne(this,"storage"),ne(this,"history"),ne(this,"expirer"),ne(this,"pairing"),ne(this,"verify"),ne(this,"echoClient"),ne(this,"linkModeSupportedApps"),ne(this,"eventClient"),ne(this,"initialized",!1),ne(this,"logChunkController"),ne(this,"on",(c,a)=>this.events.on(c,a)),ne(this,"once",(c,a)=>this.events.once(c,a)),ne(this,"off",(c,a)=>this.events.off(c,a)),ne(this,"removeListener",(c,a)=>this.events.removeListener(c,a)),ne(this,"dispatchEnvelope",({topic:c,message:a,sessionExists:h})=>{if(!c||!a)return;const l={topic:c,message:a,publishedAt:Date.now(),transportType:ae.link_mode};this.relayer.onLinkMessageEvent(l,{sessionExists:h})});const s=this.getGlobalCore(t==null?void 0:t.customStoragePrefix);if(s)try{return this.customStoragePrefix=s.customStoragePrefix,this.logger=s.logger,this.heartbeat=s.heartbeat,this.crypto=s.crypto,this.history=s.history,this.expirer=s.expirer,this.storage=s.storage,this.relayer=s.relayer,this.pairing=s.pairing,this.verify=s.verify,this.echoClient=s.echoClient,this.linkModeSupportedApps=s.linkModeSupportedApps,this.eventClient=s.eventClient,this.initialized=s.initialized,this.logChunkController=s.logChunkController,s}catch(c){console.warn("Failed to copy global core",c)}this.projectId=t==null?void 0:t.projectId,this.relayUrl=(t==null?void 0:t.relayUrl)||Rh,this.customStoragePrefix=t!=null&&t.customStoragePrefix?`:${t.customStoragePrefix}`:"";const r=lr({level:typeof(t==null?void 0:t.logger)=="string"&&t.logger?t.logger:by.logger,name:rr}),{logger:n,chunkLoggerController:o}=fl({opts:r,maxSizeInBytes:t==null?void 0:t.maxLogBlobSizeInBytes,loggerOverride:t==null?void 0:t.logger});this.logChunkController=o,(i=this.logChunkController)!=null&&i.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var c,a;(c=this.logChunkController)!=null&&c.downloadLogsBlobInBrowser&&((a=this.logChunkController)==null||a.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=Te(n,this.name),this.heartbeat=new El,this.crypto=new xw(this,this.logger,t==null?void 0:t.keychain),this.history=new L$(this,this.logger),this.expirer=new z$(this,this.logger),this.storage=t!=null&&t.storage?t.storage:new bl(Ga(Ga({},Ey),t==null?void 0:t.storageOptions)),this.relayer=new i$({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new D$(this,this.logger),this.verify=new K$(this,this.logger,this.storage),this.echoClient=new W$(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new Q$(this,this.logger,t==null?void 0:t.telemetryEnabled),this.setGlobalCore(this)}static async init(t){const i=new Hh(t);await i.initialize();const s=await i.crypto.getClientId();return await i.storage.setItem(Uy,s),i}get context(){return Qe(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var t;return(t=this.logChunkController)==null?void 0:t.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(t){this.linkModeSupportedApps.includes(t)||(this.linkModeSupportedApps.push(t),await this.storage.setItem(Sa,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(Sa)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(t){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,t),this.logger.error(t.message),t}}getGlobalCore(t=""){try{if(this.isGlobalCoreDisabled())return;const i=`_walletConnectCore_${t}`,s=`${i}_count`;return globalThis[s]=(globalThis[s]||0)+1,globalThis[s]>1&&console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[s]} times.`),globalThis[i]}catch(i){console.warn("Failed to get global WalletConnect core",i);return}}setGlobalCore(t){var i;try{if(this.isGlobalCoreDisabled())return;const s=`_walletConnectCore_${((i=t.opts)==null?void 0:i.customStoragePrefix)||""}`;globalThis[s]=t}catch(s){console.warn("Failed to set global WalletConnect core",s)}}isGlobalCoreDisabled(){try{return typeof us<"u"&&{}.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}};const sv=iv;gc();var X=Me(ur()),Vh=Me(_s());const Kh="wc",Fh=2,Gh="client",so=`${Kh}@${Fh}:${Gh}:`,Jr={name:Gh,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"};const Wa="WALLETCONNECT_DEEPLINK_CHOICE";const rv="proposal",Xb=X.THIRTY_DAYS,Za="Proposal expired",nv="session",gi=X.SEVEN_DAYS,ov="engine",fe={wc_sessionPropose:{req:{ttl:X.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:X.ONE_DAY,prompt:!1,tag:1104},res:{ttl:X.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:X.ONE_DAY,prompt:!1,tag:1106},res:{ttl:X.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:X.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:X.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:X.ONE_DAY,prompt:!1,tag:1112},res:{ttl:X.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:X.ONE_DAY,prompt:!1,tag:1114},res:{ttl:X.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:X.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:X.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:X.FIVE_MINUTES,prompt:!1,tag:1119}}},Qr={min:X.FIVE_MINUTES,max:X.SEVEN_DAYS},ft={idle:"IDLE",active:"ACTIVE"},Ya={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},av="request",cv=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],hv="wc";const lv="auth",uv="authKeys",dv="pairingTopics",pv="requests",Ir=`${hv}@1.5:${lv}:`,Qs=`${Ir}:PUB_KEY`;var gv=Object.defineProperty,fv=Object.defineProperties,yv=Object.getOwnPropertyDescriptors,Ja=Object.getOwnPropertySymbols,mv=Object.prototype.hasOwnProperty,wv=Object.prototype.propertyIsEnumerable,Un=(e,t,i)=>t in e?gv(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,re=(e,t)=>{for(var i in t||(t={}))mv.call(t,i)&&Un(e,i,t[i]);if(Ja)for(var i of Ja(t))wv.call(t,i)&&Un(e,i,t[i]);return e},Re=(e,t)=>fv(e,yv(t)),U=(e,t,i)=>Un(e,typeof t!="symbol"?t+"":t,i),$v=class extends xd{constructor(e){super(e),U(this,"name",ov),U(this,"events",new Vh.default),U(this,"initialized",!1),U(this,"requestQueue",{state:ft.idle,queue:[]}),U(this,"sessionRequestQueue",{state:ft.idle,queue:[]}),U(this,"requestQueueDelay",X.ONE_SECOND),U(this,"expectedPairingMethodMap",new Map),U(this,"recentlyDeletedMap",new Map),U(this,"recentlyDeletedLimit",200),U(this,"relayMessageCache",[]),U(this,"pendingSessions",new Map),U(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(fe)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,X.toMiliseconds)(this.requestQueueDelay)))}),U(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const i=Re(re({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(i),i.optionalNamespaces=Mf(i.requiredNamespaces,i.optionalNamespaces),i.requiredNamespaces={};const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:o,scopedProperties:c,relays:a}=i;let h=s,l,p=!1;try{if(h){const T=this.client.core.pairing.pairings.get(h);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),p=T.active}}catch(T){throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`),T}if(!h||!p){const{topic:T,uri:A}=await this.client.core.pairing.create();h=T,l=A}if(!h){const{message:T}=j("NO_MATCHING_KEY",`connect() pairing topic: ${h}`);throw new Error(T)}const u=await this.client.core.crypto.generateKeyPair(),f=fe.wc_sessionPropose.req.ttl||X.FIVE_MINUTES,y=pe(f),m=Re(re(re({requiredNamespaces:r,optionalNamespaces:n,relays:a??[{protocol:Nh}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:y,pairingTopic:h},o&&{sessionProperties:o}),c&&{scopedProperties:c}),{id:Rt()}),d=te("session_connect",m.id),{reject:g,resolve:w,done:_}=Kt(f,Za),O=({id:T})=>{T===m.id&&(this.client.events.off("proposal_expire",O),this.pendingSessions.delete(m.id),this.events.emit(d,{error:{message:Za,code:0}}))};return this.client.events.on("proposal_expire",O),this.events.once(d,({error:T,session:A})=>{this.client.events.off("proposal_expire",O),T?g(T):A&&w(A)}),await this.sendRequest({topic:h,method:"wc_sessionPropose",params:m,throwOnFailedPublish:!0,clientRpcId:m.id}),await this.setProposal(m.id,m),{uri:l,approval:_}}),U(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(i){throw this.client.logger.error("pair() failed"),i}}),U(this,"approve",async t=>{var i,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:(i=t==null?void 0:t.id)==null?void 0:i.toString(),trace:[ot.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(I){throw n.setError(Ht.no_internet_connection),I}try{await this.isValidProposalId(t==null?void 0:t.id)}catch(I){throw this.client.logger.error(`approve() -> proposal.get(${t==null?void 0:t.id}) failed`),n.setError(Ht.proposal_not_found),I}try{await this.isValidApprove(t)}catch(I){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(Ht.session_approve_namespace_validation_failure),I}const{id:o,relayProtocol:c,namespaces:a,sessionProperties:h,scopedProperties:l,sessionConfig:p}=t,u=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:f,proposer:y,requiredNamespaces:m,optionalNamespaces:d}=u;let g=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:f});g||(g=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:ot.session_approve_started,properties:{topic:f,trace:[ot.session_approve_started,ot.session_namespaces_validation_success]}}));const w=await this.client.core.crypto.generateKeyPair(),_=y.publicKey,O=await this.client.core.crypto.generateSharedKey(w,_),T=re(re(re({relay:{protocol:c??"irn"},namespaces:a,controller:{publicKey:w,metadata:this.client.metadata},expiry:pe(gi)},h&&{sessionProperties:h}),l&&{scopedProperties:l}),p&&{sessionConfig:p}),A=ae.relay;g.addTrace(ot.subscribing_session_topic);try{await this.client.core.relayer.subscribe(O,{transportType:A})}catch(I){throw g.setError(Ht.subscribe_session_topic_failure),I}g.addTrace(ot.subscribe_session_topic_success);const S=Re(re({},T),{topic:O,requiredNamespaces:m,optionalNamespaces:d,pairingTopic:f,acknowledged:!1,self:T.controller,peer:{publicKey:y.publicKey,metadata:y.metadata},controller:w,transportType:ae.relay});await this.client.session.set(O,S),g.addTrace(ot.store_session);try{g.addTrace(ot.publishing_session_settle),await this.sendRequest({topic:O,method:"wc_sessionSettle",params:T,throwOnFailedPublish:!0}).catch(I=>{throw g==null||g.setError(Ht.session_settle_publish_failure),I}),g.addTrace(ot.session_settle_publish_success),g.addTrace(ot.publishing_session_approve),await this.sendResult({id:o,topic:f,result:{relay:{protocol:c??"irn"},responderPublicKey:w},throwOnFailedPublish:!0}).catch(I=>{throw g==null||g.setError(Ht.session_approve_publish_failure),I}),g.addTrace(ot.session_approve_publish_success)}catch(I){throw this.client.logger.error(I),this.client.session.delete(O,oe("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(O),I}return this.client.core.eventClient.deleteEvent({eventId:g.eventId}),await this.client.core.pairing.updateMetadata({topic:f,metadata:y.metadata}),await this.client.proposal.delete(o,oe("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:f}),await this.setExpiry(O,pe(gi)),{topic:O,acknowledged:()=>Promise.resolve(this.client.session.get(O))}}),U(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:i,reason:s}=t;let r;try{r=this.client.proposal.get(i).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${i}) failed`),n}r&&(await this.sendError({id:i,topic:r,error:s,rpcOpts:fe.wc_sessionPropose.reject}),await this.client.proposal.delete(i,oe("USER_DISCONNECTED")))}),U(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(l){throw this.client.logger.error("update() -> isValidUpdate() failed"),l}const{topic:i,namespaces:s}=t,{done:r,resolve:n,reject:o}=Kt(),c=Rt(),a=Oi().toString(),h=this.client.session.get(i).namespaces;return this.events.once(te("session_update",c),({error:l})=>{l?o(l):n()}),await this.client.session.update(i,{namespaces:s}),await this.sendRequest({topic:i,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:a}).catch(l=>{this.client.logger.error(l),this.client.session.update(i,{namespaces:h}),o(l)}),{acknowledged:r}}),U(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:i}=t,s=Rt(),{done:r,resolve:n,reject:o}=Kt();return this.events.once(te("session_extend",s),({error:c})=>{c?o(c):n()}),await this.setExpiry(i,pe(gi)),this.sendRequest({topic:i,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{o(c)}),{acknowledged:r}}),U(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(d){throw this.client.logger.error("request() -> isValidRequest() failed"),d}const{chainId:i,request:s,topic:r,expiry:n=fe.wc_sessionRequest.req.ttl}=t,o=this.client.session.get(r);(o==null?void 0:o.transportType)===ae.relay&&await this.confirmOnlineStateOrThrow();const c=Rt(),a=Oi().toString(),{done:h,resolve:l,reject:p}=Kt(n,"Request expired. Please try again.");this.events.once(te("session_request",c),({error:d,result:g})=>{d?p(d):l(g)});const u="wc_sessionRequest",f=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);if(f)return await this.sendRequest({clientRpcId:c,relayRpcId:a,topic:r,method:u,params:{request:Re(re({},s),{expiryTimestamp:pe(n)}),chainId:i},expiry:n,throwOnFailedPublish:!0,appLink:f}).catch(d=>p(d)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:i,id:c}),await h();const y={request:Re(re({},s),{expiryTimestamp:pe(n)}),chainId:i},m=this.shouldSetTVF(u,y);return await Promise.all([new Promise(async d=>{await this.sendRequest(re({clientRpcId:c,relayRpcId:a,topic:r,method:u,params:y,expiry:n,throwOnFailedPublish:!0},m&&{tvf:this.getTVFParams(c,y)})).catch(g=>p(g)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:i,id:c}),d()}),new Promise(async d=>{var g;if(!((g=o.sessionConfig)!=null&&g.disableDeepLink)){const w=await Qd(this.client.core.storage,Wa);await Zd({id:c,topic:r,wcDeepLink:w})}d()}),h()]).then(d=>d[2])}),U(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:i,response:s}=t,{id:r}=s,n=this.client.session.get(i);n.transportType===ae.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);Et(s)?await this.sendResult({id:r,topic:i,result:s.result,throwOnFailedPublish:!0,appLink:o}):mt(s)&&await this.sendError({id:r,topic:i,error:s.error,appLink:o}),this.cleanupAfterResponse(t)}),U(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:i}=t;if(this.client.session.keys.includes(i)){const s=Rt(),r=Oi().toString(),{done:n,resolve:o,reject:c}=Kt();this.events.once(te("session_ping",s),({error:a})=>{a?c(a):o()}),await Promise.all([this.sendRequest({topic:i,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(i)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:i}))}),U(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:i,event:s,chainId:r}=t,n=Oi().toString(),o=Rt();await this.sendRequest({topic:i,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n,clientRpcId:o})}),U(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:i}=t;if(this.client.session.keys.includes(i))await this.sendRequest({topic:i,method:"wc_sessionDelete",params:oe("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:i,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(i))await this.client.core.pairing.disconnect({topic:i});else{const{message:s}=j("MISMATCHED_TOPIC",`Session or pairing topic not found: ${i}`);throw new Error(s)}}),U(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(i=>Vf(i,t)))),U(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),U(this,"authenticate",async(t,i)=>{var s;this.isInitialized(),this.isValidAuthenticate(t);const r=i&&this.client.core.linkModeSupportedApps.includes(i)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),n=r?ae.link_mode:ae.relay;n===ae.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:c="",uri:a,domain:h,nonce:l,type:p,exp:u,nbf:f,methods:y=[],expiry:m}=t,d=[...t.resources||[]],{topic:g,uri:w}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:g,uri:w}});const _=await this.client.core.crypto.generateKeyPair(),O=Ys(_);if(await Promise.all([this.client.auth.authKeys.set(Qs,{responseTopic:O,publicKey:_}),this.client.auth.pairingTopics.set(O,{topic:O,pairingTopic:g})]),await this.client.core.relayer.subscribe(O,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${g}`),y.length>0){const{namespace:v}=Ws(o[0]);let R=Vp(v,"request",y);Zs(d)&&(R=Fp(R,d.pop())),d.push(R)}const T=m&&m>fe.wc_sessionAuthenticate.req.ttl?m:fe.wc_sessionAuthenticate.req.ttl,A={authPayload:{type:p??"caip122",chains:o,statement:c,aud:a,domain:h,version:"1",nonce:l,iat:new Date().toISOString(),exp:u,nbf:f,resources:d},requester:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:pe(T)},S={eip155:{chains:o,methods:[...new Set(["personal_sign",...y])],events:["chainChanged","accountsChanged"]}},I={requiredNamespaces:{},optionalNamespaces:S,relays:[{protocol:"irn"}],pairingTopic:g,proposer:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:pe(fe.wc_sessionPropose.req.ttl),id:Rt()},{done:P,resolve:q,reject:N}=Kt(T,"Request expired"),C=Rt(),D=te("session_connect",I.id),$=te("session_request",C),b=async({error:v,session:R})=>{this.events.off($,E),v?N(v):R&&q({session:R})},E=async v=>{var R,L,B;if(await this.deletePendingAuthRequest(C,{message:"fulfilled",code:0}),v.error){const G=oe("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return v.error.code===G.code?void 0:(this.events.off(D,b),N(v.error.message))}await this.deleteProposal(I.id),this.events.off(D,b);const{cacaos:k,responder:M}=v.result,K=[],H=[];for(const G of k){await Ko({cacao:G,projectId:this.client.core.projectId})||(this.client.logger.error(G,"Signature verification failed"),N(oe("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:xe}=G,ze=Zs(xe.resources),qe=[fn(xe.iss)],Ne=tr(xe.iss);if(ze){const de=Fo(ze),He=Go(ze);K.push(...de),qe.push(...He)}for(const de of qe)H.push(`${de}:${Ne}`)}const F=await this.client.core.crypto.generateSharedKey(_,M.publicKey);let ie;K.length>0&&(ie={topic:F,acknowledged:!0,self:{publicKey:_,metadata:this.client.metadata},peer:M,controller:M.publicKey,expiry:pe(gi),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:g,namespaces:wa([...new Set(K)],[...new Set(H)]),transportType:n},await this.client.core.relayer.subscribe(F,{transportType:n}),await this.client.session.set(F,ie),g&&await this.client.core.pairing.updateMetadata({topic:g,metadata:M.metadata}),ie=this.client.session.get(F)),(R=this.client.metadata.redirect)!=null&&R.linkMode&&(L=M.metadata.redirect)!=null&&L.linkMode&&(B=M.metadata.redirect)!=null&&B.universal&&i&&(this.client.core.addLinkModeSupportedApp(M.metadata.redirect.universal),this.client.session.update(F,{transportType:ae.link_mode})),q({auths:k,session:ie})};this.events.once(D,b),this.events.once($,E);let x;try{if(r){const v=Jt("wc_sessionAuthenticate",A,C);this.client.core.history.set(g,v);const R=await this.client.core.crypto.encode("",v,{type:Cs,encoding:kt});x=Ms(i,g,R)}else await Promise.all([this.sendRequest({topic:g,method:"wc_sessionAuthenticate",params:A,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:C}),this.sendRequest({topic:g,method:"wc_sessionPropose",params:I,expiry:fe.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:I.id})])}catch(v){throw this.events.off(D,b),this.events.off($,E),v}return await this.setProposal(I.id,I),await this.setAuthRequest(C,{request:Re(re({},A),{verifyContext:{}}),pairingTopic:g,transportType:n}),{uri:x??w,response:P}}),U(this,"approveSessionAuthenticate",async t=>{const{id:i,auths:s}=t,r=this.client.core.eventClient.createEvent({properties:{topic:i.toString(),trace:[Vt.authenticated_session_approve_started]}});try{this.isInitialized()}catch(m){throw r.setError(rs.no_internet_connection),m}const n=this.getPendingAuthRequest(i);if(!n)throw r.setError(rs.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${i}`);const o=n.transportType||ae.relay;o===ae.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),h=Ys(c),l={type:Nt,receiverPublicKey:c,senderPublicKey:a},p=[],u=[];for(const m of s){if(!await Ko({cacao:m,projectId:this.client.core.projectId})){r.setError(rs.invalid_cacao);const O=oe("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:i,topic:h,error:O,encodeOpts:l}),new Error(O.message)}r.addTrace(Vt.cacaos_verified);const{p:d}=m,g=Zs(d.resources),w=[fn(d.iss)],_=tr(d.iss);if(g){const O=Fo(g),T=Go(g);p.push(...O),w.push(...T)}for(const O of w)u.push(`${O}:${_}`)}const f=await this.client.core.crypto.generateSharedKey(a,c);r.addTrace(Vt.create_authenticated_session_topic);let y;if((p==null?void 0:p.length)>0){y={topic:f,acknowledged:!0,self:{publicKey:a,metadata:this.client.metadata},peer:{publicKey:c,metadata:n.requester.metadata},controller:c,expiry:pe(gi),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:wa([...new Set(p)],[...new Set(u)]),transportType:o},r.addTrace(Vt.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(f,{transportType:o})}catch(m){throw r.setError(rs.subscribe_authenticated_session_topic_failure),m}r.addTrace(Vt.subscribe_authenticated_session_topic_success),await this.client.session.set(f,y),r.addTrace(Vt.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(Vt.publishing_authenticated_session_approve);try{await this.sendResult({topic:h,id:i,result:{cacaos:s,responder:{publicKey:a,metadata:this.client.metadata}},encodeOpts:l,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,o)})}catch(m){throw r.setError(rs.authenticated_session_approve_publish_failure),m}return await this.client.auth.requests.delete(i,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:y}}),U(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:i,reason:s}=t,r=this.getPendingAuthRequest(i);if(!r)throw new Error(`Could not find pending auth request with id ${i}`);r.transportType===ae.relay&&await this.confirmOnlineStateOrThrow();const n=r.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),c=Ys(n),a={type:Nt,receiverPublicKey:n,senderPublicKey:o};await this.sendError({id:i,topic:c,error:s,encodeOpts:a,rpcOpts:fe.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(i,{message:"rejected",code:0}),await this.client.proposal.delete(i,oe("USER_DISCONNECTED"))}),U(this,"formatAuthMessage",t=>{this.isInitialized();const{request:i,iss:s}=t;return eh(i,s)}),U(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),U(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const i=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,o;return((n=r.peerMetadata)==null?void 0:n.url)&&((o=r.peerMetadata)==null?void 0:o.url)===t.peer.metadata.url&&r.topic&&r.topic!==i.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(i){this.client.logger.error(i)}}),U(this,"deleteSession",async t=>{var i;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:o=0}=t,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,oe("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(Wa).catch(a=>this.client.logger.warn(a)),this.getPendingSessionRequests().forEach(a=>{a.topic===s&&this.deletePendingSessionRequest(a.id,oe("USER_DISCONNECTED"))}),s===((i=this.sessionRequestQueue.queue[0])==null?void 0:i.topic)&&(this.sessionRequestQueue.state=ft.idle),n&&this.client.events.emit("session_delete",{id:o,topic:s})}),U(this,"deleteProposal",async(t,i)=>{if(i)try{const s=this.client.proposal.get(t),r=this.client.core.eventClient.getEvent({topic:s.pairingTopic});r==null||r.setError(Ht.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,oe("USER_DISCONNECTED")),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),U(this,"deletePendingSessionRequest",async(t,i,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,i),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),s&&(this.sessionRequestQueue.state=ft.idle,this.client.events.emit("session_request_expire",{id:t}))}),U(this,"deletePendingAuthRequest",async(t,i,s=!1)=>{await Promise.all([this.client.auth.requests.delete(t,i),s?Promise.resolve():this.client.core.expirer.del(t)])}),U(this,"setExpiry",async(t,i)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,i),await this.client.session.update(t,{expiry:i}))}),U(this,"setProposal",async(t,i)=>{this.client.core.expirer.set(t,pe(fe.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,i)}),U(this,"setAuthRequest",async(t,i)=>{const{request:s,pairingTopic:r,transportType:n=ae.relay}=i;this.client.core.expirer.set(t,s.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:t,pairingTopic:r,verifyContext:s.verifyContext,transportType:n})}),U(this,"setPendingSessionRequest",async t=>{const{id:i,topic:s,params:r,verifyContext:n}=t,o=r.request.expiryTimestamp||pe(fe.wc_sessionRequest.req.ttl);this.client.core.expirer.set(i,o),await this.client.pendingRequest.set(i,{id:i,topic:s,params:r,verifyContext:n})}),U(this,"sendRequest",async t=>{const{topic:i,method:s,params:r,expiry:n,relayRpcId:o,clientRpcId:c,throwOnFailedPublish:a,appLink:h,tvf:l}=t,p=Jt(s,r,c);let u;const f=!!h;try{const d=f?kt:lt;u=await this.client.core.crypto.encode(i,p,{encoding:d})}catch(d){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${i} failed`),d}let y;if(cv.includes(s)){const d=wt(JSON.stringify(p)),g=wt(u);y=await this.client.core.verify.register({id:g,decryptedId:d})}const m=fe[s].req;if(m.attestation=y,n&&(m.ttl=n),o&&(m.id=o),this.client.core.history.set(i,p),f){const d=Ms(h,i,u);await V.Linking.openURL(d,this.client.name)}else{const d=fe[s].req;n&&(d.ttl=n),o&&(d.id=o),d.tvf=Re(re({},l),{correlationId:p.id}),a?(d.internal=Re(re({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,u,d)):this.client.core.relayer.publish(i,u,d).catch(g=>this.client.logger.error(g))}return p.id}),U(this,"sendResult",async t=>{const{id:i,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:o,appLink:c}=t,a=hr(i,r);let h;const l=c&&typeof(V==null?void 0:V.Linking)<"u";try{const f=l?kt:lt;h=await this.client.core.crypto.encode(s,a,Re(re({},o||{}),{encoding:f}))}catch(f){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),f}let p,u;try{p=await this.client.core.history.get(s,i);const f=p.request;try{this.shouldSetTVF(f.method,f.params)&&(u=this.getTVFParams(i,f.params,r))}catch(y){this.client.logger.warn("sendResult() -> getTVFParams() failed",y)}}catch(f){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${i}) failed`),f}if(l){const f=Ms(c,s,h);await V.Linking.openURL(f,this.client.name)}else{const f=p.request.method,y=fe[f].res;y.tvf=Re(re({},u),{correlationId:i}),n?(y.internal=Re(re({},y.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,h,y)):this.client.core.relayer.publish(s,h,y).catch(m=>this.client.logger.error(m))}await this.client.core.history.resolve(a)}),U(this,"sendError",async t=>{const{id:i,topic:s,error:r,encodeOpts:n,rpcOpts:o,appLink:c}=t,a=fc(i,r);let h;const l=c&&typeof(V==null?void 0:V.Linking)<"u";try{const u=l?kt:lt;h=await this.client.core.crypto.encode(s,a,Re(re({},n||{}),{encoding:u}))}catch(u){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),u}let p;try{p=await this.client.core.history.get(s,i)}catch(u){throw this.client.logger.error(`sendError() -> history.get(${s}, ${i}) failed`),u}if(l){const u=Ms(c,s,h);await V.Linking.openURL(u,this.client.name)}else{const u=p.request.method,f=o||fe[u].res;this.client.core.relayer.publish(s,h,f)}await this.client.core.history.resolve(a)}),U(this,"cleanup",async()=>{const t=[],i=[];this.client.session.getAll().forEach(s=>{let r=!1;Dt(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{Dt(s.expiryTimestamp)&&i.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...i.map(s=>this.deleteProposal(s))])}),U(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),U(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),U(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===ft.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=ft.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(i){this.client.logger.warn(i)}}this.requestQueue.state=ft.idle}),U(this,"processRequest",async t=>{const{topic:i,payload:s,attestation:r,transportType:n,encryptedId:o}=t,c=s.method;if(!this.shouldIgnorePairingRequest({topic:i,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:i,payload:s,attestation:r,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(i,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(i,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(i,s);case"wc_sessionPing":return await this.onSessionPingRequest(i,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(i,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:i,payload:s,attestation:r,encryptedId:o,transportType:n});case"wc_sessionEvent":return await this.onSessionEventRequest(i,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:i,payload:s,attestation:r,encryptedId:o,transportType:n});default:return this.client.logger.info(`Unsupported request method ${c}`)}}),U(this,"onRelayEventResponse",async t=>{const{topic:i,payload:s,transportType:r}=t,n=(await this.client.core.history.get(i,s.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(i,s,r);case"wc_sessionSettle":return this.onSessionSettleResponse(i,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(i,s);case"wc_sessionExtend":return this.onSessionExtendResponse(i,s);case"wc_sessionPing":return this.onSessionPingResponse(i,s);case"wc_sessionRequest":return this.onSessionRequestResponse(i,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(i,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}}),U(this,"onRelayEventUnknownPayload",t=>{const{topic:i}=t,{message:s}=j("MISSING_OR_INVALID",`Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),U(this,"shouldIgnorePairingRequest",t=>{const{topic:i,requestMethod:s}=t,r=this.expectedPairingMethodMap.get(i);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),U(this,"onSessionProposeRequest",async t=>{const{topic:i,payload:s,attestation:r,encryptedId:n}=t,{params:o,id:c}=s;try{const a=this.client.core.eventClient.getEvent({topic:i});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),a==null||a.setError(It.proposal_listener_not_found)),this.isValidConnect(re({},s.params));const h=o.expiryTimestamp||pe(fe.wc_sessionPropose.req.ttl),l=re({id:c,pairingTopic:i,expiryTimestamp:h},o);await this.setProposal(c,l);const p=await this.getVerifyContext({attestationId:r,hash:wt(JSON.stringify(s)),encryptedId:n,metadata:l.proposer.metadata});a==null||a.addTrace(yt.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:l,verifyContext:p})}catch(a){await this.sendError({id:c,topic:i,error:a,rpcOpts:fe.wc_sessionPropose.autoReject}),this.client.logger.error(a)}}),U(this,"onSessionProposeResponse",async(t,i,s)=>{const{id:r}=i;if(Et(i)){const{result:n}=i;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const o=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const c=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const a=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const h=await this.client.core.crypto.generateSharedKey(c,a);this.pendingSessions.set(r,{sessionTopic:h,pairingTopic:t,proposalId:r,publicKey:c});const l=await this.client.core.relayer.subscribe(h,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:l}),await this.client.core.pairing.activate({topic:t})}else if(mt(i)){await this.client.proposal.delete(r,oe("USER_DISCONNECTED"));const n=te("session_connect",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners, 954`);this.events.emit(n,{error:i.error})}}),U(this,"onSessionSettleRequest",async(t,i)=>{const{id:s,params:r}=i;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:o,expiry:c,namespaces:a,sessionProperties:h,scopedProperties:l,sessionConfig:p}=i.params,u=[...this.pendingSessions.values()].find(m=>m.sessionTopic===t);if(!u)return this.client.logger.error(`Pending session not found for topic ${t}`);const f=this.client.proposal.get(u.proposalId),y=Re(re(re(re({topic:t,relay:n,expiry:c,namespaces:a,acknowledged:!0,pairingTopic:u.pairingTopic,requiredNamespaces:f.requiredNamespaces,optionalNamespaces:f.optionalNamespaces,controller:o.publicKey,self:{publicKey:u.publicKey,metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},h&&{sessionProperties:h}),l&&{scopedProperties:l}),p&&{sessionConfig:p}),{transportType:ae.relay});await this.client.session.set(y.topic,y),await this.setExpiry(y.topic,y.expiry),await this.client.core.pairing.updateMetadata({topic:u.pairingTopic,metadata:y.peer.metadata}),this.client.events.emit("session_connect",{session:y}),this.events.emit(te("session_connect",u.proposalId),{session:y}),this.pendingSessions.delete(u.proposalId),this.deleteProposal(u.proposalId,!1),this.cleanupDuplicatePairings(y),await this.sendResult({id:i.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}}),U(this,"onSessionSettleResponse",async(t,i)=>{const{id:s}=i;Et(i)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(te("session_approve",s),{})):mt(i)&&(await this.client.session.delete(t,oe("USER_DISCONNECTED")),this.events.emit(te("session_approve",s),{error:i.error}))}),U(this,"onSessionUpdateRequest",async(t,i)=>{const{params:s,id:r}=i;try{const n=`${t}_session_update`,o=is.get(n);if(o&&this.isRequestOutOfSync(o,r)){this.client.logger.warn(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:oe("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(re({topic:t},s));try{is.set(n,r),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw is.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:s})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}}),U(this,"isRequestOutOfSync",(t,i)=>i.toString().slice(0,-3)<t.toString().slice(0,-3)),U(this,"onSessionUpdateResponse",(t,i)=>{const{id:s}=i,r=te("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);Et(i)?this.events.emit(te("session_update",s),{}):mt(i)&&this.events.emit(te("session_update",s),{error:i.error})}),U(this,"onSessionExtendRequest",async(t,i)=>{const{id:s}=i;try{this.isValidExtend({topic:t}),await this.setExpiry(t,pe(gi)),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}}),U(this,"onSessionExtendResponse",(t,i)=>{const{id:s}=i,r=te("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);Et(i)?this.events.emit(te("session_extend",s),{}):mt(i)&&this.events.emit(te("session_extend",s),{error:i.error})}),U(this,"onSessionPingRequest",async(t,i)=>{const{id:s}=i;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}}),U(this,"onSessionPingResponse",(t,i)=>{const{id:s}=i,r=te("session_ping",s);setTimeout(()=>{if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners 2176`);Et(i)?this.events.emit(te("session_ping",s),{}):mt(i)&&this.events.emit(te("session_ping",s),{error:i.error})},500)}),U(this,"onSessionDeleteRequest",async(t,i)=>{const{id:s}=i;try{this.isValidDisconnect({topic:t,reason:i.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(we.publish,async()=>{r(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:oe("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}}),U(this,"onSessionRequest",async t=>{var i,s,r;const{topic:n,payload:o,attestation:c,encryptedId:a,transportType:h}=t,{id:l,params:p}=o;try{await this.isValidRequest(re({topic:n},p));const u=this.client.session.get(n),f=await this.getVerifyContext({attestationId:c,hash:wt(JSON.stringify(Jt("wc_sessionRequest",p,l))),encryptedId:a,metadata:u.peer.metadata,transportType:h}),y={id:l,topic:n,params:p,verifyContext:f};await this.setPendingSessionRequest(y),h===ae.link_mode&&(i=u.peer.metadata.redirect)!=null&&i.universal&&this.client.core.addLinkModeSupportedApp((s=u.peer.metadata.redirect)==null?void 0:s.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(y):(this.addSessionRequestToSessionRequestQueue(y),this.processSessionRequestQueue())}catch(u){await this.sendError({id:l,topic:n,error:u}),this.client.logger.error(u)}}),U(this,"onSessionRequestResponse",(t,i)=>{const{id:s}=i,r=te("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);Et(i)?this.events.emit(te("session_request",s),{result:i.result}):mt(i)&&this.events.emit(te("session_request",s),{error:i.error})}),U(this,"onSessionEventRequest",async(t,i)=>{const{id:s,params:r}=i;try{const n=`${t}_session_event_${r.event.name}`,o=is.get(n);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(re({topic:t},r)),this.client.events.emit("session_event",{id:s,topic:t,params:r}),is.set(n,s)}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}}),U(this,"onSessionAuthenticateResponse",(t,i)=>{const{id:s}=i;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:i}),Et(i)?this.events.emit(te("session_request",s),{result:i.result}):mt(i)&&this.events.emit(te("session_request",s),{error:i.error})}),U(this,"onSessionAuthenticateRequest",async t=>{var i;const{topic:s,payload:r,attestation:n,encryptedId:o,transportType:c}=t;try{const{requester:a,authPayload:h,expiryTimestamp:l}=r.params,p=await this.getVerifyContext({attestationId:n,hash:wt(JSON.stringify(r)),encryptedId:o,metadata:a.metadata,transportType:c}),u={requester:a,pairingTopic:s,id:r.id,authPayload:h,verifyContext:p,expiryTimestamp:l};await this.setAuthRequest(r.id,{request:u,pairingTopic:s,transportType:c}),c===ae.link_mode&&(i=a.metadata.redirect)!=null&&i.universal&&this.client.core.addLinkModeSupportedApp(a.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:r.params,id:r.id,verifyContext:p})}catch(a){this.client.logger.error(a);const h=r.params.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),p=this.getAppLinkIfEnabled(r.params.requester.metadata,c),u={type:Nt,receiverPublicKey:h,senderPublicKey:l};await this.sendError({id:r.id,topic:s,error:a,encodeOpts:u,rpcOpts:fe.wc_sessionAuthenticate.autoReject,appLink:p})}}),U(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),U(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=ft.idle,this.processSessionRequestQueue()},(0,X.toMiliseconds)(this.requestQueueDelay))}),U(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:i})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,o=te("session_request",n);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(te("session_request",r.request.id),{error:i})})}),U(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===ft.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=ft.active,this.emitSessionRequest(t)}catch(i){this.client.logger.error(i)}}),U(this,"emitSessionRequest",t=>{this.client.events.emit("session_request",t)}),U(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const i=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);i&&this.onSessionProposeRequest({topic:t.topic,payload:Jt("wc_sessionPropose",Re(re({},i),{requiredNamespaces:i.requiredNamespaces,optionalNamespaces:i.optionalNamespaces,relays:i.relays,proposer:i.proposer,sessionProperties:i.sessionProperties,scopedProperties:i.scopedProperties}),i.id)})}),U(this,"isValidConnect",async t=>{if(!De(t)){const{message:a}=j("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(a)}const{pairingTopic:i,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,scopedProperties:o,relays:c}=t;if(Pe(i)||await this.isValidPairingTopic(i),!iy(c,!0)){const{message:a}=j("MISSING_OR_INVALID",`connect() relays: ${c}`);throw new Error(a)}if(!Pe(s)&&Is(s)!==0){const a="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(a):this.client.logger.warn(a),this.validateNamespaces(s,"requiredNamespaces")}if(!Pe(r)&&Is(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),Pe(n)||this.validateSessionProps(n,"sessionProperties"),!Pe(o)){this.validateSessionProps(o,"scopedProperties");const a=Object.keys(s||{}).concat(Object.keys(r||{}));if(!Object.keys(o).every(h=>a.includes(h)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(a)}`)}}),U(this,"validateNamespaces",(t,i)=>{const s=ty(t,"connect()",i);if(s)throw new Error(s.message)}),U(this,"isValidApprove",async t=>{if(!De(t))throw new Error(j("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:i,namespaces:s,relayProtocol:r,sessionProperties:n,scopedProperties:o}=t;this.checkRecentlyDeleted(i),await this.isValidProposalId(i);const c=this.client.proposal.get(i),a=Kr(s,"approve()");if(a)throw new Error(a.message);const h=ba(c.requiredNamespaces,s,"approve()");if(h)throw new Error(h.message);if(!ue(r,!0)){const{message:l}=j("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(l)}if(Pe(n)||this.validateSessionProps(n,"sessionProperties"),!Pe(o)){this.validateSessionProps(o,"scopedProperties");const l=new Set(Object.keys(s));if(!Object.keys(o).every(p=>l.has(p)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(l).join(", ")}`)}}),U(this,"isValidReject",async t=>{if(!De(t)){const{message:r}=j("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:i,reason:s}=t;if(this.checkRecentlyDeleted(i),await this.isValidProposalId(i),!ry(s)){const{message:r}=j("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}}),U(this,"isValidSessionSettleRequest",t=>{if(!De(t)){const{message:a}=j("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(a)}const{relay:i,controller:s,namespaces:r,expiry:n}=t;if(!Oh(i)){const{message:a}=j("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(a)}const o=Zf(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const c=Kr(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(Dt(n)){const{message:a}=j("EXPIRED","onSessionSettleRequest()");throw new Error(a)}}),U(this,"isValidUpdate",async t=>{if(!De(t)){const{message:c}=j("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:i,namespaces:s}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i);const r=this.client.session.get(i),n=Kr(s,"update()");if(n)throw new Error(n.message);const o=ba(r.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)}),U(this,"isValidExtend",async t=>{if(!De(t)){const{message:s}=j("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:i}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i)}),U(this,"isValidRequest",async t=>{if(!De(t)){const{message:c}=j("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:i,request:s,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i);const{namespaces:o}=this.client.session.get(i);if(!va(o,r)){const{message:c}=j("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!ny(s)){const{message:c}=j("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!cy(o,r,s.method)){const{message:c}=j("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!dy(n,Qr)){const{message:c}=j("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${Qr.min} and ${Qr.max}`);throw new Error(c)}}),U(this,"isValidRespond",async t=>{var i;if(!De(t)){const{message:n}=j("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:s,response:r}=t;try{await this.isValidSessionTopic(s)}catch(n){throw(i=t==null?void 0:t.response)!=null&&i.id&&this.cleanupAfterResponse(t),n}if(!oy(r)){const{message:n}=j("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}}),U(this,"isValidPing",async t=>{if(!De(t)){const{message:s}=j("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:i}=t;await this.isValidSessionOrPairingTopic(i)}),U(this,"isValidEmit",async t=>{if(!De(t)){const{message:o}=j("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(o)}const{topic:i,event:s,chainId:r}=t;await this.isValidSessionTopic(i);const{namespaces:n}=this.client.session.get(i);if(!va(n,r)){const{message:o}=j("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(o)}if(!ay(s)){const{message:o}=j("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!hy(n,r,s.name)){const{message:o}=j("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}}),U(this,"isValidDisconnect",async t=>{if(!De(t)){const{message:s}=j("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:i}=t;await this.isValidSessionOrPairingTopic(i)}),U(this,"isValidAuthenticate",t=>{const{chains:i,uri:s,domain:r,nonce:n}=t;if(!Array.isArray(i)||i.length===0)throw new Error("chains is required and must be a non-empty array");if(!ue(s,!1))throw new Error("uri is required parameter");if(!ue(r,!1))throw new Error("domain is required parameter");if(!ue(n,!1))throw new Error("nonce is required parameter");if([...new Set(i.map(c=>Ws(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=Ws(i[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),U(this,"getVerifyContext",async t=>{const{attestationId:i,hash:s,encryptedId:r,metadata:n,transportType:o}=t,c={verified:{verifyUrl:n.verifyUrl||gs,validation:"UNKNOWN",origin:n.url||""}};try{if(o===ae.link_mode){const h=this.getAppLinkIfEnabled(n,o);return c.verified.validation=h&&new URL(h).origin===new URL(n.url).origin?"VALID":"INVALID",c}const a=await this.client.core.verify.resolve({attestationId:i,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});a&&(c.verified.origin=a.origin,c.verified.isScam=a.isScam,c.verified.validation=a.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(a){this.client.logger.warn(a)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c}),U(this,"validateSessionProps",(t,i)=>{Object.values(t).forEach((s,r)=>{if(s==null){const{message:n}=j("MISSING_OR_INVALID",`${i} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[r]}`);throw new Error(n)}})}),U(this,"getPendingAuthRequest",t=>{const i=this.client.auth.requests.get(t);return typeof i=="object"?i:void 0}),U(this,"addToRecentlyDeleted",(t,i)=>{if(this.recentlyDeletedMap.set(t,i),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}}),U(this,"checkRecentlyDeleted",t=>{const i=this.recentlyDeletedMap.get(t);if(i){const{message:s}=j("MISSING_OR_INVALID",`Record was recently deleted - ${i}: ${t}`);throw new Error(s)}}),U(this,"isLinkModeEnabled",(t,i)=>{var s,r,n,o,c,a,h,l,p;return!t||i!==ae.link_mode?!1:((r=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:r.linkMode)===!0&&((o=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:o.universal)!==void 0&&((a=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:a.universal)!==""&&((h=t==null?void 0:t.redirect)==null?void 0:h.universal)!==void 0&&((l=t==null?void 0:t.redirect)==null?void 0:l.universal)!==""&&((p=t==null?void 0:t.redirect)==null?void 0:p.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(V==null?void 0:V.Linking)<"u"}),U(this,"getAppLinkIfEnabled",(t,i)=>{var s;return this.isLinkModeEnabled(t,i)?(s=t==null?void 0:t.redirect)==null?void 0:s.universal:void 0}),U(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const i=Do(t,"topic")||"",s=decodeURIComponent(Do(t,"wc_ev")||""),r=this.client.session.keys.includes(i);r&&this.client.session.update(i,{transportType:ae.link_mode}),this.client.core.dispatchEnvelope({topic:i,message:s,sessionExists:r})}),U(this,"registerLinkModeListeners",async()=>{var t;if(Zn()||zt()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const i=V==null?void 0:V.Linking;if(typeof i<"u"){i.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await i.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),U(this,"shouldSetTVF",(t,i)=>{if(!i||t!=="wc_sessionRequest")return!1;const{request:s}=i;return Object.keys(Ya).includes(s.method)}),U(this,"getTVFParams",(t,i,s)=>{var r,n;try{const o=i.request.method,c=this.extractTxHashesFromResult(o,s);return Re(re({correlationId:t,rpcMethods:[o],chainId:i.chainId},this.isValidContractData(i.request.params)&&{contractAddresses:[(n=(r=i.request.params)==null?void 0:r[0])==null?void 0:n.to]}),{txHashes:c})}catch(o){this.client.logger.warn("Error getting TVF params",o)}return{}}),U(this,"isValidContractData",t=>{var i;if(!t)return!1;try{const s=(t==null?void 0:t.data)||((i=t==null?void 0:t[0])==null?void 0:i.data);if(!s.startsWith("0x"))return!1;const r=s.slice(2);return/^[0-9a-fA-F]*$/.test(r)?r.length%2===0:!1}catch{}return!1}),U(this,"extractTxHashesFromResult",(t,i)=>{try{const s=Ya[t];if(typeof i=="string")return[i];const r=i[s.key];if(Ts(r))return t==="solana_signAllTransactions"?r.map(n=>Np(n)):r;if(typeof r=="string")return[r]}catch(s){this.client.logger.warn("Error extracting tx hashes from result",s)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[i,s]of Object.entries(t))for(const r of s)try{await this.onProviderMessageEvent({topic:i,message:r,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${i}, message: ${r}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=j("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(we.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:i,attestation:s,transportType:r}=e,{publicKey:n}=this.client.auth.authKeys.keys.includes(Qs)?this.client.auth.authKeys.get(Qs):{responseTopic:void 0,publicKey:void 0};try{const o=await this.client.core.crypto.decode(t,i,{receiverPublicKey:n,encoding:r===ae.link_mode?kt:lt});zn(o)?(this.client.core.history.set(t,o),await this.onRelayEventRequest({topic:t,payload:o,attestation:s,transportType:r,encryptedId:wt(i)})):Hn(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:t,payload:o,transportType:r}),this.client.core.history.delete(t,o.id)):await this.onRelayEventUnknownPayload({topic:t,payload:o,transportType:r}),await this.client.core.relayer.messages.ack(t,i)}catch(o){this.client.logger.error(o)}}registerExpirerEvents(){this.client.core.expirer.on(tt.expired,async e=>{const{topic:t,id:i}=Kc(e.target);if(i&&this.client.pendingRequest.keys.includes(i))return await this.deletePendingSessionRequest(i,j("EXPIRED"),!0);if(i&&this.client.auth.requests.keys.includes(i))return await this.deletePendingAuthRequest(i,j("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):i&&(await this.deleteProposal(i,!0),this.client.events.emit("proposal_expire",{id:i}))})}registerPairingEvents(){this.client.core.pairing.events.on(Zt.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(Zt.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!ue(e,!1)){const{message:t}=j("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=j("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if(Dt(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=j("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!ue(e,!1)){const{message:t}=j("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=j("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if(Dt(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=j("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=j("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if(ue(e,!1)){const{message:t}=j("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=j("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!sy(e)){const{message:t}=j("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=j("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if(Dt(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=j("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}},vv=class extends ai{constructor(e,t){super(e,t,rv,so),this.core=e,this.logger=t}},bv=class extends ai{constructor(e,t){super(e,t,nv,so),this.core=e,this.logger=t}},Ev=class extends ai{constructor(e,t){super(e,t,av,so,i=>i.id),this.core=e,this.logger=t}},Iv=class extends ai{constructor(e,t){super(e,t,uv,Ir,()=>Qs),this.core=e,this.logger=t}},_v=class extends ai{constructor(e,t){super(e,t,dv,Ir),this.core=e,this.logger=t}},Pv=class extends ai{constructor(e,t){super(e,t,pv,Ir,i=>i.id),this.core=e,this.logger=t}},Sv=Object.defineProperty,Ov=(e,t,i)=>t in e?Sv(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Xr=(e,t,i)=>Ov(e,typeof t!="symbol"?t+"":t,i),Av=class{constructor(e,t){this.core=e,this.logger=t,Xr(this,"authKeys"),Xr(this,"pairingTopics"),Xr(this,"requests"),this.authKeys=new Iv(this.core,this.logger),this.pairingTopics=new _v(this.core,this.logger),this.requests=new Pv(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}},xv=Object.defineProperty,Nv=(e,t,i)=>t in e?xv(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Z=(e,t,i)=>Nv(e,typeof t!="symbol"?t+"":t,i),Rv=class Wh extends Ad{constructor(t){super(t),Z(this,"protocol",Kh),Z(this,"version",Fh),Z(this,"name",Jr.name),Z(this,"metadata"),Z(this,"core"),Z(this,"logger"),Z(this,"events",new Vh.EventEmitter),Z(this,"engine"),Z(this,"session"),Z(this,"proposal"),Z(this,"pendingRequest"),Z(this,"auth"),Z(this,"signConfig"),Z(this,"on",(s,r)=>this.events.on(s,r)),Z(this,"once",(s,r)=>this.events.once(s,r)),Z(this,"off",(s,r)=>this.events.off(s,r)),Z(this,"removeListener",(s,r)=>this.events.removeListener(s,r)),Z(this,"removeAllListeners",s=>this.events.removeAllListeners(s)),Z(this,"connect",async s=>{try{return await this.engine.connect(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"pair",async s=>{try{return await this.engine.pair(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"approve",async s=>{try{return await this.engine.approve(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"reject",async s=>{try{return await this.engine.reject(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"update",async s=>{try{return await this.engine.update(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"extend",async s=>{try{return await this.engine.extend(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"request",async s=>{try{return await this.engine.request(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"respond",async s=>{try{return await this.engine.respond(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"ping",async s=>{try{return await this.engine.ping(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"emit",async s=>{try{return await this.engine.emit(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"disconnect",async s=>{try{return await this.engine.disconnect(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"find",s=>{try{return this.engine.find(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}}),Z(this,"authenticate",async(s,r)=>{try{return await this.engine.authenticate(s,r)}catch(n){throw this.logger.error(n.message),n}}),Z(this,"formatAuthMessage",s=>{try{return this.engine.formatAuthMessage(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"approveSessionAuthenticate",async s=>{try{return await this.engine.approveSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),Z(this,"rejectSessionAuthenticate",async s=>{try{return await this.engine.rejectSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),this.name=(t==null?void 0:t.name)||Jr.name,this.metadata=Hd(t==null?void 0:t.metadata),this.signConfig=t==null?void 0:t.signConfig;const i=typeof(t==null?void 0:t.logger)<"u"&&typeof(t==null?void 0:t.logger)!="string"?t.logger:(0,Mn.default)(lr({level:(t==null?void 0:t.logger)||Jr.logger}));this.core=(t==null?void 0:t.core)||new sv(t),this.logger=Te(i,this.name),this.session=new bv(this.core,this.logger),this.proposal=new vv(this.core,this.logger),this.pendingRequest=new Ev(this.core,this.logger),this.engine=new $v(this),this.auth=new Av(this.core,this.logger)}static async init(t){const i=new Wh(t);return await i.initialize(),i}get context(){return Qe(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},(0,X.toMiliseconds)(X.ONE_SECOND))}catch(t){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(t.message),t}}};cr();var Cv=Me(_s());const Qa="error",Tv="wss://relay.walletconnect.org",qv="wc",Uv="universal_provider",Hs=`${qv}@2:${Uv}:`,Zh="https://rpc.walletconnect.org/v1/",Si="generic",Dv=`${Zh}bundler`,rt={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function kv(){}function ro(e){return e==null||typeof e!="object"&&typeof e!="function"}function no(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}function jv(e){if(ro(e))return e;if(Array.isArray(e)||no(e)||e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer)return e.slice(0);const t=Object.getPrototypeOf(e),i=t.constructor;if(e instanceof Date||e instanceof Map||e instanceof Set)return new i(e);if(e instanceof RegExp){const s=new i(e);return s.lastIndex=e.lastIndex,s}if(e instanceof DataView)return new i(e.buffer.slice(0));if(e instanceof Error){const s=new i(e.message);return s.stack=e.stack,s.name=e.name,s.cause=e.cause,s}if(typeof File<"u"&&e instanceof File)return new i([e],e.name,{type:e.type,lastModified:e.lastModified});if(typeof e=="object"){const s=Object.create(t);return Object.assign(s,e)}return e}function Xa(e){return typeof e=="object"&&e!==null}function Yh(e){return Object.getOwnPropertySymbols(e).filter(t=>Object.prototype.propertyIsEnumerable.call(e,t))}function Jh(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const Lv="[object RegExp]",Qh="[object String]",Xh="[object Number]",el="[object Boolean]",tl="[object Arguments]",Bv="[object Symbol]",Mv="[object Date]",zv="[object Map]",Hv="[object Set]",Vv="[object Array]",Kv="[object ArrayBuffer]",Fv="[object Object]",Gv="[object DataView]",Wv="[object Uint8Array]",Zv="[object Uint8ClampedArray]",Yv="[object Uint16Array]",Jv="[object Uint32Array]",Qv="[object Int8Array]",Xv="[object Int16Array]",e0="[object Int32Array]",t0="[object Float32Array]",i0="[object Float64Array]";function s0(e,t){return Ni(e,void 0,e,new Map,t)}function Ni(e,t,i,s=new Map,r=void 0){const n=r==null?void 0:r(e,t,i,s);if(n!=null)return n;if(ro(e))return e;if(s.has(e))return s.get(e);if(Array.isArray(e)){const o=new Array(e.length);s.set(e,o);for(let c=0;c<e.length;c++)o[c]=Ni(e[c],c,i,s,r);return Object.hasOwn(e,"index")&&(o.index=e.index),Object.hasOwn(e,"input")&&(o.input=e.input),o}if(e instanceof Date)return new Date(e.getTime());if(e instanceof RegExp){const o=new RegExp(e.source,e.flags);return o.lastIndex=e.lastIndex,o}if(e instanceof Map){const o=new Map;s.set(e,o);for(const[c,a]of e)o.set(c,Ni(a,c,i,s,r));return o}if(e instanceof Set){const o=new Set;s.set(e,o);for(const c of e)o.add(Ni(c,void 0,i,s,r));return o}if(typeof Ae<"u"&&Ae.isBuffer(e))return e.subarray();if(no(e)){const o=new(Object.getPrototypeOf(e)).constructor(e.length);s.set(e,o);for(let c=0;c<e.length;c++)o[c]=Ni(e[c],c,i,s,r);return o}if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer)return e.slice(0);if(e instanceof DataView){const o=new DataView(e.buffer.slice(0),e.byteOffset,e.byteLength);return s.set(e,o),Yt(o,e,i,s,r),o}if(typeof File<"u"&&e instanceof File){const o=new File([e],e.name,{type:e.type});return s.set(e,o),Yt(o,e,i,s,r),o}if(e instanceof Blob){const o=new Blob([e],{type:e.type});return s.set(e,o),Yt(o,e,i,s,r),o}if(e instanceof Error){const o=new e.constructor;return s.set(e,o),o.message=e.message,o.name=e.name,o.stack=e.stack,o.cause=e.cause,Yt(o,e,i,s,r),o}if(typeof e=="object"&&r0(e)){const o=Object.create(Object.getPrototypeOf(e));return s.set(e,o),Yt(o,e,i,s,r),o}return e}function Yt(e,t,i=e,s,r){const n=[...Object.keys(t),...Yh(t)];for(let o=0;o<n.length;o++){const c=n[o],a=Object.getOwnPropertyDescriptor(e,c);(a==null||a.writable)&&(e[c]=Ni(t[c],c,i,s,r))}}function r0(e){switch(Jh(e)){case tl:case Vv:case Kv:case Gv:case el:case Mv:case t0:case i0:case Qv:case Xv:case e0:case zv:case Xh:case Fv:case Lv:case Hv:case Qh:case Bv:case Wv:case Zv:case Yv:case Jv:return!0;default:return!1}}function n0(e,t){return s0(e,(i,s,r,n)=>{const o=t==null?void 0:t(i,s,r,n);if(o!=null)return o;if(typeof e=="object")switch(Object.prototype.toString.call(e)){case Xh:case Qh:case el:{const c=new e.constructor(e==null?void 0:e.valueOf());return Yt(c,e),c}case tl:{const c={};return Yt(c,e),c.length=e.length,c[Symbol.iterator]=e[Symbol.iterator],c}default:return}})}function ec(e){return n0(e)}function tc(e){return e!==null&&typeof e=="object"&&Jh(e)==="[object Arguments]"}function o0(e){return no(e)}function a0(e){if(typeof e!="object"||e==null)return!1;if(Object.getPrototypeOf(e)===null)return!0;if(Object.prototype.toString.call(e)!=="[object Object]"){var t;const s=e[Symbol.toStringTag];return s==null||!(!((t=Object.getOwnPropertyDescriptor(e,Symbol.toStringTag))===null||t===void 0)&&t.writable)?!1:e.toString()===`[object ${s}]`}let i=e;for(;Object.getPrototypeOf(i)!==null;)i=Object.getPrototypeOf(i);return Object.getPrototypeOf(e)===i}function c0(e,...t){const i=t.slice(0,-1),s=t[t.length-1];let r=e;for(let n=0;n<i.length;n++){const o=i[n];r=Dn(r,o,s,new Map)}return r}function Dn(e,t,i,s){if(ro(e)&&(e=Object(e)),t==null||typeof t!="object")return e;if(s.has(t))return jv(s.get(t));if(s.set(t,e),Array.isArray(t)){t=t.slice();for(let n=0;n<t.length;n++)t[n]=t[n]??void 0}const r=[...Object.keys(t),...Yh(t)];for(let n=0;n<r.length;n++){const o=r[n];let c=t[o],a=e[o];if(tc(c)&&(c={...c}),tc(a)&&(a={...a}),typeof Ae<"u"&&Ae.isBuffer(c)&&(c=ec(c)),Array.isArray(c))if(typeof a=="object"&&a!=null){const l=[],p=Reflect.ownKeys(a);for(let u=0;u<p.length;u++){const f=p[u];l[f]=a[f]}a=l}else a=[];const h=i(a,c,o,e,t,s);h!=null?e[o]=h:Array.isArray(c)||Xa(a)&&Xa(c)?e[o]=Dn(a,c,i,s):a==null&&a0(c)?e[o]=Dn({},c,i,s):a==null&&o0(c)?e[o]=ec(c):(a===void 0||c!==void 0)&&(e[o]=c)}return e}function h0(e,...t){return c0(e,...t,kv)}var l0=Object.defineProperty,u0=Object.defineProperties,d0=Object.getOwnPropertyDescriptors,ic=Object.getOwnPropertySymbols,p0=Object.prototype.hasOwnProperty,g0=Object.prototype.propertyIsEnumerable,sc=(e,t,i)=>t in e?l0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Vs=(e,t)=>{for(var i in t||(t={}))p0.call(t,i)&&sc(e,i,t[i]);if(ic)for(var i of ic(t))g0.call(t,i)&&sc(e,i,t[i]);return e},f0=(e,t)=>u0(e,d0(t));function Je(e,t,i){var s;const r=mc(e);return((s=t.rpcMap)==null?void 0:s[r.reference])||`${Zh}?chainId=${r.namespace}:${r.reference}&projectId=${i}`}function ci(e){return e.includes(":")?e.split(":")[1]:e}function il(e){return e.map(t=>`${t.split(":")[0]}:${t.split(":")[1]}`)}function y0(e,t){const i=Object.keys(t.namespaces).filter(r=>r.includes(e));if(!i.length)return[];const s=[];return i.forEach(r=>{const n=t.namespaces[r].accounts;s.push(...n)}),s}function Ks(e={},t={}){const i=rc(e),s=rc(t);return h0(i,s)}function rc(e){var t,i,s,r,n;const o={};if(!qr(e))return o;for(const[c,a]of Object.entries(e)){const h=Wn(c)?[c]:a.chains,l=a.methods||[],p=a.events||[],u=a.rpcMap||{},f=cs(c);o[f]=f0(Vs(Vs({},o[f]),a),{chains:_r(h,(t=o[f])==null?void 0:t.chains),methods:_r(l,(i=o[f])==null?void 0:i.methods),events:_r(p,(s=o[f])==null?void 0:s.events)}),(qr(u)||qr(((r=o[f])==null?void 0:r.rpcMap)||{}))&&(o[f].rpcMap=Vs(Vs({},u),(n=o[f])==null?void 0:n.rpcMap))}return o}function nc(e){return e.includes(":")?e.split(":")[2]:e}function oc(e){const t={};for(const[i,s]of Object.entries(e)){const r=s.methods||[],n=s.events||[],o=s.accounts||[],c=Wn(i)?[i]:s.chains?s.chains:il(s.accounts);t[i]={chains:c,methods:r,events:n,accounts:o}}return t}function en(e){return typeof e=="number"?e:e.includes("0x")?parseInt(e,16):(e=e.includes(":")?e.split(":")[1]:e,isNaN(Number(e))?e:Number(e))}const sl={},ee=e=>sl[e],tn=(e,t)=>{sl[e]=t};var m0=Object.defineProperty,w0=(e,t,i)=>t in e?m0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,fi=(e,t,i)=>w0(e,typeof t!="symbol"?t+"":t,i),$0=class{constructor(e){fi(this,"name","polkadot"),fi(this,"client"),fi(this,"httpProviders"),fi(this,"events"),fi(this,"namespace"),fi(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=ci(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},v0=Object.defineProperty,b0=Object.defineProperties,E0=Object.getOwnPropertyDescriptors,ac=Object.getOwnPropertySymbols,I0=Object.prototype.hasOwnProperty,_0=Object.prototype.propertyIsEnumerable,kn=(e,t,i)=>t in e?v0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,cc=(e,t)=>{for(var i in t||(t={}))I0.call(t,i)&&kn(e,i,t[i]);if(ac)for(var i of ac(t))_0.call(t,i)&&kn(e,i,t[i]);return e},hc=(e,t)=>b0(e,E0(t)),yi=(e,t,i)=>kn(e,typeof t!="symbol"?t+"":t,i),P0=class{constructor(e){yi(this,"name","eip155"),yi(this,"client"),yi(this,"chainId"),yi(this,"namespace"),yi(this,"httpProviders"),yi(this,"events"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const i=t||Je(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=parseInt(ci(t));e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}async handleSwitchChain(e){var t,i;let s=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";s=s.startsWith("0x")?s:`0x${s}`;const r=parseInt(s,16);if(this.isChainApproved(r))this.setDefaultChain(`${r}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:s}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${r}`);else throw new Error(`Failed to switch to chain 'eip155:${r}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,i,s,r,n;const o=(i=(t=e.request)==null?void 0:t.params)==null?void 0:i[0],c=((r=(s=e.request)==null?void 0:s.params)==null?void 0:r[1])||[],a=`${o}${c.join(",")}`;if(!o)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const h=this.client.session.get(e.topic),l=((n=h==null?void 0:h.sessionProperties)==null?void 0:n.capabilities)||{};if(l!=null&&l[a])return l==null?void 0:l[a];const p=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:hc(cc({},h.sessionProperties||{}),{capabilities:hc(cc({},l||{}),{[a]:p})})})}catch(u){console.warn("Failed to update session with capabilities",u)}return p}async getCallStatus(e){var t,i;const s=this.client.session.get(e.topic),r=(t=s.sessionProperties)==null?void 0:t.bundler_name;if(r){const o=this.getBundlerUrl(e.chainId,r);try{return await this.getUserOperationReceipt(o,e)}catch(c){console.warn("Failed to fetch call status from bundler",c,o)}}const n=(i=s.sessionProperties)==null?void 0:i.bundler_url;if(n)try{return await this.getUserOperationReceipt(n,e)}catch(o){console.warn("Failed to fetch call status from custom bundler",o,n)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var i;const s=new URL(e),r=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(Jt("eth_getUserOperationReceipt",[(i=t.request.params)==null?void 0:i[0]]))});if(!r.ok)throw new Error(`Failed to fetch user operation receipt - ${r.status}`);return await r.json()}getBundlerUrl(e,t){return`${Dv}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}},S0=Object.defineProperty,O0=(e,t,i)=>t in e?S0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,mi=(e,t,i)=>O0(e,typeof t!="symbol"?t+"":t,i),A0=class{constructor(e){mi(this,"name","solana"),mi(this,"client"),mi(this,"httpProviders"),mi(this,"events"),mi(this,"namespace"),mi(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=ci(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},x0=Object.defineProperty,N0=(e,t,i)=>t in e?x0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,wi=(e,t,i)=>N0(e,typeof t!="symbol"?t+"":t,i),R0=class{constructor(e){wi(this,"name","cosmos"),wi(this,"client"),wi(this,"httpProviders"),wi(this,"events"),wi(this,"namespace"),wi(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=ci(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},C0=Object.defineProperty,T0=(e,t,i)=>t in e?C0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,$i=(e,t,i)=>T0(e,typeof t!="symbol"?t+"":t,i),q0=class{constructor(e){$i(this,"name","algorand"),$i(this,"client"),$i(this,"httpProviders"),$i(this,"events"),$i(this,"namespace"),$i(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const i=t||Je(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;e[t]=this.createHttpProvider(t,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);return typeof i>"u"?void 0:new st(new ut(i,ee("disableProviderPing")))}},U0=Object.defineProperty,D0=(e,t,i)=>t in e?U0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,vi=(e,t,i)=>D0(e,typeof t!="symbol"?t+"":t,i),k0=class{constructor(e){vi(this,"name","cip34"),vi(this,"client"),vi(this,"httpProviders"),vi(this,"events"),vi(this,"namespace"),vi(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const i=this.getCardanoRPCUrl(t),s=ci(t);e[s]=this.createHttpProvider(s,i)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||this.getCardanoRPCUrl(e);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},j0=Object.defineProperty,L0=(e,t,i)=>t in e?j0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,bi=(e,t,i)=>L0(e,typeof t!="symbol"?t+"":t,i),B0=class{constructor(e){bi(this,"name","elrond"),bi(this,"client"),bi(this,"httpProviders"),bi(this,"events"),bi(this,"namespace"),bi(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=ci(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},M0=Object.defineProperty,z0=(e,t,i)=>t in e?M0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ei=(e,t,i)=>z0(e,typeof t!="symbol"?t+"":t,i),H0=class{constructor(e){Ei(this,"name","multiversx"),Ei(this,"client"),Ei(this,"httpProviders"),Ei(this,"events"),Ei(this,"namespace"),Ei(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const s=ci(t);e[s]=this.createHttpProvider(s,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},V0=Object.defineProperty,K0=(e,t,i)=>t in e?V0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ii=(e,t,i)=>K0(e,typeof t!="symbol"?t+"":t,i),F0=class{constructor(e){Ii(this,"name","near"),Ii(this,"client"),Ii(this,"httpProviders"),Ii(this,"events"),Ii(this,"namespace"),Ii(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||Je(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;e[t]=this.createHttpProvider(t,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace);return typeof i>"u"?void 0:new st(new ut(i,ee("disableProviderPing")))}},G0=Object.defineProperty,W0=(e,t,i)=>t in e?G0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,_i=(e,t,i)=>W0(e,typeof t!="symbol"?t+"":t,i),Z0=class{constructor(e){_i(this,"name","tezos"),_i(this,"client"),_i(this,"httpProviders"),_i(this,"events"),_i(this,"namespace"),_i(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||Je(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace);return typeof i>"u"?void 0:new st(new ut(i))}},Y0=Object.defineProperty,J0=(e,t,i)=>t in e?Y0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Pi=(e,t,i)=>J0(e,typeof t!="symbol"?t+"":t,i),Q0=class{constructor(e){Pi(this,"name",Si),Pi(this,"client"),Pi(this,"httpProviders"),Pi(this,"events"),Pi(this,"namespace"),Pi(this,"chainId"),this.namespace=e.namespace,this.events=ee("events"),this.client=ee("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(rt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const i={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(s=>{const r=mc(s);i[`${r.namespace}:${r.reference}`]=this.createHttpProvider(s)}),i}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Je(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new st(new ut(i,ee("disableProviderPing")))}},X0=Object.defineProperty,eb=Object.defineProperties,tb=Object.getOwnPropertyDescriptors,lc=Object.getOwnPropertySymbols,ib=Object.prototype.hasOwnProperty,sb=Object.prototype.propertyIsEnumerable,jn=(e,t,i)=>t in e?X0(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Fs=(e,t)=>{for(var i in t||(t={}))ib.call(t,i)&&jn(e,i,t[i]);if(lc)for(var i of lc(t))sb.call(t,i)&&jn(e,i,t[i]);return e},sn=(e,t)=>eb(e,tb(t)),et=(e,t,i)=>jn(e,typeof t!="symbol"?t+"":t,i),rb=class rl{constructor(t){et(this,"client"),et(this,"namespaces"),et(this,"optionalNamespaces"),et(this,"sessionProperties"),et(this,"scopedProperties"),et(this,"events",new Cv.default),et(this,"rpcProviders",{}),et(this,"session"),et(this,"providerOpts"),et(this,"logger"),et(this,"uri"),et(this,"disableProviderPing",!1),this.providerOpts=t,this.logger=typeof(t==null?void 0:t.logger)<"u"&&typeof(t==null?void 0:t.logger)!="string"?t.logger:(0,Mn.default)(lr({level:(t==null?void 0:t.logger)||Qa})),this.disableProviderPing=(t==null?void 0:t.disableProviderPing)||!1}static async init(t){const i=new rl(t);return await i.initialize(),i}async request(t,i,s){const[r,n]=this.validateChain(i);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:Fs({},t),chainId:`${r}:${n}`,topic:this.session.topic,expiry:s})}sendAsync(t,i,s,r){const n=new Date().getTime();this.request(t,s,r).then(o=>i(null,hr(n,o))).catch(o=>i(o,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:dn("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}async authenticate(t,i){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(t),await this.cleanupPendingPairings();const{uri:s,response:r}=await this.client.authenticate(t,i);s&&(this.uri=s,this.events.emit("display_uri",s));const n=await r();if(this.session=n.session,this.session){const o=oc(this.session.namespaces);this.namespaces=Ks(this.namespaces,o),await this.persist("namespaces",this.namespaces),this.onConnect()}return n}on(t,i){this.events.on(t,i)}once(t,i){this.events.once(t,i)}removeListener(t,i){this.events.removeListener(t,i)}off(t,i){this.events.off(t,i)}get isWalletConnect(){return!0}async pair(t){const{uri:i,approval:s}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});i&&(this.uri=i,this.events.emit("display_uri",i));const r=await s();this.session=r;const n=oc(r.namespaces);return this.namespaces=Ks(this.namespaces,n),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(t,i){try{if(!this.session)return;const[s,r]=this.validateChain(t),n=this.getProvider(s);n.name===Si?n.setDefaultChain(`${s}:${r}`,i):n.setDefaultChain(r,i)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const i=this.client.pairing.getAll();if(Ri(i)){for(const s of i)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${i.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var t,i;if(this.client=this.providerOpts.client||await Rv.init({core:this.providerOpts.core,logger:this.providerOpts.logger||Qa,relayUrl:this.providerOpts.relayUrl||Tv,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(s){throw this.logger.error("Failed to get session",s),new Error(`The provided session: ${(i=(t=this.providerOpts)==null?void 0:t.session)==null?void 0:i.topic} doesn't exist in the Sign client`)}else{const s=this.client.session.getAll();this.session=s[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const t=[...new Set(Object.keys(this.session.namespaces).map(i=>cs(i)))];tn("client",this.client),tn("events",this.events),tn("disableProviderPing",this.disableProviderPing),t.forEach(i=>{if(!this.session)return;const s=y0(i,this.session),r=il(s),n=Ks(this.namespaces,this.optionalNamespaces),o=sn(Fs({},n[i]),{accounts:s,chains:r});switch(i){case"eip155":this.rpcProviders[i]=new P0({namespace:o});break;case"algorand":this.rpcProviders[i]=new q0({namespace:o});break;case"solana":this.rpcProviders[i]=new A0({namespace:o});break;case"cosmos":this.rpcProviders[i]=new R0({namespace:o});break;case"polkadot":this.rpcProviders[i]=new $0({namespace:o});break;case"cip34":this.rpcProviders[i]=new k0({namespace:o});break;case"elrond":this.rpcProviders[i]=new B0({namespace:o});break;case"multiversx":this.rpcProviders[i]=new H0({namespace:o});break;case"near":this.rpcProviders[i]=new F0({namespace:o});break;case"tezos":this.rpcProviders[i]=new Z0({namespace:o});break;default:this.rpcProviders[Si]?this.rpcProviders[Si].updateNamespace(o):this.rpcProviders[Si]=new Q0({namespace:o})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{var i;const{topic:s}=t;s===((i=this.session)==null?void 0:i.topic)&&this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{var i;const{params:s,topic:r}=t;if(r!==((i=this.session)==null?void 0:i.topic))return;const{event:n}=s;if(n.name==="accountsChanged"){const o=n.data;o&&Ri(o)&&this.events.emit("accountsChanged",o.map(nc))}else if(n.name==="chainChanged"){const o=s.chainId,c=s.event.data,a=cs(o),h=en(o)!==en(c)?`${a}:${en(c)}`:o;this.onChainChanged(h)}else this.events.emit(n.name,n.data);this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:i})=>{var s,r;if(t!==((s=this.session)==null?void 0:s.topic))return;const{namespaces:n}=i,o=(r=this.client)==null?void 0:r.session.get(t);this.session=sn(Fs({},o),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:i})}),this.client.on("session_delete",async t=>{var i;t.topic===((i=this.session)==null?void 0:i.topic)&&(await this.cleanup(),this.events.emit("session_delete",t),this.events.emit("disconnect",sn(Fs({},dn("USER_DISCONNECTED")),{data:t.topic})))}),this.on(rt.DEFAULT_CHAIN_CHANGED,t=>{this.onChainChanged(t,!0)})}getProvider(t){return this.rpcProviders[t]||this.rpcProviders[Si]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var i;this.getProvider(t).updateNamespace((i=this.session)==null?void 0:i.namespaces[t])})}setNamespaces(t){const{namespaces:i={},optionalNamespaces:s={},sessionProperties:r,scopedProperties:n}=t;this.optionalNamespaces=Ks(i,s),this.sessionProperties=r,this.scopedProperties=n}validateChain(t){const[i,s]=(t==null?void 0:t.split(":"))||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[i,s];if(i&&!Object.keys(this.namespaces||{}).map(o=>cs(o)).includes(i))throw new Error(`Namespace '${i}' is not configured. Please call connect() first with namespace config.`);if(i&&s)return[i,s];const r=cs(Object.keys(this.namespaces)[0]),n=this.rpcProviders[r].getDefaultChain();return[r,n]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}async onChainChanged(t,i=!1){if(!this.namespaces)return;const[s,r]=this.validateChain(t);if(!r)return;this.updateNamespaceChain(s,r),this.events.emit("chainChanged",r);const n=this.getProvider(s).getDefaultChain();i||this.getProvider(s).setDefaultChain(r),this.emitAccountsChangedOnChainChange({namespace:s,previousChainId:n,newChainId:t}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:t,previousChainId:i,newChainId:s}){var r,n;try{if(i===s)return;const o=(n=(r=this.session)==null?void 0:r.namespaces[t])==null?void 0:n.accounts;if(!o)return;const c=o.filter(a=>a.includes(`${s}:`)).map(nc);if(!Ri(c))return;this.events.emit("accountsChanged",c)}catch(o){this.logger.warn("Failed to emit accountsChanged on chain change",o)}}updateNamespaceChain(t,i){if(!this.namespaces)return;const s=this.namespaces[t]?t:`${t}:${i}`,r={chains:[],methods:[],events:[],defaultChain:i};this.namespaces[s]?this.namespaces[s]&&(this.namespaces[s].defaultChain=i):this.namespaces[s]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(t,i){var s;const r=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.setItem(`${Hs}/${t}${r}`,i)}async getFromStore(t){var i;const s=((i=this.session)==null?void 0:i.topic)||"";return await this.client.core.storage.getItem(`${Hs}/${t}${s}`)}async deleteFromStore(t){var i;const s=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.removeItem(`${Hs}/${t}${s}`)}async cleanupStorage(){var t;try{if(((t=this.client)==null?void 0:t.session.length)>0)return;const i=await this.client.core.storage.getKeys();for(const s of i)s.startsWith(Hs)&&await this.client.core.storage.removeItem(s)}catch(i){this.logger.warn("Failed to cleanup storage",i)}}};const nb=rb;var ob={};ul(ob,{EthereumProvider:()=>$b,OPTIONAL_EVENTS:()=>ol,OPTIONAL_METHODS:()=>nl,REQUIRED_EVENTS:()=>or,REQUIRED_METHODS:()=>nr,default:()=>al});var ab=Me(_s());const cb="wc",hb="ethereum_provider",lb=`${cb}@2:${hb}:`,ub="https://rpc.walletconnect.org/v1/",nr=["eth_sendTransaction","personal_sign"],nl=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_sendCalls","wallet_getCapabilities","wallet_getCallsStatus","wallet_showCallsStatus"],or=["chainChanged","accountsChanged"],ol=["chainChanged","accountsChanged","message","disconnect","connect"],db=async()=>{const{createAppKit:e}=await dl(()=>import("./core-BZ2u_pbs.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]));return e};var pb=Object.defineProperty,gb=Object.defineProperties,fb=Object.getOwnPropertyDescriptors,uc=Object.getOwnPropertySymbols,yb=Object.prototype.hasOwnProperty,mb=Object.prototype.propertyIsEnumerable,Ln=(e,t,i)=>t in e?pb(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ft=(e,t)=>{for(var i in t||(t={}))yb.call(t,i)&&Ln(e,i,t[i]);if(uc)for(var i of uc(t))mb.call(t,i)&&Ln(e,i,t[i]);return e},as=(e,t)=>gb(e,fb(t)),Ke=(e,t,i)=>Ln(e,typeof t!="symbol"?t+"":t,i);function ar(e){return Number(e[0].split(":")[1])}function Gs(e){return`0x${e.toString(16)}`}function wb(e){const{chains:t,optionalChains:i,methods:s,optionalMethods:r,events:n,optionalEvents:o,rpcMap:c}=e;if(!Ri(t))throw new Error("Invalid chains");const a={chains:t,methods:s||nr,events:n||or,rpcMap:Ft({},t.length?{[ar(t)]:c[ar(t)]}:{})},h=n==null?void 0:n.filter(f=>!or.includes(f)),l=s==null?void 0:s.filter(f=>!nr.includes(f));if(!i&&!o&&!r&&!(h!=null&&h.length)&&!(l!=null&&l.length))return{required:t.length?a:void 0};const p=(h==null?void 0:h.length)&&(l==null?void 0:l.length)||!i,u={chains:[...new Set(p?a.chains.concat(i||[]):i)],methods:[...new Set(a.methods.concat(r!=null&&r.length?r:nl))],events:[...new Set(a.events.concat(o!=null&&o.length?o:ol))],rpcMap:c};return{required:t.length?a:void 0,optional:i.length?u:void 0}}var al=class cl{constructor(){Ke(this,"events",new ab.EventEmitter),Ke(this,"namespace","eip155"),Ke(this,"accounts",[]),Ke(this,"signer"),Ke(this,"chainId",1),Ke(this,"modal"),Ke(this,"rpc"),Ke(this,"STORAGE_KEY",lb),Ke(this,"on",(t,i)=>(this.events.on(t,i),this)),Ke(this,"once",(t,i)=>(this.events.once(t,i),this)),Ke(this,"removeListener",(t,i)=>(this.events.removeListener(t,i),this)),Ke(this,"off",(t,i)=>(this.events.off(t,i),this)),Ke(this,"parseAccount",t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t),this.signer={},this.rpc={}}static async init(t){const i=new cl;return await i.initialize(t),i}async request(t,i){return await this.signer.request(t,this.formatChainId(this.chainId),i)}sendAsync(t,i,s){this.signer.sendAsync(t,i,this.formatChainId(this.chainId),s)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(t){var i;if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(t);const{required:s,optional:r}=wb(this.rpc);try{const n=await new Promise(async(c,a)=>{var h,l;this.rpc.showQrModal&&((h=this.modal)==null||h.open(),(l=this.modal)==null||l.subscribeState(u=>{!u.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),a(new Error("Connection request reset. Please try again.")))}));const p=t!=null&&t.scopedProperties?{[this.namespace]:t.scopedProperties}:void 0;await this.signer.connect(as(Ft({namespaces:Ft({},s&&{[this.namespace]:s})},r&&{optionalNamespaces:{[this.namespace]:r}}),{pairingTopic:t==null?void 0:t.pairingTopic,scopedProperties:p})).then(u=>{c(u)}).catch(u=>{var f;(f=this.modal)==null||f.showErrorMessage("Unable to connect"),a(new Error(u.message))})});if(!n)return;const o=co(n.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:o),this.setAccounts(o),this.events.emit("connect",{chainId:Gs(this.chainId)})}catch(n){throw this.signer.logger.error(n),n}finally{(i=this.modal)==null||i.close()}}async authenticate(t,i){var s;if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:t==null?void 0:t.chains});try{const r=await new Promise(async(o,c)=>{var a,h;this.rpc.showQrModal&&((a=this.modal)==null||a.open(),(h=this.modal)==null||h.subscribeState(l=>{!l.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),c(new Error("Connection request reset. Please try again.")))})),await this.signer.authenticate(as(Ft({},t),{chains:this.rpc.chains}),i).then(l=>{o(l)}).catch(l=>{var p;(p=this.modal)==null||p.showErrorMessage("Unable to connect"),c(new Error(l.message))})}),n=r.session;if(n){const o=co(n.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:o),this.setAccounts(o),this.events.emit("connect",{chainId:Gs(this.chainId)})}return r}catch(r){throw this.signer.logger.error(r),r}finally{(s=this.modal)==null||s.close()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",t=>{const{params:i}=t,{event:s}=i;s.name==="accountsChanged"?(this.accounts=this.parseAccounts(s.data),this.events.emit("accountsChanged",this.accounts)):s.name==="chainChanged"?this.setChainId(this.formatChainId(s.data)):this.events.emit(s.name,s.data),this.events.emit("session_event",t)}),this.signer.on("accountsChanged",t=>{this.accounts=this.parseAccounts(t),this.events.emit("accountsChanged",this.accounts)}),this.signer.on("chainChanged",t=>{const i=parseInt(t);this.chainId=i,this.events.emit("chainChanged",Gs(this.chainId)),this.persist()}),this.signer.on("session_update",t=>{this.events.emit("session_update",t)}),this.signer.on("session_delete",t=>{this.reset(),this.events.emit("session_delete",t),this.events.emit("disconnect",as(Ft({},dn("USER_DISCONNECTED")),{data:t.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",t=>{this.events.emit("display_uri",t)})}switchEthereumChain(t){this.request({method:"wallet_switchEthereumChain",params:[{chainId:t.toString(16)}]})}isCompatibleChainId(t){return typeof t=="string"?t.startsWith(`${this.namespace}:`):!1}formatChainId(t){return`${this.namespace}:${t}`}parseChainId(t){return Number(t.split(":")[1])}setChainIds(t){const i=t.filter(s=>this.isCompatibleChainId(s)).map(s=>this.parseChainId(s));i.length&&(this.chainId=i[0],this.events.emit("chainChanged",Gs(this.chainId)),this.persist())}setChainId(t){if(this.isCompatibleChainId(t)){const i=this.parseChainId(t);this.chainId=i,this.switchEthereumChain(i)}}parseAccountId(t){const[i,s,r]=t.split(":");return{chainId:`${i}:${s}`,address:r}}setAccounts(t){this.accounts=t.filter(i=>this.parseChainId(this.parseAccountId(i).chainId)===this.chainId).map(i=>this.parseAccountId(i).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(t){var i,s;const r=(i=t==null?void 0:t.chains)!=null?i:[],n=(s=t==null?void 0:t.optionalChains)!=null?s:[],o=r.concat(n);if(!o.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const c=r.length?(t==null?void 0:t.methods)||nr:[],a=r.length?(t==null?void 0:t.events)||or:[],h=(t==null?void 0:t.optionalMethods)||[],l=(t==null?void 0:t.optionalEvents)||[],p=(t==null?void 0:t.rpcMap)||this.buildRpcMap(o,t.projectId),u=(t==null?void 0:t.qrModalOptions)||void 0;return{chains:r==null?void 0:r.map(f=>this.formatChainId(f)),optionalChains:n.map(f=>this.formatChainId(f)),methods:c,events:a,optionalMethods:h,optionalEvents:l,rpcMap:p,showQrModal:!!(t!=null&&t.showQrModal),qrModalOptions:u,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,i){const s={};return t.forEach(r=>{s[r]=this.getRpcUrl(r,i)}),s}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=this.rpc.chains.length?ar(this.rpc.chains):ar(this.rpc.optionalChains),this.signer=await nb.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing,relayUrl:t.relayUrl,storage:t.storage,storageOptions:t.storageOptions,customStoragePrefix:t.customStoragePrefix,telemetryEnabled:t.telemetryEnabled,logger:t.logger}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let i;try{const s=await db(),{convertWCMToAppKitOptions:r}=await Promise.resolve().then(function(){return xb}),n=r(as(Ft({},this.rpc.qrModalOptions),{chains:[...new Set([...this.rpc.chains,...this.rpc.optionalChains])],metadata:this.rpc.metadata,projectId:this.rpc.projectId}));if(!n.networks.length)throw new Error("No networks found for WalletConnect·");i=s(as(Ft({},n),{universalProvider:this.signer,manualWCControl:!0}))}catch(s){throw console.warn(s),new Error("To use QR modal, please install @reown/appkit package")}if(i)try{this.modal=i}catch(s){throw this.signer.logger.error(s),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(t){if(!t)return;const{chains:i,optionalChains:s,rpcMap:r}=t;i&&Ri(i)&&(this.rpc.chains=i.map(n=>this.formatChainId(n)),i.forEach(n=>{this.rpc.rpcMap[n]=(r==null?void 0:r[n])||this.getRpcUrl(n)})),s&&Ri(s)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=s==null?void 0:s.map(n=>this.formatChainId(n)),s.forEach(n=>{this.rpc.rpcMap[n]=(r==null?void 0:r[n])||this.getRpcUrl(n)}))}getRpcUrl(t,i){var s;return((s=this.rpc.rpcMap)==null?void 0:s[t])||`${ub}?chainId=eip155:${t}&projectId=${i||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),i=this.session.namespaces[`${this.namespace}:${t}`]?this.session.namespaces[`${this.namespace}:${t}`]:this.session.namespaces[this.namespace];this.setChainIds(t?[this.formatChainId(t)]:i==null?void 0:i.accounts),this.setAccounts(i==null?void 0:i.accounts)}catch(t){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(t),await this.disconnect().catch(i=>this.signer.logger.warn(i))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(t){return typeof t=="string"||t instanceof String?[this.parseAccount(t)]:t.map(i=>this.parseAccount(i))}};const $b=al;var vb=Object.defineProperty,bb=Object.defineProperties,Eb=Object.getOwnPropertyDescriptors,dc=Object.getOwnPropertySymbols,Ib=Object.prototype.hasOwnProperty,_b=Object.prototype.propertyIsEnumerable,pc=(e,t,i)=>t in e?vb(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,hl=(e,t)=>{for(var i in t||(t={}))Ib.call(t,i)&&pc(e,i,t[i]);if(dc)for(var i of dc(t))_b.call(t,i)&&pc(e,i,t[i]);return e},Pb=(e,t)=>bb(e,Eb(t));function Sb(e){if(e)return{"--w3m-font-family":e["--wcm-font-family"],"--w3m-accent":e["--wcm-accent-color"],"--w3m-color-mix":e["--wcm-background-color"],"--w3m-z-index":e["--wcm-z-index"]?Number(e["--wcm-z-index"]):void 0,"--w3m-qr-color":e["--wcm-accent-color"],"--w3m-font-size-master":e["--wcm-text-medium-regular-size"],"--w3m-border-radius-master":e["--wcm-container-border-radius"],"--w3m-color-mix-strength":0}}const Ob=e=>{const[t,i]=e.split(":");return ll({id:i,caipNetworkId:e,chainNamespace:t,name:"",nativeCurrency:{name:"",symbol:"",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}})};function Ab(e){var t,i,s,r,n,o,c;const a=(t=e.chains)==null?void 0:t.map(Ob).filter(Boolean);if(a.length===0)throw new Error("At least one chain must be specified");const h=a.find(p=>{var u;return p.id===((u=e.defaultChain)==null?void 0:u.id)}),l={projectId:e.projectId,networks:a,themeMode:e.themeMode,themeVariables:Sb(e.themeVariables),chainImages:e.chainImages,connectorImages:e.walletImages,defaultNetwork:h,metadata:Pb(hl({},e.metadata),{name:((i=e.metadata)==null?void 0:i.name)||"WalletConnect",description:((s=e.metadata)==null?void 0:s.description)||"Connect to WalletConnect-compatible wallets",url:((r=e.metadata)==null?void 0:r.url)||"https://walletconnect.org",icons:((n=e.metadata)==null?void 0:n.icons)||["https://walletconnect.org/walletconnect-logo.png"]}),showWallets:!0,featuredWalletIds:e.explorerRecommendedWalletIds==="NONE"?[]:Array.isArray(e.explorerRecommendedWalletIds)?e.explorerRecommendedWalletIds:[],excludeWalletIds:e.explorerExcludedWalletIds==="ALL"?[]:Array.isArray(e.explorerExcludedWalletIds)?e.explorerExcludedWalletIds:[],enableEIP6963:!1,enableInjected:!1,enableCoinbase:!0,enableWalletConnect:!0,features:{email:!1,socials:!1}};if((o=e.mobileWallets)!=null&&o.length||(c=e.desktopWallets)!=null&&c.length){const p=[...(e.mobileWallets||[]).map(y=>({id:y.id,name:y.name,links:y.links})),...(e.desktopWallets||[]).map(y=>({id:y.id,name:y.name,links:{native:y.links.native,universal:y.links.universal}}))],u=[...l.featuredWalletIds||[],...l.excludeWalletIds||[]],f=p.filter(y=>!u.includes(y.id));f.length&&(l.customWallets=f)}return l}function ll(e){return hl({formatters:void 0,fees:void 0,serializers:void 0},e)}var xb=Object.freeze({__proto__:null,convertWCMToAppKitOptions:Ab,defineChain:ll});export{nl as A,or as C,ol as P,$b as Y,al as b,nr as f,ob as index_es_exports};
