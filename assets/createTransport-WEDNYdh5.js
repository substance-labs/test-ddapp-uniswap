import{BaseError as W,LruMap as G,stringToHex as K}from"./isAddress-P2vaZgmG.js";import{stringify as Q}from"./stringify-B82RFruy.js";import{AtomicReadyWalletRejectedUpgradeError as b,AtomicityNotSupportedError as P,BundleTooLargeError as g,ChainDisconnectedError as x,DuplicateIdError as N,HttpRequestError as O,InternalRpcError as v,InvalidInputRpcError as q,InvalidParamsRpcError as C,InvalidRequestRpcError as M,JsonRpcVersionUnsupportedError as T,LimitExceededRpcError as I,MethodNotFoundRpcError as A,MethodNotSupportedRpcError as p,ParseRpcError as D,ProviderDisconnectedError as S,ResourceNotFoundRpcError as j,ResourceUnavailableRpcError as B,SwitchChainError as L,TransactionRejectedRpcError as $,UnauthorizedProviderError as k,UnknownBundleIdError as z,UnknownRpcError as X,UnsupportedChainIdError as F,UnsupportedNonOptionalCapabilityError as H,UnsupportedProviderMethodError as J,UserRejectedRequestError as y}from"./rpc-nQR4Ijs4.js";async function Y(t){return new Promise(r=>setTimeout(r,t))}const U=256;let l=U,E;function Z(t=11){if(!E||l+t>U*2){E="",l=0;for(let r=0;r<U;r++)E+=(256+Math.random()*256|0).toString(16).substring(1)}return E.substring(l,l+++t)}const R=new G(8192);function _(t,{enabled:r=!0,id:o}){if(!r||!o)return t();if(R.get(o))return R.get(o);const d=t().finally(()=>R.delete(o));return R.set(o,d),d}function ee(t,{delay:r=100,retryCount:o=2,shouldRetry:d=()=>!0}={}){return new Promise((u,i)=>{const n=async({count:s=0}={})=>{const h=async({error:c})=>{const a=typeof r=="function"?r({count:s,error:c}):r;a&&await Y(a),n({count:s+1})};try{const c=await t();u(c)}catch(c){if(s<o&&await d({count:s,error:c}))return h({error:c});i(c)}};n()})}function te(t,r={}){return async(o,d={})=>{var u;const{dedupe:i=!1,methods:n,retryDelay:s=150,retryCount:h=3,uid:c}={...r,...d},{method:a}=o;if(!(n==null||(u=n.exclude)===null||u===void 0)&&u.includes(a))throw new p(new Error("method not supported"),{method:a});if(n!=null&&n.include&&!n.include.includes(a))throw new p(new Error("method not supported"),{method:a});const V=i?K(`${c}.${Q(o)}`):void 0;return _(()=>ee(async()=>{try{return await t(o)}catch(w){const e=w;switch(e.code){case D.code:throw new D(e);case M.code:throw new M(e);case A.code:throw new A(e,{method:o.method});case C.code:throw new C(e);case v.code:throw new v(e);case q.code:throw new q(e);case j.code:throw new j(e);case B.code:throw new B(e);case $.code:throw new $(e);case p.code:throw new p(e,{method:o.method});case I.code:throw new I(e);case T.code:throw new T(e);case y.code:throw new y(e);case k.code:throw new k(e);case J.code:throw new J(e);case S.code:throw new S(e);case x.code:throw new x(e);case L.code:throw new L(e);case H.code:throw new H(e);case F.code:throw new F(e);case N.code:throw new N(e);case z.code:throw new z(e);case g.code:throw new g(e);case b.code:throw new b(e);case P.code:throw new P(e);case 5e3:throw new y(e);default:throw w instanceof W?w:new X(e)}}},{delay:({count:w,error:e})=>{if(e&&e instanceof O){var m;const f=e==null||(m=e.headers)===null||m===void 0?void 0:m.get("Retry-After");if(f!=null&&f.match(/\d/))return Number.parseInt(f)*1e3}return~~(1<<w)*s},retryCount:h,shouldRetry:({error:w})=>re(w)}),{enabled:i,id:V})}}function re(t){return"code"in t&&typeof t.code=="number"?t.code===-1||t.code===I.code||t.code===v.code:t instanceof O&&t.status?t.status===403||t.status===408||t.status===413||t.status===429||t.status===500||t.status===502||t.status===503||t.status===504:!0}function de({key:t,methods:r,name:o,request:d,retryCount:u=3,retryDelay:i=150,timeout:n,type:s},h){const c=Z();return{config:{key:t,methods:r,name:o,request:d,retryCount:u,retryDelay:i,timeout:n,type:s},request:te(d,{methods:r,retryCount:u,retryDelay:i,uid:c}),value:h}}export{de as createTransport,Z as uid,Y as wait,ee as withRetry};
